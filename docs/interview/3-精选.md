# HTML模块

## 1 H5的新特性有哪些

- 画布(`Canvas`) API
- 地理(`Geolocation`) API
- 音频、视频API(`audio`,`video`)
- `localStorage`和`sessionStorage`
- `webworker`, `websocket`
- 新的一套标签 `header`,`nav`,`footer`,`aside`,`article`,`section`
- `web worker`是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。
- `HTML5 History`两个新增的API：`history.pushState` 和 `history.replaceState`，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。

> `Hash`就是`url` 中看到 `#` ,我们需要一个根据监听哈希变化触发的事件( `hashchange`) 事件。我们用 `window.location`处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。 可以为hash的改变添加监听事件：

```js
window.addEventListener("hashchange", funcRef, false)
```

- `WebSocket` 使用`ws`或`wss`协议，`Websocket`是一个持久化的协议，相对于HTTP这种非持久的协议来说。WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。`WebSocket`并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而`WebSocket`允许跨域通信

```js
// 创建一个Socket实例
var socket = new WebSocket('ws://localhost:8080');
// 打开Socket
socket.onopen = function(event) {
  // 发送一个初始化消息
  socket.send('I am the client and I\'m listening!');
  // 监听消息
  socket.onmessage = function(event) {
    console.log('Client received a message',event);
  };
  // 监听Socket的关闭
  socket.onclose = function(event) {
    console.log('Client notified socket has closed',event);
  };
  // 关闭Socket....
  //socket.close()
};
```

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_2-说一下-html5-drag-api)2 说一下 HTML5 drag api

- `dragstart`:事件主体是被拖放元素，在开始拖放被拖放元素时触发，。
- `darg`:事件主体是被拖放元素，在正在拖放被拖放元素时触发。
- `dragenter`:事件主体是目标元素，在被拖放元素进入某元素时触发。
- `dragover`:事件主体是目标元素，在被拖放在某元素内移动时触发。
- `dragleave`:事件主体是目标元素，在被拖放元素移出目标元素是触发。
- `drop`:事件主体是目标元素，在目标元素完全接受被拖放元素时触发。
- `dragend`:事件主体是被拖放元素，在整个拖放操作结束时触发

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_3-iframe有那些缺点)3 iframe有那些缺点

- `iframe`会阻塞主页面的`Onload`事件；
- 搜索引擎的检索程序无法解读这种页面，不利于`SEO`;
- `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
- 使用`iframe`之前需要考虑这两个缺点。如果需要使用`iframe`，最好是通过`javascript`
- 动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_4-如何实现浏览器内多个标签页之间的通信)4 如何实现浏览器内多个标签页之间的通信

1. 使用`WebSocket` 可以实现多个标签页之间的通信
2. 调用`localStorage`

- 在一个标签页里面使用 `localStorage.setItem(key,value)` 添加（修改、删除）内容；
- 在另一个标签页里面监听 `storage` 事件。
- 即可得到 `localstorge` 存储的值，实现不同标签页之间的通信

标签页1

```html
<input id="name">  
<input type="button" id="btn" value="提交">  
<script type="text/javascript">  
    $(function(){    
        $("#btn").click(function(){    
            var name=$("#name").val();    
            localStorage.setItem("name", name);   
        });    
    });    
</script>  
```

标签页2：

```html
<script type="text/javascript">  
    $(function(){   
        window.addEventListener("storage", function(event){    
            console.log(event.key + "=" + event.newValue);    
        });     
    });  
</script>  
```

1. 调用`cookie+setInterval()`

> 将要传递的信息存储在`cookie`中，每隔一定时间读取`cookie`信息，即可随时获取要传递的信息。

页面1：

```html
<input id="name">  
<input type="button" id="btn" value="提交">  
<script type="text/javascript">  
    $(function(){    
        $("#btn").click(function(){    
            var name=$("#name").val();    
            document.cookie="name="+name;    
        });    
    });    
</script>  
```

页面2：

```html
<script type="text/javascript">  
    $(function(){   
        function getCookie(key) {    
            return JSON.parse("{\"" + document.cookie.replace(/;\s+/gim,"\",\"").replace(/=/gim, "\":\"") + "\"}")[key];    
        }     
        setInterval(function(){    
            console.log("name=" + getCookie("name"));    
        }, 10000);    
    });  
</script>  
```

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_5-简述一下src与href的区别)5 简述一下src与href的区别

- `src`用于替换当前元素，`href`用于在当前文档和引用资源之间确立联系。
- `src`是`source`的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求`src`资源时会将其指向的资源下载并应用到文档内，例如`js`脚本，`img`图片和`frame`等元素

```text
<script src =”js.js”></script>
```

> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部

- `href`是`Hypertext Reference`的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加

```text
<link href=”common.css” rel=”stylesheet”/>
```

> 那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_6-知道的网页制作会用到的图片格式有哪些)6 知道的网页制作会用到的图片格式有哪些

> ```
> png-8`，`png-24`，`jpeg`，`gif`，`svg
> ```

但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物）

> 科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。

在质量相同的情况下，`WebP`格式图像的体积要比JPEG格式图像小`40%`

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_7-script标签中defer和async的区别)7 script标签中defer和async的区别

- `defer`:浏览器指示脚本在文档被解析后执行，`script`被异步加载后并不会立刻执行，而是等待文档被解析完毕后执 行。
- `async`:同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致`async`属性下的脚本是乱序的，对于 `script` 有先后依赖关系的情况，并不适用

![img](http://img-repo.poetries.top/images/20210314221335.png)

> 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的;绿色线代表 HTML 解析

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_8-说一下-web-worker)8 说一下 web worker

> 在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后， 页面才变成可相应。`web worker` 是运行在后台的 `js`，独立于其他脚本，不会影响页面你 的性能。并且通过 `postMessage` 将结果回传到主线程。这样在进行复杂操作的时候，就 不会阻塞主线程了

**如何创建 web worker:**

- 检测浏览器对于 `web worker` 的支持性
- 创建 `web worker` 文件(js，回传函数等)
- 创建 `web worker` 对象

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_9-用一个div模拟textarea的实现)9 用一个`div`模拟`textarea`的实现

- 给`div`添加`contenteditable=true` 即可

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_10-介绍下资源预加载-prefetch-preload)10 介绍下资源预加载 prefetch/preload

> 都是告知浏览器提前加载文件(图片、视频、js、css等)，但执行上是有区别的。

- `prefetch`：其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。`<link href="/js/xx.js" rel="prefetch">`
- `preload` : 可以指明哪些资源是在页面加载完成后即刻需要的，浏览器在主渲染机制介入前就进行预加载，这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。 `<link href="/js/xxx.js" rel="preload" as="script">`需要 `as` 指定资源类型**目前可用的属性类型有如下**：

```text
audio: 音频文件。
document: 一个将要被嵌入到<frame>或<iframe>内部的HTML文档。
embed: 一个将要被嵌入到<embed>元素内部的资源。
fetch: 那些将要通过fetch和XHR请求来获取的资源，比如一个ArrayBuffer或JSON文件。
font: 字体文件。
image: 图片文件。
object: 一个将会被嵌入到<embed>元素内的文件。
script: JavaScript文件。
style: 样式表。
track: WebVTT文件。
worker: 一个JavaScript的web worker或shared worker。
video: 视频文件。
```

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_11-介绍下-viewport)11 介绍下 viewport

```html
<meta name="viewport" content="width=500, initial-scale=1">
```

- `width`：页面宽度，可以取值具体的数字，也可以是 `device-width`，表示跟设备宽度相等。
- `height`：页面高度，可以取值具体的数字，也可以是 `device-height`，表示跟设备高度相等。
- `initial-scale`：初始缩放比例。
- `minimum-scale`：最小缩放比例。
- `maximum-scale`：最大缩放比例。
- `user-scalable`：是否允许用户缩放。

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_12-如何解决a标点击后hover事件失效的问题)12 如何解决a标点击后hover事件失效的问题?

改变a标签css属性的排列顺序

只需要记住`LoVe HAte`原则就可以了(爱恨原则)：

```text
link→visited→hover→active
```

比如下面错误的代码顺序：

```css
a:hover{
  color: green;
  text-decoration: none;
}
a:visited{ /* visited在hover后面，这样的话hover事件就失效了 */
  color: red;
  text-decoration: none;
}
```

正确的做法是将两个事件的位置调整一下。

注意⚠️各个阶段的含义：

- `a:link`：未访问时的样式，一般省略成a
- `a:visited`：已经访问后的样式
- `a:hover`：鼠标移上去时的样式
- `a:active`：鼠标按下时的样式

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_13-点击一个input依次触发的事件)13 点击一个input依次触发的事件

```javascript
const text = document.getElementById('text');
text.onclick = function (e) {
  console.log('onclick')
}
text.onfocus = function (e) {
  console.log('onfocus')
}
text.onmousedown = function (e) {
  console.log('onmousedown')
}
text.onmouseenter = function (e) {
  console.log('onmouseenter')
}
```

答案：

```javascript
'onmouseenter'
'onmousedown'
'onfocus'
'onclick'
```

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_14-有写过原生的自定义事件吗)14 有写过原生的自定义事件吗

**创建自定义事件**

原生自定义事件有三种写法：

1. 使用`Event`

```javascript
let myEvent = new Event('event_name');
```

1. 使用`customEvent` （可以传参数）

```javascript
let myEvent = new CustomEvent('event_name', {
	detail: {
		// 将需要传递的参数放到这里
		// 可以在监听的回调函数中获取到：event.detail
	}
})
```

1. 使用`document.createEvent('CustomEvent')和initCustomEvent()`

```javascript
let myEvent = document.createEvent('CustomEvent');// 注意这里是为'CustomEvent'
myEvent.initEvent(
	// 1. event_name: 事件名称
	// 2. canBubble: 是否冒泡
	// 3. cancelable: 是否可以取消默认行为
)
```

- `createEvent`：创建一个事件
- `initEvent`：初始化一个事件

可以看到，`initEvent`可以指定3个参数。

（有些文章中会说还有第四个参数`detail`，但是我查看了`W3C`上并没有这个参数，而且实践了一下也没有效果）

**事件的监听**

自定义事件的监听其实和普通事件的一样，使用`addEventListener`来监听：

```javascript
button.addEventListener('event_name', function (e) {})
```

**事件的触发**

触发自定义事件使用`dispatchEvent(myEvent)`。

注意⚠️，这里的参数是要自定义事件的对象(也就是`myEvent`)，而不是自定义事件的名称(`'myEvent'`)

**案例**

来看个案例吧：

```javascript
// 1.
// let myEvent = new Event('myEvent');
// 2.
// let myEvent = new CustomEvent('myEvent', {
//   detail: {
//     name: 'lindaidai'
//   }
// })
// 3.
let myEvent = document.createEvent('CustomEvent');
myEvent.initEvent('myEvent', true, true)

let btn = document.getElementsByTagName('button')[0]
btn.addEventListener('myEvent', function (e) {
  console.log(e)
  console.log(e.detail)
})
setTimeout(() => {
  btn.dispatchEvent(myEvent)
}, 2000)
```

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_15-addeventlistener和attachevent的区别)15 addEventListener和attachEvent的区别？

- 前者是标准浏览器中的用法，后者`IE8`以下
- `addEventListener`可有冒泡，可有捕获；`attachEvent`只有冒泡，没有捕获。
- 前者事件名不带`on`，后者带`on`
- 前者回调函数中的`this`指向当前元素，后者指向`window`

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_16-addeventlistener函数的第三个参数)16 addEventListener函数的第三个参数

第三个参数涉及到冒泡和捕获，是`true`时为捕获，是`false`则为冒泡。

> 或者是一个对象`{passive: true}`，针对的是`Safari`浏览器，禁止/开启使用滚动的时候要用到。

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_17-dom事件流是什么)17 DOM事件流是什么？

事件发生时会在元素节点之间按照**特定的顺序**传播，这个传播过程就叫做DOM事件流。

> DOM事件流分为三个阶段：

1. 捕获阶段：事件从`window`发出，自上而下向目标节点传播的阶段
2. 目标阶段：真正的目标阶段正在处理事件的阶段
3. 冒泡阶段：事件从目标节点自下而上向`window`传播的阶段

(注意⚠️：`JS`代码只能执行捕获或者冒泡其中一个阶段，要么是捕获要么是冒泡)

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_18-冒泡和捕获的具体过程)18 冒泡和捕获的具体过程

> 冒泡指的是：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发(当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了`click`事件就触发父元素的`click`)。

捕获则是从上层向下层传递，与冒泡相反。

（非常好记，你就想想水底有一个泡泡从下面往上传的，所以是冒泡）

来看看这个例子：

```html
<!-- 会依次执行 button li ul -->
<ul onclick="alert('ul')">
  <li onclick="alert('li')">
    <button onclick="alert('button')">点击</button>
  </li>
</ul>
<script>
  window.addEventListener('click', function (e) {
    alert('window')
  })
  document.addEventListener('click', function (e) {
    alert('document')
  })
</script>
```

- 冒泡结果：`button > li > ul > document > window`
- 捕获结果：`window > document > ul > li > button`

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_19-关于一些兼容性)19 关于一些兼容性

1. `event`的兼容性

- 其它浏览器`window.event`
- 火狐下没有`window.event`，所以用传入的参数`ev`代替
- 最终写法：`var oEvent = ev || window.event`

1. 事件源的兼容性

- 其它浏览器`event.target`
- `IE`下为`event.srcElement`
- 最终写法：`var target = event.target || event.srcElement`

1. 阻止事件冒泡

- 其它浏览器`event.stopPropagation()`
- `IE`下为`window.event.cancelBubble = true`

1. 阻止默认事件

- 其它浏览器`e.preventDefault()`
- `IE`下为`window.event.returnValue = false`

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_20-如何阻止冒泡和默认事件-兼容写法)20 如何阻止冒泡和默认事件(兼容写法)

阻止冒泡：

```javascript
function stopBubble (e) { // 阻止冒泡
  if (e && e.stopPropagation) {
    e.stopPropagation();
  } else {
    // 兼容 IE
    window.event.cancelBubble = true;
  }
}
function stopDefault (e) { // 阻止默认事件
  if (e && e.preventDefault) {
    e.preventDefault();
  } else {
    // 兼容 IE
    window.event.returnValue = false;
    return false;
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_21-所有的事件都有冒泡吗)21 所有的事件都有冒泡吗？

并不是所有的事件都有冒泡的，例如以下事件就没有：

- `onblur`
- `onfocus`
- `onmouseenter`
- `onmouseleave`

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_22-拖拽有哪些知识点)22 拖拽有哪些知识点

1. 可以通过给标签设置`draggable`属性来实现元素的拖拽，`img和a标签`默认是可以拖拽的
2. 拖拽者身上的三个事件：`ondragstart`、`ondrag`、`ondragend`
3. 拖拽要放到的元素：`ondragenter`、`ondragover`、`ondragleave`、`ondrap`

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_23-offset、scroll、client的区别)23 offset、scroll、client的区别

**client**:

- `oEvent.clientX`是指鼠标到可视区左边框的距离。
- `oEvent.clientY`是指鼠标到可视区上边框的距离。
- `clientWidth`是指可视区的宽度。
- `clientHeight`是指可视区的高度。
- `clientLeft`获取左边框的宽度。
- `clientTop`获取上边框的宽度。

**offset**:

- `offsetWidth`是指div的宽度（包括div的边框）
- `offsetHeight`是指div的高度（包括div的边框）
- `offsetLeft`是指div到整个页面左边框的距离（不包括div的边框）
- `offsetTop`是指div到整个页面上边框的距离（不包括div的边框）

**scroll**:

- `scrollTop`是指可视区顶部边框与整个页面上部边框的看不到的区域。
- `scrollLeft`是指可视区左边边框与整个页面左边边框的看不到的区域。
- `scrollWidth`是指左边看不到的区域加可视区加右边看不到的区域即整个页面的宽度（包括边框）
- `scrollHeight`是指上边看不到的区域加可视区加右边看不到的区域即整个页面的高度（包括边框）

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_24-target-blank-有哪些问题)24 target="_blank"有哪些问题？

**存在问题：**

1. 安全隐患：新打开的窗口可以通过`window.opener`获取到来源页面的`window`对象即使跨域也可以。某些属性的访问被拦截，是因为跨域安全策略的限制。 但是，比如修改`window.opener.location`的值，指向另外一个地址，这样新窗口有可能会把原来的网页地址改了并进行页面伪装来欺骗用户。
2. 新打开的窗口与原页面窗口共用一个进程，若是新页面有性能不好的代码也会影响原页面

**解决方案：**

1. 尽量不用`target="_blank"`
2. 如果一定要用，需要加上`rel="noopener"`或者`rel="noreferrer"`。这样新窗口的`window.openner`就是`null`了，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。(不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。)

## [#](http://interview.poetries.top/excellent-docs/1-HTML模块.html#_25-children以及childnodes的区别)25 children以及childNodes的区别

- `children`和只获取该节点下的所有`element`节点
- `childNodes`不仅仅获取`element`节点还会获取元素标签中的空白节点
- `firstElementChild`只获取该节点下的第一个`element`节点
- `firstChild`会获取空白节点

# 2 CSS模块

## 1 盒模型

content（元素内容） + padding（内边距） + border（边框） + margin（外边距）

> 页面渲染时，`dom` 元素所采用的 布局模型。可通过`box-sizing`进行设置。根据计算宽高的区域可分为

**box-sizing**

- `content-box`：默认值，总宽度 = `margin` + `border` + `padding` + `width`
- `border-box`：盒子宽度包含 `padding` 和 `border`，`总宽度 = margin + width`
- `inherit`：从父元素继承 `box-sizing` 属性

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_2-bfc)2 BFC

> 块级格式化上下文，是一个独立的渲染区域，让处于 `BFC` 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

> IE下为 `Layout`，可通过 `zoom:1` 触发

**触发条件:**

- 根元素
- `position: absolute/fixed`
- `display: inline-block / table`
- `float` 元素
- `ovevflow !== visible`

**规则:**

- 属于同一个 `BFC` 的两个相邻 `Box` 垂直排列
- 属于同一个 `BFC` 的两个相邻 `Box` 的 `margin` 会发生重叠
- `BFC` 中子元素的 `margin box` 的左边， 与包含块 (BFC) `border box`的左边相接触 (子元素 `absolute` 除外)
- `BFC` 的区域不会与 `float` 的元素区域重叠
- 计算 `BFC` 的高度时，浮动子元素也参与计算
- 文字层不会被浮动层覆盖，环绕于周围

**应用:**

- 阻止`margin`重叠
- 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个`div`都位于同一个 `BFC` 区域之中)
- 自适应两栏布局
- 可以阻止元素被浮动元素覆盖

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_3-层叠上下文)3 层叠上下文

> 元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。

**触发条件**

- 根层叠上下文(`html`)

- `position`

- ```
  css3
  ```

  属性

  - `flex`
  - `transform`
  - `opacity`
  - `filter`
  - `will-change`
  - `webkit-overflow-scrolling`

**层叠等级：层叠上下文在z轴上的排序**

- 在同一层叠上下文中，层叠等级才有意义
- `z-index`的优先级最高

![img](https://poetries1.gitee.io/img-repo/2020/09/111.png)

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_4-居中布局)4 居中布局

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#左右居中)左右居中

- 行内元素: `text-align: center`
- 定宽块状元素: 左右 `margin` 值为 `auto`
- 不定宽块状元素: `table`布局，`position + transform`

```css
/* 方案1 */
.wrap {
  text-align: center
}
.center {
  display: inline;
  /* or */
  /* display: inline-block; */
}
/* 方案2 */
.center {
  width: 100px;
  margin: 0 auto;
}
/* 方案2 */
.wrap {
  position: relative;
}
.center {
  position: absulote;
  left: 50%;
  transform: translateX(-50%);
}
```

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#上下垂直居中)上下垂直居中

- 定高：`margin`，`position + margin`(负值)
- 不定高：`position` + `transform`，`flex`，`IFC + vertical-align:middle`

```css
/* 定高方案1 */
.center {
  height: 100px;
  margin: 50px 0;   
}
/* 定高方案2 */
.center {
  height: 100px;
  position: absolute;
  top: 50%;
  margin-top: -25px;
}
/* 不定高方案1 */
.center {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
/* 不定高方案2 */
.wrap {
  display: flex;
  align-items: center;
}
.center {
  width: 100%;
}
/* 不定高方案3 */
/* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */
.wrap::before {
  content: '';
  height: 100%;
  display: inline-block;
  vertical-align: middle;
}
.wrap {
  text-align: center;
}
.center {
  display: inline-block;  
  vertical-align: middle;
}
```

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_5-选择器权重计算方式)5 选择器权重计算方式

> !important > 内联样式 = 外联样式 > ID选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 元素选择器 = 伪元素选择器 > 通配选择器 = 后代选择器 = 兄弟选择器

1. 属性后面加`!import`会覆盖页面内任何位置定义的元素样式
2. 作为`style`属性写在元素内的样式
3. `id`选择器
4. 类选择器
5. 标签选择器
6. 通配符选择器（`*`）
7. 浏览器自定义或继承

**同一级别：后写的会覆盖先写的**

> css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_6-清除浮动)6 清除浮动

1. 在浮动元素后面添加 `clear:both`的空 `div` 元素

```html
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
    <div style="clear:both"></div>
</div>
```

1. 给父元素添加 `overflow:hidden` 或者 `auto` 样式，触发`BFC`

```html
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
</div>
.container{
    width: 300px;
    background-color: #aaa;
    overflow:hidden;
    zoom:1;   /*IE6*/
}
```

1. 使用伪元素，也是在元素末尾添加一个点并带有 `clear: both` 属性的元素实现的。

```html
<div class="container clearfix">
    <div class="left"></div>
    <div class="right"></div>
</div>
.clearfix{
    zoom: 1; /*IE6*/
}
.clearfix:after{
    content: ".";
    height: 0;
    clear: both;
    display: block;
    visibility: hidden;
}
```

> 推荐使用第三种方法，不会在页面新增div，文档结构更加清晰

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_7-link-与-import-的区别)7 link 与 @import 的区别

- `link`功能较多，可以定义 `RSS`，定义 `Rel` 等作用，而`@import`只能用于加载 `css`
- 当解析到`link`时，页面会同步加载所引的 `css`，而`@import`所引用的 `css` 会等到页面加载完才被加载
- `@import`需要 `IE5` 以上才能使用
- `link`可以使用 `js` 动态引入，`@import`不行

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_8-css3的新特性)8 CSS3的新特性

- `transition`：过渡
- `transform`: 旋转、缩放、移动或倾斜
- `animation`: 动画
- `gradient`: 渐变
- `box-shadow`: 阴影
- `border-radius`: 圆角
- `word-break`: `normal|break-all|keep-all`; 文字换行(默认规则|单词也可以换行|只在半角空格或连字符换行)
- `text-overflow`: 文字超出部分处理
- `text-shadow`: 水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。
- `box-sizing`: `content-box|border-box` 盒模型
- 媒体查询 `@media screen and (max-width: 960px) {}`还有打印`print`

**transition和animation的区别**

> `Animation`和`transition`大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是`transition`需要触发一个事件才能改变属性，而`animation`不需要触发任何事件的情况下才会随时间改变属性值，并且`transition`为2帧，从`from .... to`，而`animation`可以一帧一帧的

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_9-css动画和过渡)9 CSS动画和过渡

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#animation-keyframes)animation / keyframes

- `animation-name`: 动画名称，对应`@keyframes`

- `animation-duration`: 间隔

- `animation-timing-function`: 曲线

- `animation-delay`: 延迟

- ```
  animation-iteration-count
  ```

  : 次数

  - `infinite`: 循环动画

- ```
  animation-direction
  ```

  : 方向

  - `alternate`: 反向播放

- ```
  animation-fill-mode
  ```

  : 静止模式

  - `forwards`: 停止时，保留最后一帧
  - `backwards`: 停止时，回到第一帧
  - `both`: 同时运用 `forwards / backwards`

- 常用钩子: `animationend`

> 动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现

- `translate`
- `scale`
- `rotate`
- `skew`
- `opacity`
- `color`

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#transform)transform

- 位移属性 translate( x , y )
- 旋转属性 rotate()
- 缩放属性 scale()
- 倾斜属性 skew()

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#transition)transition

- transition-property（过渡的属性的名称）。
- transition-duration（定义过渡效果花费的时间,默认是 0）。
- transition-timing-function:linear(匀速) ease(慢速开始，然后变快，然后慢速结束)（规定过渡效果的时间曲线，最常用的是这两个）。
- transition-delay（规定过渡效果何时开始。默认是 0）

> 般情况下，我们都是写一起的，比如：transition： width 2s ease 1s

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#关键帧动画animation)关键帧动画animation

> 一个关键帧动画，最少包含两部分，animation 属性及属性值（动画的名称和运行方式运行时间等）。@keyframes（规定动画的具体实现过程）

**animation 属性可以拆分为**

- animation-name 规定@keyframes 动画的名称。
- animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。
- animation-timing-function 规定动画的速度曲线。默认是 “ease”，常用的还有linear，同transtion 。
- animation-delay 规定动画何时开始。默认是 0。
- animation-iteration-count 规定动画被播放的次数。默认是 1，但我们一般用infinite，一直播放

> 而@keyframes的使用方法，可以是from->to（等同于0%和100%），也可以是从0%->100%之间任意个的分层设置。我们通过下面一个稍微复杂点的demo来看一下，基本上用到了上面说到的大部分知识

```text
eg:
   @keyframes mymove
  {
      from {top:0px;}
      to {top:200px;}
  }
 
等同于：
 
@keyframes mymove
{
 0%   {top:0px;}
 25%  {top:200px;}
 50%  {top:100px;}
 75%  {top:200px;}
 100% {top:0px;}
}
```

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#用css3动画使一个图片旋转)用css3动画使一个图片旋转

```css
#loader {

    display: block;

    position: relative;

    -webkit-animation: spin 2s linear infinite;

    animation: spin 2s linear infinite;

}

@-webkit-keyframes spin {

    0%   {

        -webkit-transform: rotate(0deg);

        -ms-transform: rotate(0deg);

        transform: rotate(0deg);

    }

    100% {

        -webkit-transform: rotate(360deg);

        -ms-transform: rotate(360deg);

        transform: rotate(360deg);

    }

}

@keyframes spin {

    0%   {

        -webkit-transform: rotate(0deg);

        -ms-transform: rotate(0deg);

        transform: rotate(0deg);

    }

    100% {

        -webkit-transform: rotate(360deg);

        -ms-transform: rotate(360deg);

        transform: rotate(360deg);

    }

}
```

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_10-有哪些方式-css-可以隐藏页面元素)10 有哪些方式（CSS）可以隐藏页面元素

- `opacity:0`：本质上是将元素的透明度将为0，就看起来隐藏了，但是依然占据空间且可以交互
- `visibility:hidden`: 与上一个方法类似的效果，占据空间，但是不可以交互了
- `overflow:hidden`: 这个只隐藏元素溢出的部分，但是占据空间且不可交互
- `display:none`: 这个是彻底隐藏了元素，元素从文档流中消失，既不占据空间也不交互，也不影响布局
- `z-index:-9999`: 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了
- `transform: scale(0,0)`: 平面变换，将元素缩放为0，但是依然占据空间，但不可交互

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_11-em、px、rem区别)11 em、px、rem区别

- `px`：绝对单位，页面按精确像素展示。
- `em`：相对单位，基准点为父节点字体的大小，如果自身定义了`font-size`按自身来计算（浏览器默认字体是`16px`），整个页面内1em不是一个固定的值。
- `rem`：相对单位，可理解为”`root em`”, 相对根节点html的字体大小来计算，`CSS3`新加属性，`chrome/firefox/IE9+`支持

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_12-flex)12 flex

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#使用过flex布局吗-flex-grow和flex-shrink属性有什么用)使用过flex布局吗？flex-grow和flex-shrink属性有什么用？

- `flex-grow`：项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
- `flex-shrink`：项目的缩小比例，默认为1，即如果空间不足，该项目将缩小

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_13-关于伪类-lvha-的解释)13 关于伪类 LVHA 的解释

> a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:`link`、`:visited`、`:hover`、`:active`；

**当链接未访问过时：**

- 当鼠标滑过a链接时，满足`:link`和`:hover`两种状态，要改变a标签的颜色，就必须将`:hover`伪类在`:link`伪 类后面声明；
- 当鼠标点击激活a链接时，同时满足`:link`、`:hover`、`:active`三种状态，要显示a标签激活时的样式（`:active`）， 必须将`:active`声明放到`:link`和`:hover`之后。因此得出`LVHA`这个顺序。
- 当链接访问过时，情况基本同上，只不过需要将`:link`换成`:visited`。

> 这个顺序能不能变？可以，但也只有`:link`和`:visited`可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_14-calc函数)14 calc函数

> calc函数是css3新增的功能，可以使用`calc()`计算`border、margin、pading、font-size`和width等属性设置动态值

```css
#div1 {
    position: absolute;
    left: 50px;
    width: calc( 100% / (100px * 2) );
    /* 兼容写法 */
    width: -moz-calc( 100% / (100px * 2) );
    width: -webkit-calc( 100% / (100px * 2) );
    border: 1px solid black;
}
```

**注意点：**

- 需要注意的是，运算符前后都需要保留一个空格，例如：`width: calc(100% - 10px)`;
- `calc()`函数支持 `"+"`, "`-"`, `"*"`, `"/"` 运算;
- 对于不支持 `calc()`的浏览器，整个属性值表达式将被忽略。不过我们可以对那些不支持`calc()`的浏览器，使用一个固定值作为回退。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_15-伪类和伪元素)15 伪类和伪元素

> `css`引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素都是用来修饰不在文档树中的部分

**伪类**

> 伪类存在的意义是为了通过选择器找到那些不存在DOM树中的信息以及不能被常规CSS选择器获取到的信息

1. 获取不存在与DOM树中的信息。比如a标签的`:link`、`visited`等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取；
2. 获取不能被常规CSS选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 `:first-child` 来获取到。

![img](http://blog.poetries.top/img-repo/2020/01/24.png)

**伪元素**

> 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过`:before`来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：`::before`，`::after`，`::first-line`，`::first-letter`，`::selection`、`::placeholder`等

> 因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素

**::after和:after的区别**

- 在实际的开发工作中，我们会看到有人把伪元素写成`:after`，这实际是 `CSS2` 与`CSS3`新旧标准的规定不同而导致的。
- `CSS2` 中的伪元素使用1个冒号，在 `CSS3` 中，为了区分伪类和伪元素，规定伪元素使用2个冒号。所以，对于 CSS2 标准的老伪元素，比如`:first-line`，`:first-letter`，`:before`，`:after`，写一个冒号浏览器也能识别，但对于 CSS3 标准的新伪元素，比如`::selection`，就必须写2个冒号了

**CSS3新增伪类有那些？**

- `p:first-of-type` 选择属于其父元素的首个`<p>`元素的每个`<p>` 元素。
- `p:last-of-type` 选择属于其父元素的最后 `<p>` 元素的每个`<p>` 元素。
- `p:only-of-type` 选择属于其父元素唯一的 `<p>`元素的每个 `<p>` 元素。
- `p:only-child` 选择属于其父元素的唯一子元素的每个 `<p>` 元素。
- `p:nth-child(2)` 选择属于其父元素的第二个子元素的每个 `<p>` 元素。
- `:after` 在元素之前添加内容,也可以用来做清除浮动。
- `:before` 在元素之后添加内容
- `:enabled`
- `:disabled` 控制表单控件的禁用状态。
- `:checked` 单选框或复选框被选中

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_16-浏览器是怎样解析-css-选择器的)16 浏览器是怎样解析 CSS 选择器的

- 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。
- 试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能， 最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_17-浏览器如何判断是否支持-webp-格式图片)17 浏览器如何判断是否支持 webp 格式图片

- 宽高判断法。通过创建`image`对象，将其`src`属性设置为`webp`格式的图片，然后在`onload`事件中获取图片的宽高，如 果能够获取，则说明浏览器支持`webp`格式图片。如果不能获取或者触发了`onerror`函数，那么就说明浏览器不支持webp格 式的图片
- canvas判断方法。我们可以动态的创建一个`canvas`对象，通过`canvas`的`toDataURL`将设置为webp格式，然后判断 返回值中是否含有`image/webp`字段，如果包含则说明支持`WebP`，反之则不支持

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_18-css加载问题)18 CSS加载问题

根据页面渲染流程可得知：

- `css`加载不会阻塞DOM树的解析;
- `css`加载会阻塞DOM树的渲染；
- `css`加载会阻塞后面js语句的执行

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_19-文字单超出显示省略号)19 文字单超出显示省略号

```css
div {
	width: 200px;
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
}
```

**文字多行超出显示省略号**

```css
div {
	width: 200px;
	display: -webkit-box;
	-webkit-box-orient: vertical;
	-webkit-line-clamp: 3;
	overflow: hidden;
}
```

该方法适用于WebKit浏览器及移动端。

**跨浏览器兼容方案：**

```css
p {
    position:relative;
    line-height:1.4em;
    /* 3 times the line-height to show 3 lines */
    height:4.2em;
    overflow:hidden;
}
p::after {
    content:"...";
    font-weight:bold;
    position:absolute;
    bottom:0;
    right:0;
    padding:0 20px 1px 45px;
}
```

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_20-页面变灰)20 页面变灰

```css
body {
	filter: grayscale(100%); /* 百分比或者 0~1 */
}
```

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_21-css中可继承的属性)21 CSS中可继承的属性

> 可继承的只有：`颜色`、`文字`、`字体间距`、`行高对齐方式`，`列表样式`。

所有元素可继承：`visibility`和`cursor`。

- 内联元素可继承：
  - letter-spacing
  - word-spacing
  - white-space
  - line-height
  - color
  - font
  - font-family
  - font-size
  - font-style
  - font-variant
  - font-weight
  - text-decoration
  - text-transform
  - direction
- 块状：`text-indent`和`text-align`。
- 列表元素可继承：`list-style`、`list-style-type`、`list-style-position`、`list-style-image`

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_22-常规流-文档流-是个怎样的排列关系)22 常规流(文档流)是个怎样的排列关系

将窗体自上而下分成一行一行,并在每行中按从左至右的挨次排放元素。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_23-inline-block的使用场景)23 inline-block的使用场景

1. 要设置某些子元素在一行或者多行内显示，尤其是排列方向一致的情况下，应尽量用`inline-block`。
2. 希望若干个元素平行排列，且在父元素中居中排列，此时可以用`inline-block`，且给父元素设`text-align: center`。
3. `inline-block`可以用一排`a {display: inline-block}`实现横向导航栏，无论是居左的导航栏还是居右的都适用。

对于第一种和第三种情况虽然都可以使用`float`来实现，不过`inline-block`会比它好一些，原因如下：

- 浮动会脱离文档流，导致父元素高度塌陷

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_24-position-fixed什么时候会失效)24 position: fixed什么时候会失效？

我们知道，设置了`position: fixed`固定定位属性的元素会脱离文档流，达到“超然脱俗”的境界。

> 也就是说此时给这种元素设置`top, left, right, bottom`等属性是根据**浏览器窗口**定位的，与其上级元素的位置无关。

但是有一种情况例外：

- 若是设置了`position: fixed`属性的元素，它的祖先元素设置了`transform`属性则会导致固定定位属性失效。
- 只要你的`transform`设置的不是`none`，都会影响到`position: fixed`，因为此时就会相对于祖先元素指定坐标，而不是浏览器窗口。

注意，这个特性表现，目前只在Chrome浏览器/FireFox浏览器下有。IE浏览器，包括IE11, `fixed`还是`fixed`的表现。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_25-说一下回流和重绘)25 说一下回流和重绘

**回流**：

触发条件：当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生`回流`的过程。

例如以下操作会触发回流：

1.一个 DOM 元素的几何属性变化，常见的几何属性有`width`、`height`、`padding`、`margin`、`left`、`top`、`border` 等等, 这个很好理解。 2. 使 DOM 节点发生`增减`或者`移动`。 3. 读写 `offset`族、`scroll`族和`client`族属性的时候，浏览器为了获取这些值，需要进行回流操作。 4. 调用 `window.getComputedStyle` 方法。

> 回流过程：由于DOM的结构发生了改变，所以需要从生成DOM这一步开始，重新经过`样式计算`、`生成布局树`、`建立图层树`、再到`生成绘制列表`以及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的。

**重绘**：

触发条件：

- 当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致`重绘`(`repaint`)。
- 重绘过程：由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，所以当发生重绘的时候，会跳过`生存布局树`和`建立图层树`的阶段，直接到`生成绘制列表`，然后继续进行分块、生成位图等后面一系列操作。

**如何避免触发回流和重绘**：

1. 避免频繁使用 style，而是采用修改`class`的方式。
2. 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。
3. 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的DOM操作不会引发回流和重绘
4. 使用`createDocumentFragment`进行批量的 DOM 操作。
5. 对于 resize、scroll 等进行防抖/节流处理。
6. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
7. 利用 CSS3 的`transform`、`opacity`、`filter`这些属性可以实现合成的效果，也就是`CPU`加速。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_26-gpu加速的原因)26 GPU加速的原因

> 在合成的情况下，会直接跳过布局和绘制流程，直接进入`非主线程`处理的部分，即直接交给`合成线程`处理。交给它处理有两大好处:

1. 能够充分发挥`GPU`的优势。合成线程生成位图的过程中会调用线程池，并在其中使用`GPU`进行加速生成，而 `GPU` 是擅长处理位图数据的。
2. 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_27-说说will-change)27 说说will-change

> `will-change`是`CSS3`新增的标准属性，它的作用很单纯，就是`"增强页面渲染性能"`，当我们在通过某些行为触发页面进行大面积绘制的时候，浏览器往往是没有准备，只能被动的使用CUP去计算和重绘，由于事先没有准备，对于一些复杂的渲染可能会出现掉帧、卡顿等情况。而`will-change`则是在真正的行为触发之前告诉浏览器可能要进行重绘了，相当于浏览器把CUP拉上了，能从容的面对接下来的变形。

**常用的语法主要有：**

- `whil-change: scroll-position;` 即将开始滚动
- `will-change: contents;` 内容要动画或者变化了
- `will-transform;` transform相关的属性要变化了(常用)

**注意：**

- `will-change`虽然可以开启加速，但是一定要适度使用
- 开启加速的代价为手机的耗电量会增加
- 使用时遵循最小化影响原则，可以对伪元素开启加速，独立渲染
- 可以写在伪类中，例如`hover`中，这样移出元素的时候就会自动`remove`掉`will-change`了
- 如果使用`JS`添加了`will-change`，注意要及时`remove`掉，方式就是`style.willChange = 'auto'`

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_28-z-index和background的覆盖关系)28 z-index和background的覆盖关系

![img](https://poetries1.gitee.io/img-repo/2020/09/4.png)

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_29-移动端中css你是使用什么单位)29 移动端中css你是使用什么单位

**比较常用的**：

- `em`：定义字体大小时以父级的字体大小为基准；定义长度单位时以当前字体大小为基准。例父级`font-size: 14px`，则子级`font-size: 1em;`为`font-size: 14px;`；若定义长度时，子级的字体大小如果为`14px`，则子级`width: 2em;`为`width: 24px`。
- `rem`：以根元素的字体大小为基准。例如`html`的`font-size: 14px`，则子级`1rem = 14px`。
- `%`：以父级的宽度为基准。例父级`width: 200px`，则子级`width: 50%;height:50%;`为`width: 100px;height: 100px;`
- `vw和vh`：基于视口的宽度和高度(视口不包括浏览器的地址栏工具栏和状态栏)。例如视口宽度为`1000px`，则`60vw = 600px;`
- `vmin和vmax`：`vmin`为当前`vw` 和`vh`中较小的一个值；`vmax`为较大的一个值。例如视口宽度`375px`，视口高度`812px`，则`100vmin = 375px;`，`100vmax = 812px;`

**不常用的：**

- `ex和ch`：`ex`以字符`"x"`的高度为基准；例如`1ex`表示和字符`"x"`一样长。`ch`以数字`"0"`的宽度为基准；例如`2ch`表示和2个数字`"0"`一样长。

**移动端布局总结**：

1. 移动端布局的方式主要使用rem和flex，可以结合各自的优点，比如flex布局很灵活，但是字体的大小不好控制，我们可以使用rem和媒体查询控制字体的大小，媒体查询视口的大小，然后不同的上视口大小下设置设置`html`的`font-size`。
2. 可单独制作移动端页面也可响应式pc端移动端共用一个页面。没有好坏，视情况而定，因势利导

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_30-rem和em的区别)30 rem和em的区别

**em:**

> 定义字体大小时以父级的字体大小为基准；定义长度单位时以当前字体大小为基准。例父级`font-size: 14px`，则子级`font-size: 1em;`为`font-size: 14px;`；若定义长度时，子级的字体大小如果为`14px`，则子级`width: 2em;`为`width: 24px`。

**rem:**

以根元素的字体大小为基准。例如`html`的`font-size: 14px`，则子级`1rem = 14px`。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_31-在移动端中怎样初始化根元素的字体大小)31 在移动端中怎样初始化根元素的字体大小

一个简易版的初始化根元素字体大小。

页面开头处引入下面这段代码，用于动态计算`font-size`：

(假设你需要的`1rem = 20px`)

```javascript
(function () {
  var html = document.documentElement;
  function onWindowResize() {
    html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';
  }
  window.addEventListener('resize', onWindowResize);
  onWindowResize();
})();
```

- `document.documentElement`：获取`document`的根元素
- `html.getBoundingClientRect().width`：获取`html`的宽度(窗口的宽度)
- 监听`window`的`resize`事件

一般还需要配合一个`meta`头：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no" />
```

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_32-移动端中不同手机html默认的字体大小都是一样的吗)32 移动端中不同手机html默认的字体大小都是一样的吗

> 如果没有人为取改变根元素字体大小的话，默认是`1rem = 16px`；根元素默认的字体大小是`16px`。

## [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#_33-编程题)33 编程题

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#画一条-0-5px-的线)画一条 0.5px 的线

- 采用 meta viewport 的方式 `<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />`
- 采用 `border-image` 的方式
- 采用 `transform: scale()` 的方式

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#如何画一个三角形)如何画一个三角形

三角形原理:边框的均分原理

```css
div {
  width:0px;
  height:0px;
  border-top:10px solid red; 
  border-right:10px solid transparent; 
  border-bottom:10px solid transparent; 
  border-left:10px solid transparent;
}
```

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#圆-半圆-椭圆)圆？半圆？椭圆？

```css
div {
  width: 100px;
  height: 100px;
  background-color: red;
  margin-top: 20px;
}
.box1 { /* 圆 */
  /* border-radius: 50%; */
  border-radius: 50px;
}
.box2 { /* 半圆 */
  height: 50px;
  border-radius: 50px 50px 0 0;
}
.box3 { /* 椭圆 */
  height: 50px;
  border-radius: 50px/25px; /* x轴/y轴 */
}
```

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#左边定宽-右边自适应方案)左边定宽，右边自适应方案

> float + margin，float + calc

```css
/* 方案1 */ 
.left {
  width: 120px;
  float: left;
}
.right {
  margin-left: 120px;
}
/* 方案2 */ 
.left {
  width: 120px;
  float: left;
}
.right {
  width: calc(100% - 120px);
  float: left;
}
```

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#左右两边定宽-中间自适应)左右两边定宽，中间自适应

> float，float + calc, 圣杯布局（设置BFC，margin负值法），flex

```css
.wrap {
  width: 100%;
  height: 200px;
}
.wrap > div {
  height: 100%;
}
/* 方案1 */
.left {
  width: 120px;
  float: left;
}
.right {
  float: right;
  width: 120px;
}
.center {
  margin: 0 120px; 
}
/* 方案2 */
.left {
  width: 120px;
  float: left;
}
.right {
  float: right;
  width: 120px;
}
.center {
  width: calc(100% - 240px);
  margin-left: 120px;
}
/* 方案3 */
.wrap {
  display: flex;
}
.left {
  width: 120px;
}
.right {
  width: 120px;
}
.center {
  flex: 1;
}
```

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#如何实现左侧宽度固定-右侧宽度自适应的布局)如何实现左侧宽度固定，右侧宽度自适应的布局

```html
<div class="box">
  <div class="box-left"></div>
  <div class="box-right"></div>
</div>
```

**利用float + margin实现**

```css
.box {
 height: 200px;
}

.box > div {
  height: 100%;
}

.box-left {
  width: 200px;
  float: left;
  background-color: blue;
}

.box-right {
  margin-left: 200px;
  background-color: red;
}
```

**利用calc计算宽度**

```css
.box {
 height: 200px;
}

.box > div {
  height: 100%;
}

.box-left {
  width: 200px;
  float: left;
  background-color: blue;
}

.box-right {
  width: calc(100% - 200px);
  float: right;
  background-color: red;
}
```

**利用float + overflow实现**

```css
.box {
 height: 200px;
}

.box > div {
  height: 100%;
}

.box-left {
  width: 200px;
  float: left;
  background-color: blue;
}

.box-right {
  overflow: hidden;
  background-color: red;
}
```

**利用flex实现**

```css
.box {
  height: 200px;
  display: flex;
}

.box > div {
  height: 100%;
}

.box-left {
  width: 200px;
  background-color: blue;
}

.box-right {
  flex: 1; // 设置flex-grow属性为1，默认为0
  overflow: hidden;
  background-color: red;
}
```

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#两边宽度固定中间自适应的三栏布局)两边宽度固定中间自适应的三栏布局

> 圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。

**圣杯布局**

```html
<style>
body{
    min-width: 550px;
}
#container{
    padding-left: 200px;
    padding-right: 150px;
}
#container .column{
    float: left;
}
#center{
    width: 100%;
}
#left{
    width: 200px;
    margin-left: -100%;
    position: relative;
    right: 200px;
}
#right{
    width: 150px;
    margin-right: -150px;
}
</style>
<div id="container">
    <div id="center" class="column">center</div>
    <div id="left" class="column">left</div>
    <div id="right" class="column">right</div>
</div>
```

**双飞翼布局**

```html
<style>
body {
    min-width: 500px;
}
#container {
    width: 100%;
}
.column {
    float: left;
}
#center {
    margin-left: 200px;
    margin-right: 150px;
}
#left {
    width: 200px;
    margin-left: -100%;
}
#right {
    width: 150px;
    margin-left: -150px;
}
</style>
<div id="container" class="column">
    <div id="center">center</div>
</div>
<div id="left" class="column">left</div>
<div id="right" class="column">right</div>
```

### [#](http://interview.poetries.top/excellent-docs/2-CSS模块.html#css画圆半圆扇形三角梯形)CSS画圆半圆扇形三角梯形

```css
div{
    margin: 50px;
    width: 100px;
    height: 100px;
    background: red;
}
/* 半圆 */
.half-circle{
    height: 50px;
    border-radius: 50px 50px 0 0;
}
/* 扇形 */
.sector{
    border-radius: 100px 0 0;
}
/* 三角 */
.triangle{
    width: 0px;
    height: 0px;
    background: none;
    border: 50px solid red;
    border-color: red transparent transparent transparent;
}
/* 梯形 */
.ladder{
    width: 50px;
    height: 0px;
    background: none;
    border: 50px solid red;
    border-color: red transparent transparent transparent;
}
```

# 3 JS模块

## 1 数据类型基础

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_1-1-js内置类型)1.1 JS内置类型

- `JS` 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（`Object`）。
- 基本类型有七种： `null`，`undefined`，`boolean`，`number`，`string`，`symbol`, `bigint`。
- 其中 `JS` 的数字类型是浮点类型的，没有整型。并且浮点类型基于 `IEEE 754`标准实现，在使用中会遇到某些 Bug。`NaN` 也属于 `number` 类型，并且 `NaN` 不等于自身。
- 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型。

**引用数据类型:**

- 对象`Object`（包含普通对象-`Object`，数组对象-`Array`，正则对象-`RegExp`，日期对象-`Date`，数学函数-`Math`，函数对象-`Function`）

```js
let a = 111 // 这只是字面量，不是 number 类型
a.toString() // 使用时候才会转换为对象类型
```

> 对象（`Object`）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。

```js
let a = { name: 'FE' }
let b = a
b.name = 'EF'
console.log(a.name) // EF
```

**说出下面运行的结果，解释原因。**

```js
function test(person) {
  person.age = 26
  person = {
    name: 'hzj',
    age: 18
  }
  return person
}
const p1 = {
  name: 'fyq',
  age: 19
}
const p2 = test(p1)
console.log(p1) // -> ?
console.log(p2) // -> ?
// 结果:
p1：{name: “fyq”, age: 26}
p2：{name: “hzj”, age: 18}
```

> 原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用`person.age = 26`确实改变了p1的值，但随后`person`变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_1-2-null和undefined区别)1.2 null和undefined区别

> `Undefined`类型只有一个值，即`undefined`。当声明的变量还未被初始化时，变量的默认值为`undefined`。用法

- 变量被声明了，但没有赋值时，就等于`undefined`。
- 调用函数时，应该提供的参数没有提供，该参数等于`undefined`。
- 对象没有赋值的属性，该属性的值为`undefined`。
- 函数没有返回值时，默认返回`undefined`

> `Null`类型也只有一个值，即`null`。`null`用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法

- 作为函数的参数，表示该函数的参数不是对象。
- 作为对象原型链的终点

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_1-3-null是对象吗-为什么)1.3 null是对象吗？为什么？

结论: `null`不是对象。

> 解释: 虽然 `typeof null` 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_1-4-1-tostring-为什么可以调用)1.4 '1'.toString()为什么可以调用？

其实在这个语句运行的过程中做了这样几件事情：

```text
var s = new Object('1');
s.toString();
s = null;
```

- 第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。
- 第二步: 调用实例方法。
- 第三步: 执行完方法立即销毁这个实例。

> 整个过程体现了`基本包装类型`的性质，而基本包装类型恰恰属于`基本数据类型`，包括Boolean, Number和String。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_1-5-0-1-0-2为什么不等于0-3)1.5 0.1+0.2为什么不等于0.3？

> 0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成`0.30000000000000004`

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_1-6-如何理解bigint)1.6 如何理解BigInt

**什么是BigInt?**

> `BigInt`是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

**为什么需要BigInt?**

在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？

> 这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的`Number`类型只能安全地表示`-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)）`，任何超出此范围的整数值都可能失去精度。

```text
console.log(999999999999999);  //=>10000000000000000
```

同时也会有一定的安全性问题:

```text
9007199254740992 === 9007199254740993;    // → true 居然是true!
```

**如何创建并使用BigInt？**

要创建`BigInt`，只需要在数字末尾追加`n`即可

```js
console.log( 9007199254740995n );    // → 9007199254740995n	
console.log( 9007199254740995 );     // → 9007199254740996
```

另一种创建`BigInt`的方法是用`BigInt()`构造函数

```js
BigInt("9007199254740995");    // → 9007199254740995n
```

简单使用如下:

```js
10n + 20n;    // → 30n	
10n - 20n;    // → -10n	
+10n;         // → TypeError: Cannot convert a BigInt value to a number	
-10n;         // → -10n	
10n * 20n;    // → 200n	
20n / 10n;    // → 2n	
23n % 10n;    // → 3n	
10n ** 3n;    // → 1000n	

const x = 10n;	
++x;          // → 11n	
--x;          // → 9n
console.log(typeof x);   //"bigint"
```

**值得警惕的点**

> `BigInt`不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 `Number` 的不变量，或者抛出异常。另外，更改 `+` 的行为也会破坏 `asm.js` 代码。

因为隐式类型转换可能丢失信息，所以不允许在`bigint`和 `Number` 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由`BigInt`或`Number`精确表示。

```text
10 + 10n;    // → TypeError
```

> 不能将`BigInt`传递给`Web api`和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。

```text
Math.max(2n, 4n, 6n);    // → TypeError
```

> 当 `Boolean` 类型与 `BigInt` 类型相遇时，`BigInt` 的处理方式与`Number`类似，换句话说，只要不是`0n`，`BigInt`就被视为`truthy`的值。

```text
if(0n){//条件判断为false

}
if(3n){//条件为true

}
```

- 元素都为BigInt的数组可以进行sort。
- `BigInt`可以正常地进行位运算，如`|`、`&`、`<<`、`>>`和`^`

**浏览器兼容性**

caniuse的结果:

![img](http://img-repo.poetries.top/images/20210309092826.png)

其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现，要正式成为规范，其实还有很长的路要走。

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_2-数据类型检测)2 数据类型检测

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_2-1-typeof类型判断)2.1 typeof类型判断

> 在写业务逻辑的时候，经常要用到JS数据类型的判断，面试常见的案例深浅拷贝也要用到数据类型的判断。

**typeof**

```js
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof undefined);       // undefined
console.log(typeof []);              // object 
console.log(typeof {});              // object
console.log(typeof function(){});    // function
console.log(typeof null);            // object
```

> 优点：能够快速区分基本数据类型 缺点：不能将`Object`、`Array`和`Null`区分，都返回`object`

**instanceof**

```js
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false  
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
```

- 优点：能够区分`Array`、`Object`和`Function`，适合用于判断自定义的类实例对象
- 缺点：`Number`，`Boolean`，`String`基本数据类型不能判断

**Object.prototype.toString.call()**

```js
var toString = Object.prototype.toString;
 
console.log(toString.call(2));                      //[object Number]
console.log(toString.call(true));                   //[object Boolean]
console.log(toString.call('str'));                  //[object String]
console.log(toString.call([]));                     //[object Array]
console.log(toString.call(function(){}));           //[object Function]
console.log(toString.call({}));                     //[object Object]
console.log(toString.call(undefined));              //[object Undefined]
console.log(toString.call(null));                   //[object Null]
```

- 优点：精准判断数据类型
- 缺点：写法繁琐不容易记，推荐进行封装后使用

**判断是否是promise对象**

```js
function isPromise (val) {
    return (
      typeof val.then === 'function' &&
      typeof val.catch === 'function'
    )
}
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_2-2-typeof-于-instanceof-区别)2.2 typeof 于 instanceof 区别

> `typeof` 对于基本类型，除了 `null`都可以显示正确的类型

```js
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof b // b 没有声明，但是还会显示 undefined
```

> ```
> typeof` 对于对象，除了函数都会显示 `object
> ```

```js
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```

> 对于 `null` 来说，虽然它是基本类型，但是会显示 `object`，这是一个存在很久了的 `Bug`

```text
typeof null // 'object'
```

> ```
> instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `iprototype
> ```

```js
// 我们也可以试着实现一下 instanceof
function instanceof(left, right) {
    // 获得类型的原型
    let prototype = right.prototype
    // 获得对象的原型
    left = left.__proto__
    // 判断对象的类型是否等于类型的原型
    while (true) {
    	if (left === null)
    		return false
    	if (prototype === left)
    		return true
    	left = left.__proto__
    }
}
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_2-3-object-is和-的区别)2.3 Object.is和===的区别

> `Object`在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是`+0`和`-0`，`NaN`和`NaN`。 源码如下

```js
function is(x, y) {
  if (x === y) {
    //运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    //NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
    //两个都是NaN的时候返回true
    return x !== x && y !== y;
  }
}
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_2-4-总结)2.4 总结

- ```
  typeof
  ```

  - 直接在计算机底层基于数据类型的值（二进制）进行检测
  - `typeof null`为`object` 原因是对象存在在计算机中，都是以`000`开始的二进制存储，所以检测出来的结果是对象
  - `typeof` 普通对象/数组对象/正则对象/日期对象 都是`object`
  - `typeof NaN === 'number'`

- ```
  instanceof
  ```

  - 检测当前实例是否属于这个类的
  - 底层机制：只要当前类出现在实例的原型上，结果都是true
  - 不能检测基本数据类型

- ```
  constructor
  ```

  - 支持基本类型
  - constructor可以随便改，也不准

- ```
  Object.prototype.toString.call([val])
  ```

  - 返回当前实例所属类信息

> 判断 `Target` 的类型，单单用 `typeof` 并无法完全满足，这其实并不是 `bug`，本质原因是 `JS` 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:

- 基本类型(`null`): 使用 `String(null)`
- 基本类型(`string / number / boolean / undefined`) + `function`: - 直接使用 `typeof`即可
- 其余引用类型(`Array / Date / RegExp Error`): 调用`toString`后根据`[object XXX]`进行判断

很稳的判断封装:

```js
let class2type = {}
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj
}
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-数据类型转换)3 数据类型转换

> 大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-1-转化规则)3.1 转化规则

- `-、*、/、%`：一律转换成数值后计算
- +：
  - 数字 + 字符串 = 字符串， 运算顺序是从左到右
  - 数字 + 对象， 优先调用对象的`valueOf -> toString`
  - 数字 + `boolean/null` -> 数字
  - 数字 + `undefined` -> `NaN`
- `[1].toString() === '1'`
- `{}.toString() === '[object object]'`
- `NaN !== NaN` 、+`undefined` 为 `NaN`

> 首先我们要知道，在 `JS` 中类型转换只有三种情况，分别是：

- 转换为布尔值
- 转换为数字
- 转换为字符串

![类型转换](http://blog.poetries.top/img-repo/2020/02/2.png)

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-2-转boolean)3.2 转Boolean

> 在条件判断时，除了 `undefined`，`null`， `false`， `NaN`， `''`， `0`， `-0`，其他所有值都转为 `true`，包括所有对象

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-3-对象转原始类型是根据什么流程运行的)3.3 对象转原始类型是根据什么流程运行的

> 对象转原始类型，会调用内置的`[ToPrimitive]`函数，对于该函数而言，其逻辑如下：

- 如果有`Symbol.toPrimitive()`方法，优先调用再返回
- 调用`valueOf()`，如果转换为原始类型，则返回
- 调用`toString()`，如果转换为原始类型，则返回
- 如果都没有返回原始类型，会报错

```js
var obj = {
  value: 3,
  valueOf() {
    return 4;
  },
  toString() {
    return '5'
  },
  [Symbol.toPrimitive]() {
    return 6
  }
}
console.log(obj + 1); // 输出7
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-4-如何让if-a-1-a-2-条件成立)3.4 如何让if(a == 1 && a == 2)条件成立

其实就是上一个问题的应用。

```js
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
console.log(a == 1 && a == 2);//true
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-5-四则运算符)3.5 四则运算符

> 它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"
```

- 对于第一行代码来说，触发特点一，所以将数字 `1` 转换为字符串，得到结果 `'11'`
- 对于第二行代码来说，触发特点二，所以将 `true` 转为数字 `1`
- 对于第三行代码来说，触发特点二，所以将数组通过 `toString`转为字符串 `1,2,3`，得到结果 `41,2,3`

> 另外对于加法还需要注意这个表达式 `'a' + + 'b'`

```text
'a' + + 'b' // -> "aNaN"
```

- 因为 `+ 'b'` 等于 `NaN`，所以结果为 `"aNaN"`，你可能也会在一些代码中看到过 `+ '1'`的形式来快速获取 `number` 类型。
- 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

```js
4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-6-比较运算符)3.6 比较运算符

- 如果是对象，就通过 `toPrimitive` 转换对象
- 如果是字符串，就通过 `unicode` 字符索引来比较

```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a > -1 // true
```

> 在以上代码中，因为 `a` 是对象，所以会通过 `valueOf` 转换为原始类型再比较值。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-7-结果是什么-为什么)3.7 [] == ![]结果是什么？为什么？

- `==` 中，左右两边都需要转换为数字然后进行比较
- `[]`转换为数字为`0`
- `![]` 首先是转换为布尔值，由于`[]`作为一个引用类型转换为布尔值为`true`
- 因此`![]`为`false`，进而在转换成数字，变为`0`
- `0 == 0` ， 结果为`true`

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-8-和-有什么区别)3.8 == 和 ===有什么区别

> ```
> ===`叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如`'1'===1`的结果是`false`，因为一边是`string`，另一边是`number
> ```

**==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下**

- 两边的类型是否相同，相同的话就比较值的大小，例如`1==2`，返回`false`
- 判断的是否是`null`和`undefined`，是的话就返回true
- 判断的类型是否是`String`和`Number`，是的话，把`String`类型转换成`Number`，再进行比较
- 判断其中一方是否是`Boolean`，是的话就把`Boolean`转换成`N`umber`，再进行比较
- 如果其中一方为`Object`，且另一方为`String`、`Number`或者`Symbol`，会将`Object`转换成字符串，再进行比较

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_4-闭包)4 闭包

> 红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，

> MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。
>
> - （其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_4-1-闭包产生的原因)4.1 闭包产生的原因

> 首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————`全局作用域`和`函数作用域`，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。 比如:

```js
var a = 1;
function f1() {
  var a = 2
  function f2() {
    var a = 3;
    console.log(a);//3
  }
}
```

> 在这段代码中，`f1`的作用域指向有全局作用域(`window`)和它本身，而`f2`的作用域指向全局作用域(`window`)、`f1`和它本身。而且作用域是从最底层向上找，直到找到全局作用域`window`为止，如果全局还没有的话就会报错。就这么简单一件事情

**闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:**

```js
function f1() {
  var a = 2
  function f2() {
    console.log(a);//2
  }
  return f2;
}
var x = f1();
x();
```

> 这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。

- 那是不是只有返回函数才算是产生了闭包呢？
- 回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：

```js
var f3;
function f1() {
  var a = 2
  f3 = function() {
    console.log(a);
  }
}
f1();
f3();
```

- 让`f1`执行，给`f3`赋值后，等于说现在`f3`拥有了`window、f1和f3本身这几个作用域的访问权限`，还是自底向上查找，最近是在`f1`中找到了`a`,因此输出2。
- 在这里是外面的变量`f3`存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_4-2-闭包有哪些表现形式)4.2 闭包有哪些表现形式

明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？

1. 返回一个函数。刚刚已经举例。
2. 作为函数参数传递

```js
var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
// 输出2，而不是1
foo();
```

1. 在定时器、事件监听、Ajax请求、跨窗口通信、`Web Workers`或者任何异步中，只要使用了回调函数，实际上就是在使用闭包

以下的闭包保存的仅仅是window和当前作用域。

```js
// 定时器
setTimeout(function timeHandler(){
  console.log('111');
}，100)

// 事件监听
$('#app').click(function(){
  console.log('DOM Listener');
})
```

1. `IIFE`(立即执行函数表达式)创建闭包, 保存了全局作用域`window`和当前函数的作用域，因此可以访问全局的变量

```js
var a = 2;
(function IIFE(){
  // 输出2
  console.log(a);
})();
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_4-3-如何解决下面的循环输出问题)4.3 如何解决下面的循环输出问题

```js
for(var i = 1; i <= 5; i ++){
  setTimeout(function timer(){
    console.log(i)
  }, 0)
}
```

为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好) 因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。

**解决方法：**

1. 利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中

```js
for(var i = 1;i <= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}
```

1. 给定时器传入第三个参数, 作为`timer`函数的第一个函数参数

```js
for(var i=1;i<=5;i++){
  setTimeout(function timer(j){
    console.log(j)
  }, 0, i)
}
```

1. 使用ES6中的let

```js
for(let i = 1; i <= 5; i++){
  setTimeout(function timer(){
    console.log(i)
  },0)
}
```

> let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:

```js
// i = 1
{
  setTimeout(function timer(){
    console.log(1)
  },0)
}
// i = 2
{
  setTimeout(function timer(){
    console.log(2)
  },0)
}
// i = 3
...
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_5-原型链)5 原型链

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_5-1-原型-构造函数-实例)5.1 原型/构造函数/实例

- 原型(`prototype`): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 `Firefox` 和 `Chrome` 中，每个`JavaScript`对象中都包含一个`__proto__`(非标准)的属性指向它爹(该对象的原型)，可`obj.__proto__`进行访问。
- 构造函数: 可以通过`new`来 新建一个对象 的函数。
- 实例: 通过构造函数和`new`创建出来的对象，便是实例。 实例通过`__proto__`指向原型，通过`constructor`指向构造函数。

> 以`Object`为例，我们常用的`Object`便是一个构造函数，因此我们可以通过它构建实例。

```js
// 实例
const instance = new Object()
```

> 则此时， 实例为`instance`, 构造函数为`Object`，我们知道，构造函数拥有一个`prototype`的属性指向原型，因此原型为:

```js
// 原型
const prototype = Object.prototype
```

**这里我们可以来看出三者的关系:**

- `实例.__proto__ === 原型`
- `原型.constructor === 构造函数`
- `构造函数.prototype === 原型`

```text
// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如: 
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false
实例.constructor === 构造函数
```

![img](https://poetries1.gitee.io/img-repo/2020/09/112.png)

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_5-2-原型对象和构造函数有何关系)5.2 原型对象和构造函数有何关系

- 在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个`prototype`属性，这个属性指向函数的原型对象。
- 当函数经过`new`调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个`__proto__`属性，指向构造函数的原型对象。

![img](http://img-repo.poetries.top/images/20210309102015.png)

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_5-3-能不能描述一下原型链)5.3 能不能描述一下原型链

> JavaScript对象通过`__proto__` 指向父类对象，直到指向`Object`对象为止，这样就形成了一个原型指向的链条, 即原型链

![img](http://img-repo.poetries.top/images/20210309102100.png)

- 对象的 `hasOwnProperty()` 来检查对象自身中是否含有该属性
- 使用 `in` 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 `true`

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-继承)6 继承

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-1-方式1-借助call)6.1 方式1: 借助call

```js
 function Parent1(){
    this.name = 'parent1';
  }
  function Child1(){
    Parent1.call(this);
    this.type = 'child1'
  }
  console.log(new Child1);
```

> 这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-2-方式2-借助原型链)6.2 方式2: 借助原型链

```js
 function Parent2() {
    this.name = 'parent2';
    this.play = [1, 2, 3]
  }
  function Child2() {
    this.type = 'child2';
  }
  Child2.prototype = new Parent2();

  console.log(new Child2());
```

看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：

```js
var s1 = new Child2();
var s2 = new Child2();
s1.play.push(4);
console.log(s1.play, s2.play);
```

可以看到控制台：

![img](http://img-repo.poetries.top/images/20210309103243.png)

> 明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。

那么还有更好的方式么？

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-3-方式3-将前两种组合)6.3 方式3：将前两种组合

```js
  function Parent3 () {
    this.name = 'parent3';
    this.play = [1, 2, 3];
  }
  function Child3() {
    Parent3.call(this);
    this.type = 'child3';
  }
  Child3.prototype = new Parent3();
  var s3 = new Child3();
  var s4 = new Child3();
  s3.play.push(4);
  console.log(s3.play, s4.play);
```

可以看到控制台：

![img](http://img-repo.poetries.top/images/20210309103312.png)

> 之前的问题都得以解决。但是这里又徒增了一个新问题，那就是`Parent3`的构造函数会多执行了一次（`Child3.prototype = new Parent3();`）。这是我们不愿看到的。那么如何解决这个问题？

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-4-方式4-组合继承的优化1)6.4 方式4: 组合继承的优化1

```js
  function Parent4 () {
    this.name = 'parent4';
    this.play = [1, 2, 3];
  }
  function Child4() {
    Parent4.call(this);
    this.type = 'child4';
  }
  Child4.prototype = Parent4.prototype;
```

这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：

```js
var s3 = new Child4();
var s4 = new Child4();
console.log(s3)
```

![img](http://img-repo.poetries.top/images/20210309103358.png)

> 子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-5-方式5-最推荐使用-组合继承的优化2)6.5 方式5(最推荐使用): 组合继承的优化2

```js
 function Parent5 () {
    this.name = 'parent5';
    this.play = [1, 2, 3];
  }
  function Child5() {
    Parent5.call(this);
    this.type = 'child5';
  }
  Child5.prototype = Object.create(Parent5.prototype);
  Child5.prototype.constructor = Child5;
```

这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-6-es6的extends被编译后的javascript代码)6.6 ES6的extends被编译后的JavaScript代码

> ES6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将ES6的代码编译成ES5让一些不支持新语法的浏览器也能运行。

那最后编译成了什么样子呢？

```js
function _possibleConstructorReturn(self, call) {
    // ...
    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
}

function _inherits(subClass, superClass) {
    // ...
    //看到没有
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}


var Parent = function Parent() {
    // 验证是否是 Parent 构造出来的 this
    _classCallCheck(this, Parent);
};

var Child = (function (_Parent) {
    _inherits(Child, _Parent);

    function Child() {
        _classCallCheck(this, Child);

        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));
    }

    return Child;
}(Parent));
```

> 核心是`_inherits`函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个`Object.setPrototypeOf(subClass, superClass)`，这是用来干啥的呢？

答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。

**追问: 面向对象的设计一定是好的设计吗？**

> 不一定。从继承的角度说，这一设计是存在巨大隐患的。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-7-从设计思想上谈谈继承本身的问题)6.7 从设计思想上谈谈继承本身的问题

假如现在有不同品牌的车，每辆车都有drive、music、addOil这三个方法。

```js
class Car{
  constructor(id) {
    this.id = id;
  }
  drive(){
    console.log("wuwuwu!");
  }
  music(){
    console.log("lalala!")
  }
  addOil(){
    console.log("哦哟！")
  }
}
class otherCar extends Car{}
```

现在可以实现车的功能，并且以此去扩展不同的车。

但是问题来了，新能源汽车也是车，但是它并不需要addOil(加油)。

如果让新能源汽车的类继承Car的话，也是有问题的，俗称"大猩猩和香蕉"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。

> 继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。

当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好。

**那如何来解决继承的诸多问题呢？**

> 用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。

顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。

```js
function drive(){
  console.log("wuwuwu!");
}
function music(){
  console.log("lalala!")
}
function addOil(){
  console.log("哦哟！")
}

let car = compose(drive, music, addOil);
let newEnergyCar = compose(drive, music);
```

> 代码干净，复用性也很好。这就是面向组合的设计方式。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_6-8-继承-简版)6.8 继承-简版

> 在 ES5 中，我们可以使用如下方式解决继承的问题

```js
function Super() {}
Super.prototype.getNumber = function() {
  return 1
}

function Sub() {}
let s = new Sub()
Sub.prototype = Object.create(Super.prototype, {
  constructor: {
    value: Sub,
    enumerable: false,
    writable: true,
    configurable: true
  }
})
```

- 以上继承实现思路就是将子类的原型设置为父类的原型
- 在 `ES6` 中，我们可以通过 `class` 语法轻松解决这个问题

```js
class MyDate extends Date {
  test() {
    return this.getTime()
  }
}
let myDate = new MyDate()
myDate.test()
```

- 但是 `ES6` 不是所有浏览器都兼容，所以我们需要使用 `Babel` 来编译这段代码。
- 如果你使用编译过得代码调用 `myDate.test()`你会惊奇地发现出现了报错

> 因为在 `JS` 底层有限制，如果不是由 `Date`构造出来的实例的话，是不能调用 `Date` 里的函数的。所以这也侧面的说明了：`ES6` 中的 `class` 继承与 `ES5` 中的一般继承写法是不同的。

- 既然底层限制了实例必须由 `Date` 构造出来，那么我们可以改变下思路实现继承

```js
function MyData() {

}
MyData.prototype.test = function () {
  return this.getTime()
}
let d = new Date()
Object.setPrototypeOf(d, MyData.prototype)
Object.setPrototypeOf(MyData.prototype, Date.prototype)
```

- 以上继承实现思路：先创建父类实例 => 改变实例原先的 `_proto__`转而连接到子类的 `prototype`=> 子类的 `prototype` 的 `__proto__` 改为父类的 `prototype`。
- 通过以上方法实现的继承就可以完美解决 `JS` 底层的这个限制

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_7-this)7 this

> 我们先来看几个函数调用的场景

```js
function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
```

- 对于直接调用 `foo` 来说，不管 `foo` 函数被放在了什么地方，`this` 一定是`window`
- 对于 `obj.foo()` 来说，我们只需要记住，谁调用了函数，谁就是 `this`，所以在这个场景下 `foo` 函数中的 `this` 就是 `obj` 对象
- 对于 `new` 的方式来说，`this` 被永远绑定在了 `c` 上面，不会被任何方式改变 `this`

> 说完了以上几种情况，其实很多代码中的 `this` 应该就没什么问题了，下面让我们看看箭头函数中的 `this`

```js
function a() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
console.log(a()()())
```

- 首先箭头函数其实是没有 `this` 的，箭头函数中的 `this` 只取决包裹箭头函数的第一个普通函数的 `this`。在这个例子中，因为包裹箭头函数的第一个普通函数是 `a`，所以此时的 `this` 是 `window`。另外对箭头函数使用 `bind`这类函数是无效的。
- 最后种情况也就是 `bind` 这些改变上下文的 `API` 了，对于这些函数来说，`this` 取决于第一个参数，如果第一个参数为空，那么就是 `window`。
- 那么说到 `bind`，不知道大家是否考虑过，如果对一个函数进行多次 `bind`，那么上下文会是什么呢？

```js
let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // => ?
```

> 如果你认为输出结果是 `a`，那么你就错了，其实我们可以把上述代码转换成另一种形式

```js
// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()
```

> 可以从上述代码中发现，不管我们给函数 `bind` 几次，`fn` 中的 `this` 永远由第一次 `bind` 决定，所以结果永远是 `window`

```js
let a = { name: 'poetries' }
function foo() {
  console.log(this.name)
}
foo.bind(a)() // => 'poetries'
```

> 以上就是 `this` 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 `this` 最终指向哪里。

> 首先，`new` 的方式优先级最高，接下来是 `bind` 这些函数，然后是 `obj.foo()` 这种调用方式，最后是 `foo` 这种调用方式，同时，箭头函数的 `this` 一旦被绑定，就不会再被任何方式所改变。

![image.png](https://poetries1.gitee.io/img-repo/2020/07/2.png)

**总结**

> `this`执行主体，谁把它执行的和在哪创建的在哪执行的都没有必然的关系

- 函数执行，看方法前面是否有点，没有点`this`是`window`(严格模式下是`undefined`)，有点，点前面是谁·this·就是谁
- 给当前元素的某个事件行为绑定方法，当事件行为触发，方法中的this是当前元素本身（排除`attachEvent`）
- 构造函数体中`this`是当前类的实例
- 箭头函数中没有执行主体，所用到的this都是所处上下文中的`this`
- 可以基于`Function.prototype`上的`call/apply/bind`改变`this`指向

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_8-内存机制)8 内存机制

> 网上的资料基本是这样说的: 基本数据类型用栈存储，引用数据类型用堆存储。

看起来没有错误，但实际上是有问题的。可以考虑一下闭包的情况，如果变量存在栈中，那函数调用完栈顶空间销毁，闭包变量不就没了吗？

其实还是需要补充一句:

> 闭包变量是存在堆内存中的。

**具体而言，以下数据类型存储在栈中:**

- `boolean`
- `null`
- `undefined`
- `number`
- `string`
- `symbol`
- `bigint`

而所有的对象数据类型存放在堆中。

> 值得注意的是，对于赋值操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。

因此会有下面的情况:

```js
let obj = { a: 1 };
let newObj = obj;
newObj.a = 2;
console.log(obj.a);//变成了2
```

- 之所以会这样，是因为 `obj` 和 `newObj` 是同一份堆空间的地址，改变`newObj`，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。 当然，你可能会问: 为什么不全部用栈来保存呢？
- 首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:

当然，你可能会问: 为什么不全部用栈来保存呢？

首先，对于系统栈来说，它的功能除了保存变量之外，还有`创建并切换函数执行上下文的功能`。举个例子:

```js
function f(a) {
  console.log(a);
}

function func(a) {
  f(a);
}

func(1);
```

- 假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程：
- 调用func, 将 func 函数的上下文压栈，ESP指向栈顶。
- 执行func，又调用f函数，将 f 函数的上下文压栈，ESP 指针上移。
- 执行完 f 函数，将ESP 下移，f函数对应的栈顶空间被回收。
- 执行完 func，ESP 下移，func对应的空间被回收。

图示如下:

![img](http://img-repo.poetries.top/images/20210309114827.png)

- 因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！
- 不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_9-执行上下文)9 执行上下文

> 当执行 JS 代码时，会产生三种执行上下文

- 全局执行上下文
- 函数执行上下文
- `eval` 执行上下文

> 每个执行上下文中都有三个重要的属性

- 变量对象（`VO`），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问
- 作用域链（`JS` 采用词法作用域，也就是说变量的作用域是在定义时就决定了）
- `this`

```js
var a = 10
function foo(i) {
  var b = 20
}
foo()
```

> 对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。

```js
stack = [
    globalContext,
    fooContext
]
```

> 对于全局上下文来说，`VO`大概是这样的

```js
globalContext.VO === globe
globalContext.VO = {
    a: undefined,
	foo: <Function>,
}
```

> 对于函数 `foo` 来说，`VO` 不能访问，只能访问到活动对象（`AO`）

```js
fooContext.VO === foo.AO
fooContext.AO {
    i: undefined,
	b: undefined,
    arguments: <>
}
// arguments 是函数独有的对象(箭头函数没有)
// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素
// 该对象中的 `callee` 属性代表函数本身
// `caller` 属性代表函数的调用者
```

> 对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 `[[Scope]]`属性查找上级变量

```js
fooContext.[[Scope]] = [
    globalContext.VO
]
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO
fooContext.Scope = [
    fooContext.VO,
    globalContext.VO
]
```

> 接下来让我们看一个老生常谈的例子，`var`

```js
b() // call b
console.log(a) // undefined

var a = 'Hello world'

function b() {
	console.log('call b')
}
```

> 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 `VO`），`JS` 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 `undefined`，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。

- 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升

```js
b() // call b second

function b() {
	console.log('call b fist')
}
function b() {
	console.log('call b second')
}
var b = 'Hello world'
```

> `var`会产生很多错误，所以在 `ES6`中引入了 `let`。`let`不能在声明前使用，但是这并不是常说的 `let` 不会提升，`let` 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。

- 对于非匿名的立即执行函数需要注意以下一点

```js
var foo = 1
(function foo() {
    foo = 10
    console.log(foo)
}()) // -> ƒ foo() { foo = 10 ; console.log(foo) }
```

> 因为当 `JS` 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 `foo`，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。

```js
specialObject = {};

Scope = specialObject + Scope;

foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}

delete Scope[0]; // remove specialObject from the front of scope chain
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#小结)小结

> 执行上下文可以简单理解为一个对象:

**它包含三个部分:**

- 变量对象(`VO`)
- 作用域链(词法作用域)
- `this`指向

**它的类型:**

- 全局执行上下文
- 函数执行上下文
- `eval`执行上下文

**代码执行过程:**

- 创建 全局上下文 (`global EC`)
- 全局执行上下文 (`caller`) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (`callee`) 被`push`到执行栈顶层
- 函数执行上下文被激活，成为 `active EC`, 开始执行函数中的代码，`caller` 被挂起
- 函数执行完后，`callee` 被`pop`移除出执行栈，控制权交还全局上下文 (`caller`)，继续执行

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_10-变量提升)10 变量提升

> 当执行 `JS` 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。

```js
b() // call b
console.log(a) // undefined

var a = 'Hello world'

function b() {
    console.log('call b')
}
```

> 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，`JS` 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 `undefined`，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用

- 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升

```js
b() // call b second

function b() {
    console.log('call b fist')
}
function b() {
    console.log('call b second')
}
var b = 'Hello world'
```

> `var` 会产生很多错误，所以在 ES6中引入了 `let`。`let`不能在声明前使用，但是这并不是常说的 `let` 不会提升，`let`提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_11-模块化)11 模块化

> 模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 在浏览器中使用 `ES6` 的模块化支持，在 `Node` 中使用 `commonjs` 的模块化支持。

**分类:**

- `es6: import / export`
- `commonjs: require / module.exports / exports`
- `amd: require / defined`

**require与import的区别**

- `require`支持 动态导入，`import`不支持，正在提案 (`babel` 下可支持)
- `require`是 同步 导入，`impor`t属于 异步 导入
- `require`是 值拷贝，导出值变化不会影响导入值；`import`指向 内存地址，导入值会随导出值而变化

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_12-settimeout、promise、async-await-的区别)12 setTimeout、Promise、Async / Await 的区别

- 首先，我们先来了解一下基本概念：
  - js EventLoop 事件循环机制:
  - JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)
- 宏任务：包括整体代码script，setTimeout，setInterval
- 微任务：Promise.then(非new Promise)，process.nextTick(node中)
- 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。
- 注意： setTimeOut并不是直接的把你的回掉函数放进上述的异步队列中去，而是在定时器的时间到了之后，把回掉函数放到执行异步队列中去。如果此时这个队列已经有很多任务了，那就排在他们的后面。这也就解释了为什么setTimeOut为什么不能精准的执行的问题了。
- setTimeout执行需要满足两个条件：
  - 主进程必须是空闲的状态，如果到时间了，主进程不空闲也不会执行你的回掉函数
  - 这个回掉函数需要等到插入异步队列时前面的异步函数都执行完了，才会执行
- 上面是比较官方的解释，说一下自己的理解吧：
  - 了解了什么是宏任务和微任务，就好理解多了，首先执行 宏任务 => 微任务的Event Queue => 宏任务的Event Queue
- promise、async/await
  - 首先，new Promise是同步的任务，会被放到主进程中去立即执行。而.then()函数是异步任务会放到异步队列中去，那什么时候放到异步队列中去呢？当你的promise状态结束的时候，就会立即放进异步队列中去了。
  - 带async关键字的函数会返回一个promise对象，如果里面没有await，执行起来等同于普通函数；如果没有await，async函数并没有很厉害是不是
  - await 关键字要在 async 关键字函数的内部，await 写在外面会报错；await如同他的语意，就是在等待，等待右侧的表达式完成。此时的await会让出线程，阻塞async内后续的代码，先去执行async外的代码。等外面的同步代码执行完毕，才会执行里面的后续代码。就算await的不是promise对象，是一个同步函数，也会等这样操作

![img](https://pic2.zhimg.com/80/v2-9540801abdfb378ae5120b0df9a96059_1440w.jpg)

根据图片显示我们来整理一下流程：

- 执行`console.log('script start')`，输出`script start`；
- 执行`setTimeout`，是一个异步动作，放入宏任务异步队列中；
- 执行`async1()`，输出`async1 start`，继续向下执行；
- 执行`async2()`，输出`async2`，并返回了一个`promise`对象，`await`让出了线程，把返回的promise加入了微任务异步队列，所以`async1()`下面的代码也要等待上面完成后继续执行;
- 执行 `new Promise`，输出`promise1`，然后将`resolve`放入微任务异步队列；
- 执行`console.log('script end')`，输出`script end`；
- 到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务
- 接下来执行`resolve`（`async2`返回的`promise`返回的），输出了`async1 end`。
- 然后执行`resolve`（`new Promise`的），输出了`promise2`
- 最后执行`setTimeout`，输出了`settimeout`

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_13-async原理)13 async原理

> `async/await`语法糖就是使用`Generator`函数+自动执行器来运作的

```js
// 定义了一个promise，用来模拟异步请求，作用是传入参数++
function getNum(num){
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(num+1)
        }, 1000)
    })
}

//自动执行器，如果一个Generator函数没有执行完，则递归调用
function asyncFun(func){
  var gen = func();

  function next(data){
    var result = gen.next(data);
    if (result.done) return result.value;
    result.value.then(function(data){
      next(data);
    });
  }

  next();
}

// 所需要执行的Generator函数，内部的数据在执行完成一步的promise之后，再调用下一步
var func = function* (){
  var f1 = yield getNum(1);
  var f2 = yield getNum(f1);
  console.log(f2) ;
};
asyncFun(func);
```

- 在执行的过程中，判断一个函数的`promise`是否完成，如果已经完成，将结果传入下一个函数，继续重复此步骤
- 每一个 `next()` 方法返回值的 `value` 属性为一个 `Promise` 对象，所以我们为其添加 `then` 方法， 在 `then` 方法里面接着运行 `next` 方法挪移遍历器指针，直到 `Generator`函数运行完成

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_14-js-整数是怎么表示的)14 JS 整数是怎么表示的

> 通过 Number 类型来表示，遵循 IEEE754 标准，通过 64 位来表示一个数字，（1 + 11 + 52），最大安全数字是 Math.pow(2, 53) - 1，对于 16 位十进制。（符号位 + 指数位 + 小数部分有效位）

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_15-number-的存储空间是多大-如果后台发送了一个超过最大自己的数字怎么办)15 Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办

> Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_16-settimeout-fn-0-多久才执行-event-loop)16 setTimeout(fn, 0)多久才执行，Event Loop

> setTimeout 按照顺序放到队列里面，然后等待函数调用栈清空之后才开始执行，而这些操作进入队列的顺序，则由设定的延迟时间来决定

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_17-js脚本加载问题-async、defer问题)17 js脚本加载问题，async、defer问题

- 如果依赖其他脚本和 DOM 结果，使用 defer
- 如果与 DOM 和其他脚本依赖不强时，使用 async

**script 引入方式**

- `html` 静态`<script>`引入
- `js` 动态插入`<script>`
- `<script defer>`: 异步加载，元素解析完成后执行
- `<script async>`: 异步加载，但执行时会阻塞元素渲染

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_18-javascript垃圾回收机制的了解)18 JavaScript垃圾回收机制的了解

- 对于在JavaScript中的字符串，对象，数组是没有固定大小的，只有当对他们进行动态分配存储时，解释器就会分配内存来存储这些数据，当JavaScript的解释器消耗完系统中所有可用的内存时，就会造成系统崩溃。
- 内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存越占越大，极端情况下可以导致系统崩溃，服务器宕机。
- JavaScript有自己的一套垃圾回收机制，JavaScript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。
- 针对JavaScript的来及回收机制有以下两种方法（常用）：标记清除，引用计数
- 标记清除

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_19-说说有几种类型的dom节点)19 说说有几种类型的DOM节点

- Document节点，整个文档是一个文档节点；
- Element节点，每个HTML标签是一个元素节点；
- Attribute节点，每一个HTML属性是一个属性节点；
- Text节点，包含在HTML元素中的文本是文本节点

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_20-说说javascript对象的几种创建方式)20 说说JavaScript对象的几种创建方式

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#工厂模式-创建方式)工厂模式,创建方式

```js
function createPerson(name,age,job){
    var o = new Object();
    o.name=name;
    o.age=age;
    o.job=job;
    o.sayName = function(){
        alert(this.name);
    }
}
var person1 = createPerson("da",1,"it");
var person2 = createPerson("dada",2,"it");
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#构造函数模式)构造函数模式

```js
function Person(name,age,ob){
    this.name=name;
    this.age=age;
    this.job=job;
    this.sayName = function(){
        alert(this.name);
    }
var person1 = new Person("dada",1,"web");
var person2 = new Person("dada",2,"web");
}
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#使用原型模式)使用原型模式

```js
function Person(){
}
Person.prototype.name = "da";
Person.prototype.age = 1;
Person.prototype.job = "web";
Person.prototype.sayName = function(){
    alert(this.name);
}
 
var person1 = new Person();
person1.sayName();    //"dada"
 
var person2 = new Person();
person2.sayName();    //"dada"
 
alert(person1.sayName == person2.sayName);   //true
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#组合使用构造函数模式和原型模式)组合使用构造函数模式和原型模式

```js
function Person(name,age){
    this.name = name;
    this.age = age;
    this.friends = ["da","dada"];
}
Person.prototype = {
    constructor:Person,
    sayName:function(){
        alert(this.name);
    }
}
var person1 = new Person("da1",1);
var person2 = new Person("da2",2);
person1.friends.push("dadada");
console.log(person1.friends);    //["da","dada","dadada"]
console.log(person2.friends);    //["da","dada"]
console.log(person1.friends === person2.friends);    //false
console.log(person1.sayName === person2.sayName);   //true
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#动态原型模式)动态原型模式

```js
function Person(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;

    if(typeof this.sayName!="function"){
        Person.prototype.sayName=function(){
            alert(this.name);
        };
    }
}
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_21-如何转化类数组成数组)21 如何转化类数组成数组

> 因为`arguments`本身并不能调用数组方法，它是一个另外一种对象类型，只不过属性从`0`开始排，依次为`0，1，2...`最后还有`callee`和`length`属性。我们也把这样的对象称为类数组

**常见的类数组还有：**

- 用`getElementsByTagName/ClassName()`获得的`HTMLCollection`
- 用`querySelector`获得的`nodeList`

> 那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#array-prototype-slice-call)Array.prototype.slice.call()

```js
function sum(a, b) {
  let args = Array.prototype.slice.call(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
}
sum(1, 2);//3
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#array-from)Array.from()

```js
function sum(a, b) {
  let args = Array.from(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
}
sum(1, 2);//3
```

这种方法也可以用来转换`Set`和`Map`哦！

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#es6展开运算符)ES6展开运算符

```js
function sum(a, b) {
  let args = [...arguments];
  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
}
sum(1, 2);//3
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#利用concat-apply)利用concat+apply

```js
function sum(a, b) {
  let args = Array.prototype.concat.apply([], arguments);//apply方法会把第二个参数展开
  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
}
sum(1, 2);//3
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_22-foreach中return有效果吗-如何中断foreach循环)22 forEach中return有效果吗？如何中断forEach循环？

> 在`forEach`中用`return`不会返回，函数会继续执行。

```js
let nums = [1, 2, 3];
nums.forEach((item, index) => {
  return;//无效
})
```

**中断方法：**

- 使用`try`监视代码块，在需要中断的地方抛出异常。
- 官方推荐方法（替换方法）：用`every`和`some`替代`forEach`函数。`every`在碰到`return false`的时候，中止循环。`some`在碰到`return true`的时候，中止循环

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_23-js判断数组中是否包含某个值)23 JS判断数组中是否包含某个值

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#方法一-array-indexof)方法一：array.indexOf

> 此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回`-1`。

```js
var arr=[1,2,3,4];
var index=arr.indexOf(3);
console.log(index);
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#方法二-array-includes-searcelement-fromindex)方法二：array.includes(searcElement[,fromIndex])

> 此方法判断数组中是否存在某个值，如果存在返回`true`，否则返回`false`

```js
var arr=[1,2,3,4];
if(arr.includes(3))
    console.log("存在");
else
    console.log("不存在");
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#方法三-array-find-callback-thisarg)方法三：array.find(callback[,thisArg])

返回数组中满足条件的第一个元素的值，如果没有，返回`undefined`

```js
var arr=[1,2,3,4];
var result = arr.find(item =>{
    return item > 3
});
console.log(result);
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#方法四-array-findeindex-callback-thisarg)方法四：array.findeIndex(callback[,thisArg])

> 返回数组中满足条件的第一个元素的下标，如果没有找到，返回`-1`

```js
var arr=[1,2,3,4];
var result = arr.findIndex(item =>{
    return item > 3
});
console.log(result);
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_24-js中flat-数组扁平化)24 JS中flat---数组扁平化

> 对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？

需求:多维数组=>一维数组

```js
let ary = [1, [2, [3, [4, 5]]], 6];// -> [1, 2, 3, 4, 5, 6]
let str = JSON.stringify(ary);
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#调用es6中的flat方法)调用ES6中的flat方法

```text
ary = ary.flat(Infinity);
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#replace-split)replace + split

```text
ary = str.replace(/(\[|\])/g, '').split(',')
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#replace-json-parse)replace + JSON.parse

```js
str = str.replace(/(\[|\])/g, '');
str = '[' + str + ']';
ary = JSON.parse(str);
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#普通递归)普通递归

```js
let result = [];
let fn = function(ary) {
  for(let i = 0; i < ary.length; i++) {
    let item = ary[i];
    if (Array.isArray(ary[i])){
      fn(item);
    } else {
      result.push(item);
    }
  }
}
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#利用reduce函数迭代)利用reduce函数迭代

```js
function flatten(ary) {
    return ary.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, []);
}
let ary = [1, 2, [3, 4], [5, [6, 7]]]
console.log(flatten(ary))
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#扩展运算符)扩展运算符

```js
//只要有一个元素有数组，那么循环继续
while (ary.some(Array.isArray)) {
  ary = [].concat(...ary);
}
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_25-js中浅拷贝的手段有哪些)25 JS中浅拷贝的手段有哪些

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#重要-什么是拷贝)重要: 什么是拷贝？

首先来直观的感受一下什么是拷贝

```js
let arr = [1, 2, 3];
let newArr = arr;
newArr[0] = 100;

console.log(arr);//[100, 2, 3]
```

> 这是直接赋值的情况，不涉及任何拷贝。当改变`newArr`的时候，由于是同一个引用，arr指向的值也跟着改变。

现在进行浅拷贝:

```js
let arr = [1, 2, 3];
let newArr = arr.slice();
newArr[0] = 100;

console.log(arr);//[1, 2, 3]
```

> 当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间啦！

这就是浅拷贝！

但是这又会带来一个潜在的问题:

```js
let arr = [1, 2, {val: 4}];
let newArr = arr.slice();
newArr[2].val = 1000;

console.log(arr);//[ 1, 2, { val: 1000 } ]
```

不是已经不是同一块空间的引用了吗？为什么改变了newArr改变了第二个元素的val值，arr也跟着变了。

> 这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能

解决无限极的对象嵌套问题，实现彻底的拷贝。当然，这是我们下一篇的重点。 现在先让大家有一个基本的概念。

接下来，我们来研究一下JS中实现浅拷贝到底有多少种方式？

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_1-手动实现)1. 手动实现

```js
const shallowClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_2-object-assign)2. Object.assign

> 但是需要注意的是，`Object.assgin()` 拷贝的是对象的属性的引用，而不是对象本身。

```js
let obj = { name: 'sy', age: 18 };
const obj2 = Object.assign({}, obj, {name: 'sss'});
console.log(obj2);//{ name: 'sss', age: 18 }
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_3-concat浅拷贝数组)3. concat浅拷贝数组

```js
let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr);//[ 1, 2, 3 ]
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_4-slice浅拷贝)4. slice浅拷贝

开头的例子

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_5-展开运算符)5. ...展开运算符

```js
let arr = [1, 2, 3];
let newArr = [...arr];//跟arr.slice()是一样的效果
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_26-数组-array)26 数组(array)

- `map`: 遍历数组，返回回调返回值组成的新数组
- `forEach`: 无法`break`，可以用`try/catch`中`throw new Error`来停止
- `filter`: 过滤
- `some`: 有一项返回`true`，则整体为`true`
- `every`: 有一项返回`false`，则整体为`false`
- `join`: 通过指定连接符生成字符串
- `push / pop`: 末尾推入和弹出，改变原数组， 返回推入/弹出项
- `unshift / shift`: 头部推入和弹出，改变原数组，返回操作项
- `sort(fn) / reverse`: 排序与反转，改变原数组
- `concat`: 连接数组，不影响原数组， 浅拷贝
- `slice(start, end)`: 返回截断后的新数组，不改变原数组
- `splice(start, number, value...)`: 返回删除元素组成的数组，`value`为插入项，改变原数组
- `indexOf / lastIndexOf(value, fromIndex)`: 查找数组项，返回对应的下标
- `reduce / reduceRight(fn(prev, cur)`， `defaultPrev)`: 两两执行，`prev` 为上次化简函数的`return`值，`cur`为当前值(从第二项开始)

**数组乱序：**

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
    return Math.random() - 0.5;
});
```

**数组拆解: flat: [1,[2,3]] --> [1, 2, 3]**

```js
Array.prototype.flat = function() {
    this.toString().split(',').map(item => +item )
}
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_27-代码的复用)27 代码的复用

> 当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:

- 函数封装
- 继承
- 复制`extend`
- 混入`mixin`
- 借用`apply/call`

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_28-操作dom节点方法)28 操作DOM节点方法

**创建新节点**

```js
createDocumentFragment()    //创建一个DOM片段
createElement()   //创建一个具体的元素
createTextNode()   //创建一个文本节点
```

**添加、移除、替换、插入**

```js
appendChild()      //添加
removeChild()      //移除
replaceChild()      //替换
insertBefore()      //插入
```

**查找**

```js
getElementsByTagName()    //通过标签名称
getElementsByName()     //通过元素的Name属性的值
getElementById()        //通过元素Id，唯一性
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_29-ajax总结)29 Ajax总结

- `Ajax`的原理简单来说是在用户和服务器之间加了—个中间层(`AJAX`引擎)，通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`javascript`来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据
- `Ajax`的过程只涉及`JavaScript`、`XMLHttpRequest`和`DOM`。`XMLHttpRequest`是`ajax`的核心机制

```js
// 1. 创建连接
var xhr = null;
xhr = new XMLHttpRequest()
// 2. 连接服务器
xhr.open('get', url, true)
// 3. 发送请求
xhr.send(null);
// 4. 接受请求
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        if(xhr.status == 200){
            success(xhr.responseText);
        } else { // fail
            fail && fail(xhr.status);
        }
    }
}
```

**ajax 有那些优缺点?**

**优点：**

- 通过异步模式，提升了用户体验.
- 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.
- `Ajax`在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
- `Ajax`可以实现动态不刷新（局部刷新）

**缺点：**

- 安全问题 `AJAX`暴露了与服务器交互的细节。
- 对搜索引擎的支持比较弱。
- 不容易调试。

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_30-谈谈你对for-in-for-of的理解)30 谈谈你对for in/for of的理解

> `for in`性能很差，迭代当前对象中可枚举的属性，并且一直查找到原型上去。

- 问题1：遍历顺序数字优先
- 问题2：无法遍历`symbol`属性
- 问题3：可以遍历到原型属性中可枚举的

```js
let obj = {
  name: 'poetry',
  age: 22,
  [Symbol('aa')]: 100,
  0: 200,
  1: 300
}
```

![img](http://img-repo.poetries.top/images/20210320102041.png) ![img](http://img-repo.poetries.top/images/20210320103701.png)

```js
for(let key in obj) {
  // 不遍历原型上的属性
  if(!obj.hasOwnProperty(key)) {
    break;
  }
}
```

**遍历obj的私有属性拼接**

```js
let keys = Object.keys(obj)
keys = keys.concat(Object.getOwnPropertySymbols(obj1))
keys.forEach(v=>{
  console.log(v)
})
```

**for of**

- 部分数据结构实现了迭代器规范
  - `Symbol.itertor`
  - `数组/set/map`
  - 对象没有实现，`for of`不能遍历对象

```js
// 数组具备迭代器规范，模拟实现
var arr = [1,2,3,4,5]

arr[Symbol.iterator] = function() {
  let self = this, index = 0;

  return {
    next() {
      if(index > self.length - 1) {
        return {
          done: true,
          value: undefined
        }
      }
      return {
        done: false,
        value: self[index++]
      }
    }
  }
}
// 使对象具备可迭代特性
let obj = {
  0: 100,
  1: 200,
  length: 2
}

obj[Symbol.iterator] = Array.prototype[Symbol.iterator]

for(var val of obj) {
  console.log(val)
}
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_31-数组相关)31 数组相关

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#array-3-和array-3-4-的区别)Array(3)和Array(3, 4)的区别？

```javascript
console.log(Array(3)) // [empty x 3]
console.log(Array(3, 4)) // [3, 4]
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#请创建一个长度为100-值都为1的数组)请创建一个长度为100，值都为1的数组

```javascript
new Array(100).fill(1)
```

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#请创建一个长度为100-值为对应下标的数组)请创建一个长度为100，值为对应下标的数组

```javascript
// cool的写法：
[...Array(100).keys()]

// 其他方法：
Array(100).join(",").split(",").map((v, i) => i)
Array(100).fill().map((v, i) => i)
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_32-setinterval存在哪些问题)32 setInterval存在哪些问题？

> `JavaScript`中使用 `setInterval` 开启轮询。定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而javascript引擎对这个问题的解决是：当使用`setInterval()`时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。

但是，这样会导致两个问题：

- 某些间隔被跳过；
- 多个定时器的代码执行之间的间隔可能比预期的小

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_33-链式调用settimeout对比setinterval)33 链式调用setTimeout对比setInterval

在上一题中也说到了`setInterval`本身是会存在一些问题的。而使用链式调用`setTimeout`这种方式会比它好一些：

```javascript
setTimeout(function fn(){
    console.log('我是setTimeout');
    setTimeout(fn, 1000);
},1000);
```

这个模式链式调用了`setTimeout()`，每次函数执行的时候都会创建一个新的定时器。第二个`setTimeout()`调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是：

- 在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。
- 而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_34-说一下requestanimationframe)34 说一下requestAnimationFrame

**简介：**

显示器都有自己固有的刷新频率(60HZ或者75HZ)，也就是说每秒最多重绘60次或者75次。而`requestAnimationFrame`的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行重绘。

**特点：**

- 使用这个API时，一旦页面不处于浏览器的当前标签，就会自动停止刷新，这样就节省了CPU、GPU、电力。
- 由于它时在主线程上完成的，所以若是主线程非常忙时它的动画也会收到影响
- 它使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。

**使用：**

正常使用：

```javascript
const requestID = window.requestAnimationFrame(callback);
```

兼容版本：

```javascript
// 给 window 下挂载一个兼容版本的 requestAniFrame
window.requestAniFrame = (function () {
  return  window.requestAnimationFrame || 
    window.webkitRequestAnimationFrame || 
    window.mozRequestAnimationFrame    || 
    window.oRequestAnimationFrame      || 
    window.msRequestAnimationFrame     || 
    function( callback ){
      window.setTimeout(callback, 1000 / 60);
    };
})();
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_35-requestanimationframe对比settimeout)35 requestAnimationFrame对比setTimeout

- **屏幕刷新频率：**屏幕每秒出现图像的次数。普通笔记本为`60Hz`
- **动画原理：**计算机每`16.7ms`刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。
- **setTimeout：**通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿抖动的现象；原因是：

1. `settimeout`任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；
2. `settimeout`的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。

> **requestAnimationFrame：**优势：由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿。且由于一旦页面不处于浏览器的当前标签，就会自动停止刷新，这样就节省了CPU、GPU、电力。

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_36-xmlhttprequest)36 XMLHttpRequest

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#关于http-xmlhttprequest-ajax的关系)关于http,XMLHttpRequest,Ajax的关系

- `http`是浏览器和web服务器交换数据的协议,规范
- `XMLHttpRequest`是一个`JS`对象，是浏览器实现的一组`api`函数，使用这些函数，浏览器再通过`http`协议请求和发送数据。
- `Ajax`是一种技术方案，但并不是一种新技术，它最核心的就是依赖浏览器提供的`XMLHttpRequest`对象。用一句话来概括就是`我们使用XMLHttpRequest对象来发送一个Ajax请求`。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#xmlhttprequest的发展历程是怎样的)XMLHttpRequest的发展历程是怎样的？

它最开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了`XMLHttpRequest`标准。标准又分为`Level 1`和`Level 2`。

`Level 2`相对于`Level 1`做了很大的改进，具体来说是：

- 可以设置HTTP请求的超时时间。
- 可以使用FormData对象管理表单数据。
- 可以上传文件。
- 可以请求不同域名下的数据（跨域请求）。
- 可以获取服务器端的二进制数据。
- 可以获得数据传输的进度信息。

### [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#使用xmlhttprequest封装一个get和post请求)使用XMLHttpRequest封装一个get和post请求

**get请求**：

核心就四步：

1. `var xhr = new XMLHttpRequest()`
2. `xhr.open('GET', 'http://www.example.com/api/getname', true)`
3. `xhr.onreadystatechange = function () {}`
4. `xhr.send()`

让我们来封装一个简易版的：

```javascript
/*
* xhr的get请求
* @param url: 请求地址
* @param params: 请求参数
* @param onSuccess: 成功回调函数
* @param onError: 失败回调函数
*/
function xhrGet (url, params = {}, onSuccess, onError) {
  // 兼容IE6
  var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
  let paramString = formatParams(params);
  // xhr.open的第三个参数isAsync：是否异步 
  xhr.open('GET', `${url}${paramString}`, true);
  xhr.onreadystatechange = function () {
    // console.log(e);
    console.log(this);
    if (this.readyState === 4) {
      if (this.status >= 200 && this.status < 300) {
        onSuccess(this.response);
      } else {
        onError(this.response)
      }
    }
  }
  xhr.send();
}
// 处理参数：如将{name: 'lindaidai'}转为'?name=lindaidai'
function formatParams (params) {
  var paramString = Object.keys(params).map(key => {
    return `${key}=${encodeURIComponent(params[key])}`
  }).join('&');
  return paramString ? `?${paramString}` : ''
}
```

（当然上面的兼容`IE6`估计现在考的不多了，而且我这种写法其实也没啥用，因为如果真是在`IE6`下的话，后面的`Object.keys()`等方法也用不了了）

需要注意的是两种状态，一个是`readyState`，一个是`status`。

> `readyState`请求状态：

- 0（未初始化）：还没有调用 open() 方法。
- 1（载入）：已调用 send() 方法，正在发送请求。
- 2（载入完成）：send() 方法完成，已收到全部响应内容。
- 3（解析）：正在解析响应内容。
- 4（完成）：响应内容解析完成，可以在客户端调用。

> `status`结果状态码：

- 0 ：如果状态是 UNSENT 或 OPENED；或者如果错误标签被设置(例如跨域时)
- 200 成功
- 其它HTTP状态码

**post请求：**

```javascript
function xhrPost (url, params, onSuccess, onError) {
  var xhr = new XMLHttpRequest();
  xhr.open('POST', url, true);
  // ajax的默认请求ContentType:text/plain(纯文本)
  xhr.setRequestHeader("Content-Type", "application-x-www-form-urlencode");
  xhr.onreadystatechange = function () {
    if (this.readyState === 4) {
      if (this.status >= 200 && this.status < 300) {
        onSuccess(this.response);
      } else {
        onError(this.response);
      }
    }
  }
  xhr.send(params);
}
```

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#_37-javascript-实现对上传图片的压缩)37 JavaScript 实现对上传图片的压缩？

> 答：读取用户上传的 File 对象，读写到画布（canvas）上，利用 Canvas 的 API 进行压缩，完成压缩之后再转成 `File（Blob）` 对象，上传到远程图片服务器；不过有时候我们也需要将一个 `base64` 字符串压缩之后再变为 `base64` 字符串传入到远程数据库或者再转成 `File（Blob）` 对象。

思路就是 `File + Canvas` 的 `drawImage`

## [#](http://interview.poetries.top/excellent-docs/3-JS模块.html#参考)参考

- [JS灵魂之问](https://juejin.cn/post/6844903974378668039)

# 4 ES6模块

## 1 ES5、ES6和ES2015有什么区别?

> `ES2015`特指在`2015`年发布的新一代`JS`语言标准，`ES6`泛指下一代JS语言标准，包含`ES2015`、`ES2016`、`ES2017`、`ES2018`等。现阶段在绝大部分场景下，`ES2015`默认等同`ES6`。`ES5`泛指上一代语言标准。`ES2015`可以理解为`ES5`和`ES6`的时间分界线

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_2-babel是什么-有什么作用)2 babel是什么，有什么作用?

> `babel`是一个 `ES6` 转码器，可以将 `ES6` 代码转为 `ES5` 代码，以便兼容那些还没支持`ES6`的平台

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_3-let有什么用-有了var为什么还要用let)3 let有什么用，有了var为什么还要用let？

> 在`ES6`之前，声明变量只能用`var`，`var`方式声明变量其实是很不合理的，准确的说，是因为`ES5`里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如`for`循环`var`变量泄露，变量覆盖等问题。`let`声明的变量拥有自己的块级作用域，且修复了`var`声明变量带来的变量提升问题。

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_4-举一些es6对string字符串类型做的常用升级优化)4 举一些ES6对String字符串类型做的常用升级优化?

**优化部分**

> `ES6`新增了字符串模板，在拼接大段字符串时，用反斜杠`(`)`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅

**升级部分**

> `ES6`在`String`原型上新增了`includes()`方法，用于取代传统的只能用`indexOf`查找包含字符的方法(`indexOf`返回`-1`表示没查到不如`includes`方法返回`false`更明确，语义更清晰), 此外还新增了`startsWith()`, `endsWith(),` `padStart()`,`padEnd()`,`repeat()`等方法，可方便的用于查找，补全字符串

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_5-举一些es6对array数组类型做的常用升级优化)5 举一些ES6对Array数组类型做的常用升级优化

**优化部分**

- 数组解构赋值。`ES6`可以直接以`let [a,b,c] = [1,2,3]`形式进行变量赋值，在声明较多变量时，不用再写很多`let(var),`且映射关系清晰，且支持赋默认值
- 扩展运算符。`ES6`新增的扩展运算符(`...`)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代`arguments`对象和`apply`方法，轻松获取未知参数个数情况下的参数集合。（尤其是在`ES5`中，`arguments`并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（`let a = [2,3,4]`; `let b = [...a]`）

**升级部分**

> `ES6`在`Array`原型上新增了`find()`方法，用于取代传统的只能用`indexOf`查找包含数组项目的方法,且修复了`indexOf`查找不到`NaN的bug([NaN].indexOf(NaN) === -1)`.此外还新增了`copyWithin()`,`includes()`, `fill()`,`flat()`等方法，可方便的用于字符串的查找，补全,转换等

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_6-举一些es6对number数字类型做的常用升级优化)6 举一些ES6对Number数字类型做的常用升级优化

**优化部分**

> ES6在`Number`原型上新增了`isFinite()`, `isNaN()`方法，用来取代传统的全局`isFinite(),` `isNaN()`方法检测数值是否有限、是否是`NaN`。`ES5`的`isFinite()`, `isNaN()`方法都会先将非数值类型的参数转化为`Number`类型再做判断，这其实是不合理的，最造成i`sNaN('NaN') === true`的奇怪行为`--'NaN'`是一个字符串，但是`isNaN`却说这就是`NaN`。而`Number.isFinite()`和`Number.isNaN()`则不会有此类问题(`Number.isNaN('NaN') === false`)。（`isFinite()`同上）

**升级部分**

> `ES6`在`Math`对象上新增了`Math.cbrt()`，`trunc()`，`hypot()`等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_7-举一些es6对object类型做的常用升级优化)7 举一些ES6对Object类型做的常用升级优化

**优化部分**

> 对象属性变量式声明。`ES6`可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰

```js
let [apple, orange] = ['red appe', 'yellow orange'];
let myFruits = {apple, orange};    // let myFruits = {apple: 'red appe', orange: 'yellow orange'};
```

> 尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显

```js
let {keys, values, entries} = Object;
let MyOwnMethods = {keys, values, entries}; // let MyOwnMethods = {keys: keys, values: values, entries: entries}
```

可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法

```js
let es5Fun = {
    method: function(){}
}; 
let es6Fun = {
    method(){}
}
```

> 对象的解构赋值。 `ES6`对象也可以像数组解构赋值那样，进行变量的解构赋值

```js
let {apple, orange} = {apple: 'red appe', orange: 'yellow orange'};
```

> 对象的扩展运算符(`...`)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解

```js
let {apple, orange, ...otherFruits} = {apple: 'red apple', orange: 'yellow orange', grape: 'purple grape', peach: 'sweet peach'}; 
// otherFruits  {grape: 'purple grape', peach: 'sweet peach'}
// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数)
let moreFruits = {watermelon: 'nice watermelon'};
let allFruits = {apple, orange, ...otherFruits, ...moreFruits};
```

> `super` 关键字。`ES6`在`Class`类里新增了类似`this`的关键字`super`。同`this`总是指向当前函数所在的对象不同，`super`关键字总是指向当前函数所在对象的原型对象

**升级部分**

> ```
> ES6`在`Object`原型上新增了`is()`方法，做两个目标对象的相等比较，用来完善`'==='`方法。`'==='`方法中`NaN === NaN //false`其实是不合理的，`Object.is`修复了这个小`bug`。`(Object.is(NaN, NaN) // true)
> ```

> `ES6`在`Object`原型上新增了`assign()`方法，用于对象新增属性或者多个对象合并

```js
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
```

> **注意**: `assign`合并的对象`target`只能合并`source1`、s`ource2`中的自身属性，并不会合并`source1`、`source2`中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行`get/set`函数，取`return`的值）

- `ES6`在`Object`原型上新增了`getOwnPropertyDescriptors()`方法，此方法增强了`ES5`中`getOwnPropertyDescriptor()`方法，可以获取指定对象所有自身属性的描述对象。结合`defineProperties()`方法，可以完美复制对象，包括复制`get`和`set`属性
- `ES6`在`Object`原型上新增了`getPrototypeOf()`和`setPrototypeOf()`方法，用来获取或设置当前对象的`prototype`对象。这个方法存在的意义在于，`ES5`中获取设置`prototype`对像是通过`__proto__`属性来实现的，然而`__proto__`属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的`prototype`对象时，都应该采用ES6新增的标准用法
- `ES6`在`Object`原型上还新增了`Object.keys()`，`Object.values()`，`Object.entries()`方法，用来获取对象的所有键、所有值和所有键值对数组

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_8-举一些es6对function函数类型做的常用升级优化)8 举一些ES6对Function函数类型做的常用升级优化?

**优化部分**

> 箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点

- 箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下`this`的指向变得很难理解，尤其是非严格模式情况下，`this`有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的`this`,这也就导致了`this`总是指向上一层的`this`，如果上一层还是箭头函数，则继续向上指，直到指向到有自己`this`的函数为止，并作为自己的`this`
- 箭头函数不能用作构造函数，因为它没有自己的`this`，无法实例化
- 也是因为箭头函数没有自己的this,所以箭头函数 内也不存在`arguments`对象。（可以用扩展运算符代替）
- 函数默认赋值。`ES6`之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。`ES6`以更简洁更明确的方式进行函数默认赋值

```js
function es6Fuc (x, y = 'default') {
    console.log(x, y);
}
es6Fuc(4) // 4, default
```

**升级部分**

> ES6新增了双冒号运算符，用来取代以往的`bind`，`call`,和`apply`。(浏览器暂不支持，`Babel`已经支持转码)

```js
foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);
```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_9-symbol是什么-有什么作用)9 Symbol是什么，有什么作用？

> `Symbol`是`ES6`引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中`Symbol()`属性不能被`for...in`遍历，但是也不是私有属性

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_10-set是什么-有什么作用)10 Set是什么，有什么作用？

> `Set`是`ES6`引入的一种类似`Array`的新的数据结构，`Set`实例的成员类似于数组`item`成员，区别是`Set`实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重

### [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#介绍下-set、map、weakset-和-weakmap-的区别)介绍下 Set、Map、WeakSet 和 WeakMap 的区别

- Set——对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用
- WeakSet——成员都是对象；成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏；
- Map——本质上是键值对的集合，类似集合；可以遍历，方法很多，可以跟各种数据格式转换。
- WeakMap——只接受对象最为键名（null 除外），不接受其他类型的值作为键名；键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；不能遍历，方法有 get、set、has、delet

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_11-map是什么-有什么作用)11 Map是什么，有什么作用？

> `Map`是`ES6`引入的一种类似`Object`的新的数据结构，`Map`可以理解为是`Object`的超集，打破了以传统键值对形式定义对象，对象的`key`不再局限于字符串，也可以是`Object`。可以更加全面的描述对象的属性

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_12-proxy是什么-有什么作用)12 Proxy是什么，有什么作用？

> ```
> Proxy`是`ES6`新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的`get/set`等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的`get/set`方法，可以轻松地定制自己想要的`key`或者`value`。下面的例子可以看到，随便定义一个`myOwnObj`的`key`,都可以变成自己想要的函数
> ```

```js
function createMyOwnObj() {
	//想把所有的key都变成函数，或者Promise,或者anything
	return new Proxy({}, {
		get(target, propKey, receiver) {
			return new Promise((resolve, reject) => {
				setTimeout(() => {
					let randomBoolean = Math.random() > 0.5;
					let Message;
					if (randomBoolean) {
						Message = `你的${propKey}运气不错，成功了`;
						resolve(Message);
					} else {
						Message = `你的${propKey}运气不行，失败了`;
						reject(Message);
					}
				}, 1000);
			});
		}
	});
}

let myOwnObj = createMyOwnObj();

myOwnObj.hahaha.then(result => {
	console.log(result) //你的hahaha运气不错，成功了
}).catch(error => {
	console.log(error) //你的hahaha运气不行，失败了
})

myOwnObj.wuwuwu.then(result => {
	console.log(result) //你的wuwuwu运气不错，成功了
}).catch(error => {
	console.log(error) //你的wuwuwu运气不行，失败了
})
```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_13-reflect是什么-有什么作用)13 Reflect是什么，有什么作用？

> ```
> Reflect`是`ES6`引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在`Object`、`Function`或者全局函数里的方法(如`apply`、`delete`、`get`、`set`等等)，统一整合到`Reflect`上，这样可以更加方便更加统一的管理一些原生`API`。其次就是因为`Proxy`可以改写默认的原生API，如果一旦原生`API`别改写可能就找不到了，所以`Reflect`也可以起到备份原生API的作用，使得即使原生`API`被改写了之后，也可以在被改写之后的`API`用上默认的`API
> ```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_14-promise是什么-有什么作用)14 Promise是什么，有什么作用？

> `Promise`是`ES6`引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的`API`，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_15-iterator是什么-有什么作用)15 Iterator是什么，有什么作用？

- `Iterator`是`ES6`中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为`ES6`新增了`Set`、`Map`类型，他们和`Array`、`Object`类型很像，`Array`、`Object`都是可以遍历的，但是`Set`、`Map`都不能用for循环遍历，解决这个问题有两种方案，一种是为`Set`、`Map`单独新增一个用来遍历的`API`，另一种是为`Set`、`Map`、`Array`、`Object`新增一个统一的遍历`API`，显然，第二种更好，`ES6`也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。`Iterator`正是这样一种标准。或者说是一种规范理念
- 就好像`JavaScript`是`ECMAScript`标准的一种具体实现一样，`Iterator`标准的具体实现是`Iterator`遍历器。`Iterator`标准规定，所有部署了`key`值为`[Symbol.iterator]`，且`[Symbol.iterator]`的`value`是标准的`Iterator`接口函数(标准的`Iterator`接口函数: 该函数必须返回一个对象，且对象中包含`next`方法，且执行`next()`能返回包含`value/done`属性的`Iterator`对象)的对象，都称之为可遍历对象，`next()`后返回的`Iterator`对象也就是`Iterator`遍历器

```js
//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。
//obj.[Symbol.iterator]() 就是Iterator遍历器
let obj = {
  data: [ 'hello', 'world' ],
  [Symbol.iterator]() {
    const self = this;
    let index = 0;
    return {
      next() {
        if (index < self.data.length) {
          return {
            value: self.data[index++],
            done: false
          };
        } else {
          return { value: undefined, done: true };
        }
      }
    };
  }
};
```

> `ES6`给`Set`、`Map`、`Array`、`String`都加上了`[Symbol.iterator]`方法，且`[Symbol.iterator]`方法函数也符合标准的`Iterator`接口规范，所以`Set`、`Map`、`Array`、`String`默认都是可以遍历的

```js
//Array
let array = ['red', 'green', 'blue'];
array[Symbol.iterator]() //Iterator遍历器
array[Symbol.iterator]().next() //{value: "red", done: false}

//String
let string = '1122334455';
string[Symbol.iterator]() //Iterator遍历器
string[Symbol.iterator]().next() //{value: "1", done: false}

//set
let set = new Set(['red', 'green', 'blue']);
set[Symbol.iterator]() //Iterator遍历器
set[Symbol.iterator]().next() //{value: "red", done: false}

//Map
let map = new Map();
let obj= {map: 'map'};
map.set(obj, 'mapValue');
map[Symbol.iterator]().next()  {value: Array(2), done: false}
```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_16-for-in-和for-of有什么区别)16 for...in 和for...of有什么区别？

> 如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用`for...of`。ES6规定，有所部署了载了`Iterator`接口的对象(可遍历对象)都可以通过`for...of`去遍历，而`for..in`仅仅可以遍历对象

- 这也就意味着，数组也可以用`for...of`遍历，这极大地方便了数组的取值，且避免了很多程序用`for..in`去遍历数组的恶习

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_17-generator函数是什么-有什么作用)17 Generator函数是什么，有什么作用？

- 如果说`JavaScript`是`ECMAScript`标准的一种具体实现、`Iterator`遍历器是`Iterator`的具体实现，那么`Generator`函数可以说是`Iterator`接口的具体实现方式。
- 执行`Generator`函数会返回一个遍历器对象，每一次`Generator`函数里面的`yield`都相当一次遍历器对象的`next()`方法，并且可以通过`next(value)`方法传入自定义的value,来改变`Generator`函数的行为。
- `Generator`函数可以通过配合`Thunk` 函数更轻松更优雅的实现异步编程和控制流管理。

### [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#generator-原理)generator 原理

> `Generator` 是 `ES6`中新增的语法，和 `Promise` 一样，都可以用来异步编程

```js
// 使用 * 表示这是一个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调用 next 恢复执行
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}
let b = test();
console.log(b.next()); // >  { value: 2, done: false }
console.log(b.next()); // >  { value: 3, done: false }
console.log(b.next()); // >  { value: undefined, done: true }
```

> 从以上代码可以发现，加上 `*`的函数执行后拥有了 `next` 函数，也就是说函数执行后返回了一个对象。每次调用 `next` 函数可以继续执行被暂停的代码。以下是 `Generator` 函数的简单实现

```js
// cb 也就是编译过的 test 函数
function generator(cb) {
  return (function() {
    var object = {
      next: 0,
      stop: function() {}
    };

    return {
      next: function() {
        var ret = cb(object);
        if (ret === undefined) return { value: undefined, done: true };
        return {
          value: ret,
          done: false
        };
      }
    };
  })();
}
// 如果你使用 babel 编译后可以发现 test 函数变成了这样
function test() {
  var a;
  return generator(function(_context) {
    while (1) {
      switch ((_context.prev = _context.next)) {
        // 可以发现通过 yield 将代码分割成几块
        // 每次执行 next 函数就执行一块代码
        // 并且表明下次需要执行哪块代码
        case 0:
          a = 1 + 2;
          _context.next = 4;
          return 2;
        case 4:
          _context.next = 6;
          return 3;
		// 执行完毕
        case 6:
        case "end":
          return _context.stop();
      }
    }
  });
}
```

### [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#generator-实现)Generator 实现

> `Generator` 是 `ES6`中新增的语法，和 `Promise` 一样，都可以用来异步编程

```js
// 使用 * 表示这是一个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调用 next 恢复执行
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}
let b = test();
console.log(b.next()); // >  { value: 2, done: false }
console.log(b.next()); // >  { value: 3, done: false }
console.log(b.next()); // >  { value: undefined, done: true }
```

> 从以上代码可以发现，加上 `*` 的函数执行后拥有了 `next`函数，也就是说函数执行后返回了一个对象。每次调用 `next`函数可以继续执行被暂停的代码。以下是 `Generator` 函数的简单实现

```js
// cb 也就是编译过的 test 函数
function generator(cb) {
  return (function() {
    var object = {
      next: 0,
      stop: function() {}
    };

    return {
      next: function() {
        var ret = cb(object);
        if (ret === undefined) return { value: undefined, done: true };
        return {
          value: ret,
          done: false
        };
      }
    };
  })();
}
// 如果你使用 babel 编译后可以发现 test 函数变成了这样
function test() {
  var a;
  return generator(function(_context) {
    while (1) {
      switch ((_context.prev = _context.next)) {
        // 可以发现通过 yield 将代码分割成几块
        // 每次执行 next 函数就执行一块代码
        // 并且表明下次需要执行哪块代码
        case 0:
          a = 1 + 2;
          _context.next = 4;
          return 2;
        case 4:
          _context.next = 6;
          return 3;
		// 执行完毕
        case 6:
        case "end":
          return _context.stop();
      }
    }
  });
}
```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_18-async函数是什么-有什么作用)18 async函数是什么，有什么作用？

> `async`函数可以理解为内置自动执行器的`Generator`函数语法糖，它配合`ES6`的`Promise`近乎完美的实现了异步编程解决方案

**async、await 优缺点**

> `async` 和 `await` 相比直接使用 `Promise` 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 `await` 可能会导致性能问题，因为 `await` 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性

下面来看一个使用 `await` 的代码。

```js
var a = 0
var b = async () => {
  a = a + await 10
  console.log('2', a) // -> '2' 10
  a = (await 10) + a
  console.log('3', a) // -> '3' 20
}
b()
a++
console.log('1', a) // -> '1' 1
```

- 首先函数`b` 先执行，在执行到 `await 10` 之前变量 `a` 还是 `0`，因为在 `await` 内部实现了 `generators` ，`generators` 会保留堆栈中东西，所以这时候 `a = 0` 被保存了下来
- 因为 `await` 是异步操作，遇到`await`就会立即返回一个`pending`状态的`Promise`对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 `console.log('1', a)`
- 这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 `a = 10`
- 然后后面就是常规执行代码了

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_19-class、extends是什么-有什么作用)19 Class、extends是什么，有什么作用？

> `ES6` 的`class`可以看作只是一个`ES5`生成实例对象的构造函数的语法糖。它参考了`java`语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。`Class`类可以通过`extends`实现继承。它和ES5构造函数的不同点

类的内部定义的所有方法，都是不可枚举的

```js
///ES5
function ES5Fun (x, y) {
	this.x = x;
	this.y = y;
}
ES5Fun.prototype.toString = function () {
	 return '(' + this.x + ', ' + this.y + ')';
}
var p = new ES5Fun(1, 3);
p.toString();
Object.keys(ES5Fun.prototype); //['toString']

//ES6
class ES6Fun {
	constructor (x, y) {
		this.x = x;
		this.y = y;
	}
	toString () {
		return '(' + this.x + ', ' + this.y + ')';
	}
}

Object.keys(ES6Fun.prototype); //[]
```

- `ES6`的`class`类必须用`new`命令操作，而`ES5`的构造函数不用`new`也可以执行。
- `ES6`的`class`类不存在变量提升，必须先定义`class`之后才能实例化，不像`ES5`中可以将构造函数写在实例化之后。
- `ES5` 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面。`ES6` 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_20-module、export、import是什么-有什么作用)20 module、export、import是什么，有什么作用？

- `module`、`export`、`import`是`ES6`用来统一前端模块化方案的设计思路和实现方案。`export`、`import`的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的`AMD/CMD`、`requireJS`、`seaJS`、`commondJS`等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，`JS`也能更加能实现大型的应用程序开发。
- `import`引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。
- `import`引入`export`导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_21-日常前端代码开发中-有哪些值得用es6去改进的编程优化或者规范)21 日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？

- 常用箭头函数来取代`var self = this`;的做法。
- 常用`let`取代`var`命令。
- 常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。
- 在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。
- 用`Class`类取代传统的构造函数，来生成实例化对象。
- 在大型应用开发中，要保持`module`模块化开发思维，分清模块之间的关系，常用`import`、`export`方法。

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_22-es6的了解)22 ES6的了解

> 新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=>outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_23-说说你对promise的理解)23 说说你对Promise的理解

- 依照

   

  ```
  Promise/A+
  ```

   

  的定义，Promise 有四种状态：

  - `pending`: 初始状态, 非 `fulfilled` 或 `rejected.`
  - `fulfilled`: 成功的操作.
  - `rejected`: 失败的操作.
  - `settled`: `Promise`已被`fulfilled`或`rejected`，且不是`pending`

- 另外， `fulfilled` 与 `rejected` 一起合称 settled

- `Promise` 对象用来进行延迟(`deferred`) 和异步(`asynchronous` ) 计算

- 可以把 `Promise`看成一个状态机。初始是 `pending` 状态，可以通过函数 `resolve` 和 `reject`，将状态转变为 `resolved` 或者 `rejected` 状态，状态一旦改变就不能再次变化。

- `then` 函数会返回一个 `Promise` 实例，并且该返回值是一个新的实例而不是之前的实例。因为 `Promise` 规范规定除了 `pending` 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 `then`调用就失去意义了

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_24-promise-的构造函数)24 Promise 的构造函数

> 构造一个 `Promise`，最基本的用法如下：

```js
var promise = new Promise(function(resolve, reject) {

        if (...) {  // succeed

            resolve(result);

        } else {   // fails

            reject(Error(errMessage));

        }
    });
```

> `Promise` 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：

```js
promise.then(onFulfilled, onRejected)
```

> 接收两个函数作为参数，一个在 `fulfilled` 的时候被调用，一个在`rejected`的时候被调用，接收参数就是 future，`onFulfilled` 对应 `resolve`, `onRejected` 对应 `reject`

**什么是 Promise ？**

- Promise 就是一个对象，用来表示并传递异步操作的最终结果
- Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因
- Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱）

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_25-谈一谈你了解ecmascript6的新特性)25 谈一谈你了解ECMAScript6的新特性？

- 块级作用区域 `let a = 1;`
- 可定义常量 `const PI = 3.141592654;`
- 变量解构赋值 `var [a, b, c] = [1, 2, 3];`
- 字符串的扩展(模板字符串) `var sum =`${a + b}`;`
- 数组的扩展(转换数组类型) `Array.from($('li'));`
- 函数的扩展(扩展运算符) `[1, 2].push(...[3, 4, 5]);`
- 对象的扩展(同值相等算法) `Object.is(NaN, NaN);`
- 新增数据类型(Symbol) `let uid = Symbol('uid');`
- 新增数据结构(Map) `let set = new Set([1, 2, 2, 3]);`
- for...of循环 `for(let val of arr){};`
- Promise对象 `var promise = new Promise(func);`
- Generator函数 `function* foo(x){yield x; return x*x;}`
- 引入Class(类) `class Foo {}`
- 引入模块体系 `export default func;`
- 引入async函数[ES7]

```js
async function asyncPrint(value, ms) {
      await timeout(ms);
      console.log(value)
     }
     
```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_26-object-is-与原来的比较操作符-、-的区别)26 Object.is() 与原来的比较操作符 ===、== 的区别？

- `==` 相等运算符，比较时会自动进行数据类型转换
- `===` 严格相等运算符，比较时不进行隐式类型转换
- `Object.is` 同值相等算法，在 `===` 基础上对 `0` 和 `NaN` 特别处理

```js
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_27-什么是-babel)27 什么是 Babel

- `Babel` 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。 这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。
- `Babel` 默认只转换新的 JS 句法(syntax)，而不转换新的API。

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_28-symbol-有什么用处)28 symbol 有什么用处

> 可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗？我没想出其他的用处就直接答我不知道了，还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。

主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。

> ```
> Symbol.for()` 可以在全局访问 `symbol
> ```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_29-模块化)29 模块化

> 在有 `Babel` 的情况下，我们可以直接使用 `ES6`的模块化

```js
// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}

import {a, b} from './a.js'
import XXX from './b.js'
```

**CommonJS**

> `CommonJs` 是 `Node` 独有的规范，浏览器中使用就需要用到 `Browserify`解析了。

```js
// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
```

> 在上述代码中，`module.exports` 和 `exports` 很容易混淆，让我们来看看大致内部实现

```js
var module = require('./a.js')
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// 基本实现
var module = {
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};
```

> 再来说说 `module.exports` 和`exports`，用法其实是相似的，但是不能对 `exports` 直接赋值，不会有任何效果。

> 对于 `CommonJS` 和 `ES6` 中的模块化的两者区别是：

- 前者支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。
- 而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。
- 但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- 后者会编译成 `require/exports` 来执行的

**AMD**

> `AMD` 是由 `RequireJS` 提出的

```js
// AMD
define(['./a', './b'], function(a, b) {
    a.do()
    b.do()
})
define(function(require, exports, module) {   
    var a = require('./a')  
    a.doSomething()   
    var b = require('./b')
    b.doSomething()
})
```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_30-箭头函数的特点)30 箭头函数的特点

```js
function a() {
    return () => {
        return () => {
        	console.log(this)
        }
    }
}
console.log(a()()())
```

> 箭头函数其实是没有 `this` 的，这个函数中的 `this` 只取决于他外面的第一个不是箭头函数的函数的 `this`。在这个例子中，因为调用 `a` 符合前面代码中的第一个情况，所以 `this` 是`window`。并且 `this`一旦绑定了上下文，就不会被任何代码改变

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_31-es5-es6-的继承除了写法以外还有什么区别)31 ES5 / ES6 的继承除了写法以外还有什么区别

- ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）
- ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this。
- ES5 的继承时通过原型或构造函数机制来实现。
- ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。
- 子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。
- 注意 super 关键字指代父类的实例，即父类的 this 对象。
- 注意：在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。function 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_32-全局作用域中-用-const-和-let-声明的变量不在-window-上-那到底在哪里-如何去获取)32 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？

```js
// 在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。
var a = 12;
function f(){};
console.log(window.a);
// 12console.log(window.f);
// f(){}

// 但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。
let aa = 1;
const bb = 2;
console.log(window.aa);
// undefinedconsole.log(window.bb);
// undefined

// 在哪里？怎么获取？通过在设置断点，看看浏览器是怎么处理的：
//通过上图也可以看到，在全局作用域中，用 let 和 const 声明的全局变量并没
//有在全局对象中，只是一个块级作用域（Script）中怎么获取？在定义变量的块级作用域中就能获取啊，既然不属于顶层对象，那就不加 window（global）呗。
let aa = 1;
const bb = 2;
console.log(aa);
// 1console.log(bb);
// 2
```

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_33-介绍下-set、map、weakset-和-weakmap-的区别)33 介绍下 Set、Map、WeakSet 和 WeakMap 的区别

**Set**

- 成员不能重复
- 只有健值，没有健名，有点类似数组
- 可以遍历，方法有`add`, `delete`,`has`

**weakSet**

- 成员都是对象
- 成员都是弱引用，随时可以消失。 可以用来保存DOM节点，不容易造成内存泄漏
- 不能遍历，方法有`add`, `delete`,`has`

**Map**

- 本质上是健值对的集合，类似集合
- 可以遍历，方法很多，可以干跟各种数据格式转换

**weakMap**

- 直接受对象作为健名（`null`除外），不接受其他类型的值作为健名
- 健名所指向的对象，不计入垃圾回收机制
- 不能遍历，方法同`get`,`set`,`has`,`delete`

## [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#_34-promise-all-和-promise-allsettled-的比较)34 Promise.all() 和 Promise.allSettled()的比较

### [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#promise-allsettled)Promise.allSettled()

> 接受的结果与入参时的promise实例一一对应，且结果的每一项都是一个对象，告诉你结果和值，对象内都有一个属性叫“status”，用来明确知道对应的这个promise实例的状态（fulfilled或rejected），fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。

```js
const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) {
  console.log(results);
});
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]
```

> 重要的一点是，他不论接受入参的promise本身的状态，会返回所有promise的结果，但这一点`Promise.all`做不到，如果你需要知道所有入参的异步操作的所有结果，或者需要知道这些异步操作是否全部结束，应该使用`promise.allSettled()`

### [#](http://interview.poetries.top/excellent-docs/4-ES6模块.html#promise-all)Promise.all()

> 只有当所有入参的promise实例都是`fulfilled`状态，才会在`Promise.all().then()`方法中结果，返回结果也是与入参一一对应，结果中只包含实际的`resolve`的结果，不包含类似`allSettled`的`status`和`value`属性。

# 5 浏览器模块

## 1 跨标签页通讯

> 不同标签页间的通讯，本质原理就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法:

- 通过父页面

  ```
  window.open()
  ```

  和子页面

  ```
  postMessage
  ```

  - 异步下，通过 `window.open('about: blank')` 和 `tab.location.href = '*'`

- 设置同域下共享的

  ```
  localStorage
  ```

  与监听

  ```
  window.onstorage
  ```

  - 重复写入相同的值无法触发
  - 会受到浏览器隐身模式等的限制

- 设置共享`cookie`与不断轮询脏检查(`setInterval`)

- 借助服务端或者中间层实现

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_2-浏览器架构)2 浏览器架构

- 用户界面

- 主进程

- 内核

  - 渲染引擎

  - ```
    JS
    ```

     

    引擎

    - 执行栈

- 事件触发线程

  - 消息队列
    - 微任务
    - 宏任务

- 网络异步线程

- 定时器线程

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_3-渲染机制)3 渲染机制

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_3-1-浏览器的渲染机制一般分为以下几个步骤)3.1 浏览器的渲染机制一般分为以下几个步骤

- 处理 `HTML` 并构建 `DOM` 树。
- 处理 `CSS` 构建 `CSSOM` 树。
- 将 `DOM` 与 `CSSOM` 合并成一个渲染树。
- 根据渲染树来布局，计算每个节点的位置。
- 调用 `GPU` 绘制，合成图层，显示在屏幕上

![img](https://poetries1.gitee.io/img-repo/2020/09/98.png)

- 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。
- css 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间
- 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_3-2-图层)3.2 图层

> 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用

- 通过以下几个常用属性可以生成新图层
  - `3D`变换：`translate3d`、`translateZ`
  - `will-change`
  - `video`、`iframe` 标签
  - 通过动画实现的 `opacity` 动画转换
  - `position: fixed`

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_3-3-重绘与回流)3.3 重绘与回流

> 当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

> - 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少
> - 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:

- 页面初次渲染
- 浏览器窗口大小改变
- 元素尺寸、位置、内容发生改变
- 元素字体大小变化
- 添加或者删除可见的 `dom` 元素
- 激活 `CSS` 伪类（例如：`:hover`）
- 查询某些属性或调用某些方法
  - `clientWidth、clientHeight、clientTop、clientLeft`
  - `offsetWidth、offsetHeight、offsetTop、offsetLeft`
  - `scrollWidth、scrollHeight、scrollTop、scrollLeft`
  - `getComputedStyle()`
  - `getBoundingClientRect()`
  - `scrollTo()`

> 回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。

**回流的优化**

> 对树的局部甚至全局重新生成是非常耗性能的，所以要避免频繁触发回流

- 现代浏览器已经帮我们做了优化，采用队列存储多次的回流操作，然后批量执行，但获取布局信息例外，因为要获取到实时的数值，浏览器就必须要清空队列，立即执行回流。
- 编码上，避免连续多次修改，可通过合并修改，一次触发
- 减少`dom`的增删次数，可使用 字符串 或者 `documentFragment` 一次性插入
- 对于大量不同的 `dom` 修改，可以先将其脱离文档流，比如使用绝对定位，或者 `display:none`，在文档流外修改完成后再放回文档里中
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`
- 通过节流和防抖控制触发频率
- `css3` 硬件加速，`transform`、`opacity`、`filters`，开启后，会新建渲染层

**开启GPU加速的方法**

> 开启后，会将 dom元素提升为独立的渲染层，它的变化不会再影响文档流中的布局。

- `transform: translateZ(0)`
- `opacity`
- `filters`
- `Will-change`

**很多人不知道的是，重绘和回流其实和 `Event loop` 有关**

- 当 `Event loop` 执行完 `Microtasks` 后，会判断 `document` 是否需要更新。因为浏览器是 `60Hz`的刷新率，每 `16ms`才会更新一次。
- 然后判断是否有 `resize` 或者 `scroll` ，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 `16ms` 才会触发一次，并且自带节流功能。
- 判断是否触发了`media query`
- 更新动画并且发送事件
- 判断是否有全屏操作事件
- 执行 `requestAnimationFrame` 回调
- 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
- 更新界面
- 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_3-4-javascript-会阻塞-dom-生成)3.4 JavaScript 会阻塞 DOM 生成

> `JavaScript` 会阻塞 `DOM`生成，而样式文件又会阻塞 `JavaScript` 的执行，所以在实际的工程中需要重点关注 `JavaScript` 文件和样式表文件，使用不当会影响到页面性能的

> 当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据

- 如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。
- 而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。
- 不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_3-5-缩短白屏时长-可以有以下策略)3.5 缩短白屏时长，可以有以下策略

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_4-跨域)4 跨域

> 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，`Ajax`请求会失败。

我们可以通过以下几种常用方法解决跨域的问题

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#jsonp)JSONP

> `JSONP` 的原理很简单，就是利用 `<script>`标签没有跨域限制的漏洞。通过 `<script>`标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时

```html
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>    
```

> `JSONP` 使用简单且兼容性不错，但是只限于 `get` 请求

- 在开发中可能会遇到多个 `JSONP` 请求的回调函数名是相同的，这时候就需要自己封装一个 `JSONP`，以下是简单实现

```js
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement("script");
  script.src = url;
  script.async = true;
  script.type = "text/javascript";
  window[jsonpCallback] = function(data) {
    success && success(data);
  };
  document.body.appendChild(script);
}
jsonp(
  "http://xxx",
  "callback",
  function(value) {
    console.log(value);
  }
);
```

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#cors)CORS

- `ORS`需要浏览器和后端同时支持。`IE 8` 和 `9` 需要通过 `XDomainRequest` 来实现。
- 浏览器会自动进行 `CORS` 通信，实现`CORS`通信的关键是后端。只要后端实现了 `CORS`，就实现了跨域。
- 服务端设置 `Access-Control-Allow-Origin` 就可以开启 `CORS`。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#document-domain)document.domain

- 该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。
- 只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#postmessage)postMessage

> 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
// 发送消息端
window.parent.postMessage('message', 'http://test.com');
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener('message', (event) => {
    var origin = event.origin || event.originalEvent.origin;
    if (origin === 'http://test.com') {
        console.log('验证通过')
    }
});
```

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_5-浏览器缓存)5 浏览器缓存

> 我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。

- 短暂性的时候，我们只需要将数据存在内存中，只在运行时可用

- 持久性存储，可以分为 浏览器端 与 服务器端

  - 浏览器:

    - ```
      cookie
      ```

      : 通常用于存储用户身份，登录状态等

      - `http` 中自动携带， 体积上限为 `4K`， 可自行设置过期时间

    - `localStorage / sessionStorage`: 长久储存/窗口关闭删除， 体积限制为 `4~5M`

    - `indexDB`

  - 服务器:

    - 分布式缓存 `redis`
    - 数据库

> 提示：如果平常有遇到过缓存的坑或者很好的利用缓存，可以讲解一下自己的使用场景。如果没有使用注意过缓存问题你也可以尝试讲解一下和我们息息相关的Webpack构建（每一次构建静态资源名称的`hash`值都会变化），它其实就跟缓存相关

> 缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-1-强缓存)6.1 强缓存

**Expires(HTTP1.0)**：`Exprires`的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用`Cache-Control`替代

> 缺点：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。

**Cache-Control(HTTP1.1)**：有很多属性，不同的属性代表的意义也不同

- `private`：客户端可以缓存
- `public`：客户端和代理服务器都可以缓存
- `max-age=t`：缓存内容将在t秒后失效
- `no-cache`：需要使用协商缓存来验证缓存数据
- `no-store`：所有内容都不会缓存

> 请注意`no-cache`指令很多人误以为是不缓存，这是不准确的，`no-cache`的意思是可以缓存，但每次用应该去向服务器验证缓存是否可用。`no-store`才是不缓存内容。当在首部字段`Cache-Control` 有指定 `max-age` 指令时，比起首部字段 Expires，会优先处理 `max-age` 指令。命中强缓存的表现形式：Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为200 (`from disk cache`)或是200 OK (`from memory cache`)

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-2-协商缓存)6.2 协商缓存

> 协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了

- `Last-Modified`：服务器在响应请求时，会告诉浏览器资源的最后修改时间
- `if-Modified-Since`：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有`if-Modified-Since`，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可
- 如果真的被修改：那么开始传输响应一个整体，服务器返回：`200 OK`
- 如果没有被修改：那么只需传输响应`header`，服务器返回：`304 Not Modified`
- `Etag`：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）
- `If-Match`：条件请求，携带上一次请求中资源的`ETag`，服务器根据这个字段判断文件是否有新的修改
- `If-None-Match`： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现`If-None-Match`则与被请求资源的唯一标识进行对比。

> 但是实际应用中由于`Etag`的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用`Etag`了

- 浏览器地址栏中写入`URL`，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）
- `F5`就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上`If-Modify-since`
- `Ctrl+F5`告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-3-缓存场景)6.3 缓存场景

> 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-4-讲讲304)6.4 讲讲304

> 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容(自 上次访问以来或者根据请求的条件)并没有改变，则服务器应当返回这个 304 状态码

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-5-强缓存、协商缓存什么时候用哪个)6.5 强缓存、协商缓存什么时候用哪个

> 因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们 还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资 源;所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地 的缓存，以最大程度的减少因网络请求而产生的资源浪费。

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-6-缓存总结)6.6 缓存总结

> 缓存分为两种:强缓存和协商缓存，根据响应的 header 内容来决定。

|          | 获取资源形式 | 状态码            | 发送请求到服务器                  |
| -------- | ------------ | ----------------- | --------------------------------- |
| 强缓存   | 从缓存取     | 200(from cache)   | 否，直接从缓存取                  |
| 协商缓存 | 从缓存取     | 304(not modified) | 是，通过服务器来告知缓存是否可 用 |

- 强缓存相关字段有 `expires`，`cache-control`。如果 `cache-control` 与 `expires` 同时存在的话， `cache-control` 的优先级高于 `expires`。
- 协商缓存相关字段有 `Last-Modified/If-Modified-Since`，`Etag/If-None-Match`

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-7-cookie和localsrorage、session、indexdb-的区别)6.7 cookie和localSrorage、session、indexDB 的区别

| 特性         | cookie                                     | localStorage             | sessionStorage | indexDB                  |
| ------------ | ------------------------------------------ | ------------------------ | -------------- | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间         | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | `4K`                                       | `5M`                     | `5M`           | 无限                     |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与                   | 不参与         | 不参与                   |

> 从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage`和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

**对于 `cookie`，我们还需要注意安全性**

| 属性        | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| `value`     | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| `http-only` | 不能通过 `JS`访问 `Cookie`，减少 `XSS`攻击                   |
| `secure`    | 只能在协议为 `HTTPS` 的请求中携带                            |
| `same-site` | 规定浏览器不能在跨域请求中携带 `Cookie`，减少 `CSRF` 攻击    |

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-内存泄露)6 内存泄露

- 意外的全局变量: 无法被回收
- 定时器: 未被正确关闭，导致所引用的外部变量无法被释放
- 事件监听: 没有正确销毁 (低版本浏览器可能出现)
- 闭包: 会导致父级中的变量无法被释放
- `dom` 引用: `dom` 元素被删除时，内存中的引用未被正确清空

> 可用 `chrome` 中的 `timeline` 进行内存标记，可视化查看内存的变化情况，找出异常点。

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_7-浏览器api)7 浏览器API

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_7-1-web-worker)7.1 Web Worker

> 现代浏览器为`JavaScript`创造的 多线程环境。可以新建并将部分任务分配到`worker`线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。

**基本用法:**

```js
// 创建 worker
const worker = new Worker('work.js');

// 向主进程推送消息
worker.postMessage('Hello World');

// 监听主进程来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
}
```

**限制:**

- 同源限制
- 无法使用 `document / window / alert / confirm`
- 无法加载本地资源

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_7-2-service-worker)7.2 Service Worker

service worker

`Service workers` 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API

**目前该技术通常用来做缓存文件，提高首屏速度**

```javascript
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register("sw.js")
    .then(function(registration) {
      console.log("service worker 注册成功");
    })
    .catch(function(err) {
      console.log("servcie worker 注册失败");
    });
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener("install", e => {
  e.waitUntil(
    caches.open("my-cache").then(function(cache) {
      return cache.addAll(["./index.html", "./index.js"]);
    })
  );
});

// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener("fetch", e => {
  e.respondWith(
    caches.match(e.request).then(function(response) {
      if (response) {
        return response;
      }
      console.log("fetch source");
    })
  );
});
```

> 打开页面，可以在开发者工具中的 `Application` 看到 `Service Worker` 已经启动了

![img](https://poetries1.gitee.io/img-repo/2020/09/96.png)

> 在 Cache 中也可以发现我们所需的文件已被缓存

![img](https://poetries1.gitee.io/img-repo/2020/09/97.png)

> 当我们重新刷新页面可以发现我们缓存的数据是从 `Service` `Worker` 中读取的

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_7-3-requestanimationframe用法)7.3 requestAnimationFrame用法

> 在Web应用中，实现动画效果的方法比较多，`Javascript` 中可以通过定时器 `setTimeout` 来实现，`css3` 可以使用 `transition` 和 `animation` 来实现，`html5` 中的 `canvas` 也可以实现。除此之外，html5 还提供一个专门用于请求动画的`API`，那就是 `requestAnimationFrame`，顾名思义就是请求动画帧

#### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_1-页面可见)1.页面可见

> 当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个 `visibilitychange`事件,并设置`document.hidden`属性为true；切换到显示状态时，页面为可见，也同样触发一个 `visibilitychange` 事件，设置`document.hidden`属性为`false`

#### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_2-动画帧请求回调函数列表)2.动画帧请求回调函数列表

> 每个`Document`都有一个动画帧请求回调函数列表，该列表可以看成是由`<handlerId, callback>`元组组成的集合。其中`handlerId`是一个整数，唯一地标识了元组在列表中的位置；`callback`是回调函数

#### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_3-屏幕刷新频率)3.屏幕刷新频率

> 即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是`60Hz`， 这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响

#### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_4-动画原理)4.动画原理

> 根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢

刷新频率为`60Hz`的屏幕每`16.7ms`刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即`1px`。这样一来，屏幕每次刷出来的图像位置都比前一个要差`1px`，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画

#### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_5-requestanimationframe用法)5.requestAnimationFrame用法

异步，传入的函数在重绘之前调用

**1. 写法：handlerId = requestAnimationFrame(callback)**

- 传入一个`callback`函数，即动画函数
- 返回值`handlerId`为浏览器定义的、大于`0`的整数，唯一标识了该回调函数在列表中位置

**2. 浏览器执行过程**

- 首先要判断`document.hidden`属性是否为`true`,即页面处于可见状态下才会执行
- 浏览器清空上一轮的动画函数
- 这个方法返回的handlerId 值会和动画函数callback，以`<handlerId , callback>` 进入到动画帧请求回调函数列
- 浏览器会遍历动画帧请求回调函数列表，根据handlerId 的值大小，依次去执行相应的动画函数

**3. 取消动画函数的方法**

```text
cancelAnimationFrame(handlerId)
```

#### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_6-与settimeout对比)6.与setTimeout对比

> 理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因

- `setTimeout`的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 `setTimeout` 的实际执行时间一般要比其设定的时间晚一些
- 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。

> 以上两种情况都会导致`setTimeout`的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢

> 首先要明白，`setTimeout`的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔`16.7ms`刷新一次，而`setTimeout`每隔`10ms`设置图像向左移动`1px`， 就会出现如下绘制过程：

- 第0ms: 屏幕未刷新，等待中，setTimeout也未执行，等待中；
- 第10ms: 屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px；
- 第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout 未执行，继续等待中；
- 第20ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=2px;
- 第30ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=3px;
- 第33.4ms: 屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中； …

> 从上面的绘制过程中可以看出，屏幕没有更新`left=2px`的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿

> 与`setTimeout`相比，`requestAnimationFrame`最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是`60Hz`,那么回调函数就每16.7ms被执行一次，如果刷新率是`75Hz`，那么这个时间间隔就变成了`1000/75=13.3ms`，换句话说就是，`requestAnimationFrame`的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

```js
var progress = 0;
//回调函数
function render() {  
  progress += 1; //修改图像的位置  
  if (progress < 100) {  //在动画没有结束前，递归渲染    
    window.requestAnimationFrame(render); 
  }
}
//第一帧渲染
window.requestAnimationFrame(render)
```

**除此之外，requestAnimationFrame还有以下两个优势**

- CPU节能：使用`setTimeout`实现的动画，当页面被隐藏或最小化时，`setTimeout` 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而`requestAnimationFrame`则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的`requestAnimationFrame`也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了`CPU`开销
- 函数节流：在高频率事件(`resize`,`scroll`等)中，为了防止在一个刷新间隔内发生多次函数执行，使用`requestAnimationFrame`可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每`16.7ms`刷新一次，多次绘制并不会在屏幕上体现出来

#### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_7-优雅降级)7.优雅降级

> 由于`requestAnimationFrame`目前还存在兼容性问题，而且不同的浏览器还需要带不同的前缀。因此需要通过优雅降级的方式对`requestAnimationFrame`进行封装，优先使用高级特性，然后再根据不同浏览器的情况进行回退，直至只能使用`setTimeout`的情况。下面的代码就是有人在github上提供的polyfill，详细介绍请参考github代码 [requestAnimationFrame(opens new window)](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdarius%2FrequestAnimationFrame)

```js
if (!Date.now)
    Date.now = function() { return new Date().getTime(); };
 
(function() {
    'use strict';
     
    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
        var vp = vendors[i];
        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];
        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']
                                   || window[vp+'CancelRequestAnimationFrame']);
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy
        || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
        var lastTime = 0;
        window.requestAnimationFrame = function(callback) {
            var now = Date.now();
            var nextTime = Math.max(lastTime + 16, now);
            return setTimeout(function() { callback(lastTime = nextTime); },
                              nextTime - now);
        };
        window.cancelAnimationFrame = clearTimeout;
    }
}())
```

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_8-页面加载执行)8 页面加载执行

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_8-1-浏览器事件循环)8.1 浏览器事件循环

> 事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表

- 微任务 `microtask(jobs): promise / process.nextTick / MutationObserver`
- 宏任务 `macrotask(task): setTimout / setInterval / setImmediate / script / IO / UI Rendering`

> 宏任务中包括了 `script` ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_8-2-怎么判断页面是否加载完成)8.2 怎么判断页面是否加载完成

- `Load` 事件触发代表页面中的 `DOM`，`CSS`，`JS`，图片已经全部加载完毕。
- `DOMContentLoaded` 事件触发代表初始的 `HTML` 被完全加载和解析，不需要等待 `CSS`，`JS`，图片加载

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_8-3-css-加载会造成阻塞吗)8.3 css 加载会造成阻塞吗 ？

- `DOM` 和 `CSSOM` 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析。
- 然而,由于 `Render Tree` 是依赖于 DOM Tree 和 `CSSOM Tree` 的,
- 所以他必须等待到 `CSSOM Tree` 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。
- 因此,CSS 加载会阻塞 Dom 的渲染。
- 由于 JavaScript 是可操纵 DOM 和 css 样式的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。
- 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。因此,样式表会在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_8-4-为什么-js-阻塞页面加载)8.4 为什么 JS 阻塞页面加载 ?

- 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了
- 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系
- 当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行
- 从上面我们可以推理出,由于 GUI 渲染线程与 JavaScript 执行线程是互斥的关系,
- 当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行
- 因此如果 JS执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_8-5-domcontentloaded-与-load-的区别)8.5 DOMContentLoaded 与 load 的区别 ?

- 当 `DOMContentLoaded` 事件触发时,仅当 `DOM` 解析完成后,不包括样式表,图片。我们前面提到 CSS 加载会阻塞 Dom 的渲染和后面 js 的执行,js 会阻塞 Dom 解析,所以我们可以得到结论:
- 当文档中没有脚本时,浏览器解析完文档便能触发 `DOMContentLoaded` 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,`DOMContentLoaded` 的触发不需要等待图片等其他资源加载完成
- 当 `onload` 事件触发时,页面上所有的 `DOM`,样式表,脚本,图片等资源已经加载完毕
- `DOMContentLoaded` -> `load`

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_8-6-什么是-crp-即关键渲染路径-如何优化)8.6 什么是 CRP,即关键渲染路径? 如何优化

> 关键渲染路径是浏览器将 HTML CSS JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤。也就是我们上面说的浏览器渲染流程。

为尽快完成首次渲染,我们需要最大限度减小以下三种可变因素:

- 关键资源的数量: 可能阻止网页首次渲染的资源。
- 关键路径长度: 获取所有关键资源所需的往返次数或总时间。
- 关键字节: 实现网页首次渲染所需的总字节数,等同于所有关键资源传送文件大小的总和

**1. 优化 DOM**

- 删除不必要的代码和注释包括空格,尽量做到最小化文件。
- 可以利用 GZIP 压缩文件。
- 结合 HTTP 缓存文件

**2. 优化 CSSOM**

> 缩小、压缩以及缓存同样重要,对于 CSSOM 我们前面重点提过了它会阻止页面呈现,因此我们可以从这方面考虑去优化。

- 减少关键 CSS 元素数量
- 当我们声明样式表时,请密切关注媒体查询的类型,它们极大地影响了 CRP 的性能

**3. 优化 JavaScript**

> 当浏览器遇到 script标记时,会阻止解析器继续操作,直到 CSSOM 构建完毕,JavaScript 才会运行并继续完成 DOM 构建过程。

- `async`: 当我们在 `script` 标记添加 `async` 属性以后,浏览器遇到这个 `script` 标记时会继续解析 DOM,同时脚本也不会被 `CSSOM` 阻止,即不会阻止 `CRP`。
- `defer`: 与 `async` 的区别在于,脚本需要等到文档解析后（ `DOMContentLoaded` 事件前）执行,而 `async` 允许脚本在文档解析时位于后台运行（两者下载的过程不会阻塞 `DOM`,但执行会）
- 当我们的脚本不会修改 `DOM` 或 `CSSOM` 时,推荐使用 async
- 预加载 —— `preload & prefetch`
- `DNS` 预解析 —— `dns-prefetch`

**总结**

- 分析并用 关键资源数 关键字节数 关键路径长度 来描述我们的 `CRP`
- 最小化关键资源数:消除它们（内联）、推迟它们的下载（`defer`）或者使它们异步解析（`async`）等
- 优化关键字节数（缩小、压缩）来减少下载时间 优化加载剩余关键资源的顺序:
- 让关键资源（`CSS`）尽早下载以减少 `CRP` 长度

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_9-history路由和hash路由)9 history路由和hash路由

**hash 路由**

> hash 路由，在 html5 前，为了解决单页路由跳转问题采用的方案， hash 的变化不会触发页面渲染，服务端也无法获取到 hash 值，前端可通过监听 hashchange 事件来处理hash值的变化

```text
window.addEventListener('hashchange', function(){ 
    // 监听hash变化，点击浏览器的前进后退会触发
})
```

**history 路由**

> history 路由，是 html5 的规范，提供了对`history`栈中内容的操作，常用api有：

```js
window.history.pushState(state, title, url) 
// let currentState = history.state; 获取当前state
// state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取
// title：标题，基本没用，一般传 null
// url：设定新的历史记录的 url。新的 url 与当前 url 的 origin 必须是一樣的，否则会抛出错误。url可以是绝对路径，也可以是相对路径。
//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/，
//执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/

window.history.replaceState(state, title, url)
// 与 pushState 基本相同，但她是修改当前历史记录，而 pushState 是创建新的历史记录

window.addEventListener("popstate", function() {
    // 监听浏览器前进后退事件，pushState 与 replaceState 方法不会触发              
});
```

## [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#_10-performance相关)10 performance相关

### [#](http://interview.poetries.top/excellent-docs/5-浏览器模块.html#window-performance-getentries)window.performance.getEntries()

> 浏览器获取网页时，会对网页中每一个对象（脚本文件、样式表、图片文件等等）发出一个HTTP请求。而通过`window.performance.getEntries`方法，则可以以数组形式，返回这些请求的时间统计信息，每个数组成员均是一个`PerformanceResourceTiming`对象！

用它小玩儿一下，统计页面上的静态资源加载耗时：

```js
(function () {
    // 浏览器不支持，就算了！
    if (!window.performance && !window.performance.getEntries) {
        return false;
    }

    var result = [];
    // 获取当前页面所有请求对应的PerformanceResourceTiming对象进行分析
    window.performance.getEntries().forEach(function (perf) {
        result.push({
            'url': perf.name,
            'entryType': perf.entryType,
            'type': perf.initiatorType,
            'duration(ms)': perf.duration
        });
    });

    // 控制台输出统计结果
    console.table(result);
})();
```

![img](http://img-repo.poetries.top/images/20210329140157.png)



# 6 React模块

## 1、React 中 keys 的作用是什么？

> `Keys`是 `React` 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识

- 在开发过程中，我们需要保证某个元素的 `key` 在其同级元素中具有唯一性。在 `React Diff` 算法中`React` 会借助元素的 `Key` 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 `Key` 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 `Key` 的重要性

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_2、传入-setstate-函数的第二个参数的作用是什么)2、传入 setState 函数的第二个参数的作用是什么？

> 该函数会在 `setState` 函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：

```js
this.setState(
  { username: 'tylermcginnis33' },
  () => console.log('setState has finished and the component has re-rendered.')
)
this.setState((prevState, props) => {
  return {
    streak: prevState.streak + props.count
  }
})
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_3、react-中-refs-的作用是什么)3、React 中 refs 的作用是什么

- `Refs` 是 `React` 提供给我们的安全访问 `DOM`元素或者某个组件实例的句柄
- 可以为元素添加`ref`属性然后在回调函数中接受该元素在 `DOM` 树中的句柄，该值会作为回调函数的第一个参数返回

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_4、在生命周期中的哪一步你应该发起-ajax-请求)4、在生命周期中的哪一步你应该发起 AJAX 请求

> 我们应当将AJAX 请求放到 `componentDidMount` 函数中执行，主要原因有下

- `React` 下一代调和算法 `Fiber` 会通过开始或停止渲染的方式优化应用性能，其会影响到 `componentWillMount` 的触发次数。对于 `componentWillMount` 这个生命周期函数的调用次数会变得不确定，`React` 可能会多次频繁调用 `componentWillMount`。如果我们将 `AJAX` 请求放到 `componentWillMount` 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。
- 如果我们将`AJAX` 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了`setState`函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 `componentDidMount` 函数中进行 `AJAX` 请求则能有效避免这个问题

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_5、shouldcomponentupdate-的作用)5、shouldComponentUpdate 的作用

> `shouldComponentUpdate` 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_6、如何告诉-react-它应该编译生产环境版)6、如何告诉 React 它应该编译生产环境版

> 通常情况下我们会使用 `Webpack` 的 `DefinePlugin` 方法来将 `NODE_ENV` 变量值设置为 `production`。编译版本中 `React`会忽略 `propType` 验证以及其他的告警信息，同时还会降低代码库的大小，`React` 使用了 `Uglify` 插件来移除生产环境下不必要的注释等信息

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_7、概述下-react-中的事件处理逻辑)7、概述下 React 中的事件处理逻辑

> 为了解决跨浏览器兼容性问题，`React` 会将浏览器原生事件（`Browser Native Event`）封装为合成事件（`SyntheticEvent`）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，`React` 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 `React` 在更新 `DOM` 的时候就不需要考虑如何去处理附着在 `DOM` 上的事件监听器，最终达到优化性能的目的

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_8、createelement-与-cloneelement-的区别是什么)8、createElement 与 cloneElement 的区别是什么

> ```
> createElement` 函数是 JSX 编译之后使用的创建 `React Element` 的函数，而 `cloneElement` 则是用于复制某个元素并传入新的 `Props
> ```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_9、redux中间件)9、redux中间件

> 中间件提供第三方插件的模式，自定义拦截 `action` -> `reducer` 的过程。变为 `action` -> `middlewares` -> `reducer`。这种机制可以让我们改变数据流，实现如异步`action` ，`action` 过滤，日志输出，异常报告等功能

- `redux-logger`：提供日志输出
- `redux-thunk`：处理异步操作
- `redux-promise`：处理异步操作，`actionCreator`的返回值是`promise`

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_10、redux有什么缺点)10、redux有什么缺点

- 一个组件所需要的数据，必须由父组件传过来，而不能像`flux`中直接从`store`取。
- 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新`render`，可能会有效率影响，或者需要写复杂的`shouldComponentUpdate`进行判断。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_11、react组件的划分业务组件技术组件)11、react组件的划分业务组件技术组件？

- 根据组件的职责通常把组件分为UI组件和容器组件。
- UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。
- 两者通过`React-Redux` 提供`connect`方法联系起来

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_12、react旧版生命周期函数)12、react旧版生命周期函数

**初始化阶段**

- `getDefaultProps`:获取实例的默认属性
- `getInitialState`:获取每个实例的初始化状态
- `componentWillMount`：组件即将被装载、渲染到页面上
- `render`:组件在这里生成虚拟的`DOM`节点
- `componentDidMount`:组件真正在被装载之后

**运行中状态**

- `componentWillReceiveProps`:组件将要接收到属性的时候调用
- `shouldComponentUpdate`:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止`render`调用，后面的函数不会被继续执行了）
- `componentWillUpdate`:组件即将更新不能修改属性和状态
- `render`:组件重新描绘
- `componentDidUpdate`:组件已经更新

**销毁阶段**

- `componentWillUnmount`:组件即将销毁

### [#](http://interview.poetries.top/excellent-docs/6-React.html#新版生命周期)新版生命周期

> 在新版本中，React 官方对生命周期有了新的 变动建议:

- 使用`getDerivedStateFromProps`替换`componentWillMount；`
- 使用`getSnapshotBeforeUpdate`替换`componentWillUpdate；`
- 避免使用`componentWillReceiveProps`；

> 其实该变动的原因，正是由于上述提到的 `Fiber`。首先，从上面我们知道 React 可以分成 `reconciliation` 与 `commit`两个阶段，对应的生命周期如下:

**reconciliation**

- `componentWillMount`
- `componentWillReceiveProps`
- `shouldComponentUpdate`
- `componentWillUpdate`

**commit**

- `componentDidMount`
- `componentDidUpdate`
- `componentWillUnmount`

> 在 `Fiber` 中，`reconciliation` 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 `reconciliation` 中的生命周期函数在一次更新渲染循环中被 多次调用 的情况，产生一些意外错误

新版的建议生命周期如下:

```js
class Component extends React.Component {
  // 替换 `componentWillReceiveProps` ，
  // 初始化和 update 时被调用
  // 静态函数，无法使用 this
  static getDerivedStateFromProps(nextProps, prevState) {}
  
  // 判断是否需要更新组件
  // 可以用于组件性能优化
  shouldComponentUpdate(nextProps, nextState) {}
  
  // 组件被挂载后触发
  componentDidMount() {}
  
  // 替换 componentWillUpdate
  // 可以在更新之前获取最新 dom 数据
  getSnapshotBeforeUpdate() {}
  
  // 组件更新后调用
  componentDidUpdate() {}
  
  // 组件即将销毁
  componentWillUnmount() {}
  
  // 组件已销毁
  componentDidUnMount() {}
}
```

**使用建议:**

- 在`constructor`初始化 `state`；

- 在`componentDidMount`中进行事件监听，并在`componentWillUnmount`中解绑事件；

- 在`componentDidMount`中进行数据的请求，而不是在`componentWillMount`；

- 需要根据

   

  ```
  props
  ```

   

  更新

   

  ```
  state
  ```

   

  时，使用

  ```
  getDerivedStateFromProps(nextProps, prevState)
  ```

  ；

  - 旧 props 需要自己存储，以便比较；

```js
public static getDerivedStateFromProps(nextProps, prevState) {
	// 当新 props 中的 data 发生变化时，同步更新到 state 上
	if (nextProps.data !== prevState.data) {
		return {
			data: nextProps.data
		}
	} else {
		return null1
	}
}
```

> 可以在componentDidUpdate监听 props 或者 state 的变化，例如:

```js
componentDidUpdate(prevProps) {
	// 当 id 发生变化时，重新获取数据
	if (this.props.id !== prevProps.id) {
		this.fetchData(this.props.id);
	}
}
```

- 在componentDidUpdate使用setState时，必须加条件，否则将进入死循环；
- getSnapshotBeforeUpdate(prevProps, prevState)可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前；
- shouldComponentUpdate: 默认每次调用setState，一定会最终走到 diff 阶段，但可以通过shouldComponentUpdate的生命钩子返回false来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_13、react性能优化是哪个周期函数)13、react性能优化是哪个周期函数

> `shouldComponentUpdate` 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在`shouldComponentUpdate方`法中能够写出更优化的`dom diff`算法，可以极大的提高性能

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_14、为什么虚拟dom会提高性能)14、为什么虚拟dom会提高性能

> 虚拟`dom`相当于在`js`和真实`dom`中间加了一个缓存，利用`dom diff`算法避免了没有必要的`dom`操作，从而提高性能

**具体实现步骤如下**

- 用 `JavaScript` 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 `DOM` 树，插到文档当中
- 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
- 把2所记录的差异应用到步骤1所构建的真正的`DOM`树上，视图就更新

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_15、diff算法)15、diff算法?

- 把树形结构按照层级分解，只比较同级元素。
- 给列表结构的每个单元添加唯一的`key`属性，方便比较。
- `React` 只会匹配相同 `class` 的 `component`（这里面的`class`指的是组件的名字）
- 合并操作，调用 `component` 的 `setState` 方法的时候, `React` 将其标记为 - `dirty`.到每一个事件循环结束, `React` 检查所有标记 `dirty`的 `component`重新绘制.
- 选择性子树渲染。开发人员可以重写`shouldComponentUpdate`提高`diff`的性能

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_16、react性能优化方案)16、react性能优化方案

- 重写`shouldComponentUpdate`来避免不必要的dom操作
- 使用 `production` 版本的`react.js`
- 使用`key`来帮助`React`识别列表中所有子组件的最小变化

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_16、简述flux-思想)16、简述flux 思想

> `Flux` 的最大特点，就是数据的"单向流动"。

- 用户访问 `View`
- `View`发出用户的 `Action`
- `Dispatcher` 收到`Action`，要求 `Store` 进行相应的更新
- `Store` 更新后，发出一个`"change"`事件
- `View` 收到`"change"`事件后，更新页面

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_17、说说你用react有什么坑点)17、说说你用react有什么坑点？

**1. JSX做表达式判断时候，需要强转为boolean类型**

> 如果不使用 `!!b` 进行强转数据类型，会在页面里面输出 `0`。

```jsx
render() {
  const b = 0;
  return <div>
    {
      !!b && <div>这是一段文本</div>
    }
  </div>
}
```

**2. 尽量不要在 `componentWillReviceProps` 里使用 setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃**

**3. 给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次ref这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有的时候去ref赋值后的属性会取到null**

**4. 遍历子节点的时候，不要用 index 作为组件的 key 进行传入**

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_18、我现在有一个button-要用react在上面绑定点击事件-要怎么做)18、我现在有一个button，要用react在上面绑定点击事件，要怎么做？

```jsx
class Demo {
  render() {
    return <button onClick={(e) => {
      alert('我点击了按钮')
    }}>
      按钮
    </button>
  }
}
```

**你觉得你这样设置点击事件会有什么问题吗？**

> 由于`onClick`使用的是匿名函数，所有每次重渲染的时候，会把该`onClick`当做一个新的`prop`来处理，会将内部缓存的`onClick`事件进行重新赋值，所以相对直接使用函数来说，可能有一点的性能下降

修改

```js
class Demo {

  onClick = (e) => {
    alert('我点击了按钮')
  }

  render() {
    return <button onClick={this.onClick}>
      按钮
    </button>
  }
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_19、react-的虚拟dom是怎么实现的)19、react 的虚拟dom是怎么实现的

> 首先说说为什么要使用`Virturl DOM`，因为操作真实`DOM`的耗费的性能代价太高，所以`react`内部使用`js`实现了一套dom结构，在每次操作在和真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，递归找出有变化的dom节点，然后对其进行更新操作。为了实现虚拟`DOM`，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行`diff`的时候，`react`会先比较该节点类型，假如节点类型不一样，那么`react`会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较`prop`是否有更新，假如有`prop`不一样，那么`react`会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_20、react-的渲染过程中-兄弟节点之间是怎么处理的-也就是key值不一样的时候)20、react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候

> 通常我们输出节点的时候都是map一个数组然后返回一个`ReactNode`，为了方便`react`内部进行优化，我们必须给每一个`reactNode`添加`key`，这个`key prop`在设计值处不是给开发者用的，而是给react用的，大概的作用就是给每一个`reactNode`添加一个身份标识，方便react进行识别，在重渲染过程中，如果key一样，若组件属性有所变化，则`react`只更新组件对应的属性；没有变化则不更新，如果key不一样，则react先销毁该组件，然后重新创建该组件

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_21、介绍一下react)21、介绍一下react

1. 以前我们没有jquery的时候，我们大概的流程是从后端通过ajax获取到数据然后使用jquery生成dom结果然后更新到页面当中，但是随着业务发展，我们的项目可能会越来越复杂，我们每次请求到数据，或则数据有更改的时候，我们又需要重新组装一次dom结构，然后更新页面，这样我们手动同步dom和数据的成本就越来越高，而且频繁的操作dom，也使我我们页面的性能慢慢的降低。
2. 这个时候mvvm出现了，mvvm的双向数据绑定可以让我们在数据修改的同时同步dom的更新，dom的更新也可以直接同步我们数据的更改，这个特定可以大大降低我们手动去维护dom更新的成本，mvvm为react的特性之一，虽然react属于单项数据流，需要我们手动实现双向数据绑定。
3. 有了mvvm还不够，因为如果每次有数据做了更改，然后我们都全量更新dom结构的话，也没办法解决我们频繁操作dom结构(降低了页面性能)的问题，为了解决这个问题，react内部实现了一套虚拟dom结构，也就是用js实现的一套dom结构，他的作用是讲真实dom在js中做一套缓存，每次有数据更改的时候，react内部先使用算法，也就是鼎鼎有名的diff算法对dom结构进行对比，找到那些我们需要新增、更新、删除的dom节点，然后一次性对真实DOM进行更新，这样就大大降低了操作dom的次数。 那么diff算法是怎么运作的呢，首先，diff针对类型不同的节点，会直接判定原来节点需要卸载并且用新的节点来装载卸载的节点的位置；针对于节点类型相同的节点，会对比这个节点的所有属性，如果节点的所有属性相同，那么判定这个节点不需要更新，如果节点属性不相同，那么会判定这个节点需要更新，react会更新并重渲染这个节点。
4. react设计之初是主要负责UI层的渲染，虽然每个组件有自己的state，state表示组件的状态，当状态需要变化的时候，需要使用setState更新我们的组件，但是，我们想通过一个组件重渲染它的兄弟组件，我们就需要将组件的状态提升到父组件当中，让父组件的状态来控制这两个组件的重渲染，当我们组件的层次越来越深的时候，状态需要一直往下传，无疑加大了我们代码的复杂度，我们需要一个状态管理中心，来帮我们管理我们状态state。
5. 这个时候，redux出现了，我们可以将所有的state交给redux去管理，当我们的某一个state有变化的时候，依赖到这个state的组件就会进行一次重渲染，这样就解决了我们的我们需要一直把state往下传的问题。redux有action、reducer的概念，action为唯一修改state的来源，reducer为唯一确定state如何变化的入口，这使得redux的数据流非常规范，同时也暴露出了redux代码的复杂，本来那么简单的功能，却需要完成那么多的代码。
6. 后来，社区就出现了另外一套解决方案，也就是mobx，它推崇代码简约易懂，只需要定义一个可观测的对象，然后哪个组价使用到这个可观测的对象，并且这个对象的数据有更改，那么这个组件就会重渲染，而且mobx内部也做好了是否重渲染组件的生命周期shouldUpdateComponent，不建议开发者进行更改，这使得我们使用mobx开发项目的时候可以简单快速的完成很多功能，连redux的作者也推荐使用mobx进行项目开发。但是，随着项目的不断变大，mobx也不断暴露出了它的缺点，就是数据流太随意，出了bug之后不好追溯数据的流向，这个缺点正好体现出了redux的优点所在，所以针对于小项目来说，社区推荐使用mobx，对大项目推荐使用redux

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_22、react怎么做数据的检查和变化)22、React怎么做数据的检查和变化

> ```
> Model`改变之后（可能是调用了`setState`），触发了`virtual dom`的更新，再用`diff`算法来`把virtual DOM`比较`real DOM`，看看是哪个`dom`节点更新了，再渲染`real dom
> ```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_23、react-router里的-link-标签和-a-标签有什么区别)23、react-router里的`<Link>`标签和`<a>`标签有什么区别

> 对比`<a>`,`Link`组件避免了不必要的重渲染

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_24、connect原理)24、connect原理

- 首先`connect`之所以会成功，是因为`Provider`组件：
- 在原应用组件上包裹一层，使原来整个应用成为`Provider`的子组件 接收`Redux`的`store`作为`props`，通过`context`对象传递给子孙组件上的`connect`

> `connect`做了些什么。它真正连接 `Redux` 和 `React`，它包在我们的容器组件的外一层，它接收上面 `Provider` 提供的 `store` 里面的`state` 和 `dispatch`，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件

- `connect`是一个高阶函数，首先传入`mapStateToProps`、`mapDispatchToProps`，然后返回一个生产`Component`的函数(`wrapWithConnect`)，然后再将真正的`Component`作为参数传入`wrapWithConnect`，这样就生产出一个经过包裹的`Connect`组件，

**该组件具有如下特点**

- 通过`props.store`获取祖先`Component`的`store props`包括`stateProps`、`dispatchProps`、`parentProps`,合并在一起得到`nextState`，作为`props`传给真正的`Component componentDidMount`时，添加事件`this.store.subscribe(this.handleChange)`，实现页面交互
- `shouldComponentUpdate`时判断是否有避免进行渲染，提升页面性能，并得到`nextState` `componentWillUnmount`时移除注册的事件`this.handleChange`

> 由于`connect`的源码过长，我们只看主要逻辑

```js
export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {
  return function wrapWithConnect(WrappedComponent) {
    class Connect extends Component {
      constructor(props, context) {
        // 从祖先Component处获得store
        this.store = props.store || context.store
        this.stateProps = computeStateProps(this.store, props)
        this.dispatchProps = computeDispatchProps(this.store, props)
        this.state = { storeState: null }
        // 对stateProps、dispatchProps、parentProps进行合并
        this.updateState()
      }
      shouldComponentUpdate(nextProps, nextState) {
        // 进行判断，当数据发生改变时，Component重新渲染
        if (propsChanged || mapStateProducedChange || dispatchPropsChanged) {
          this.updateState(nextProps)
            return true
          }
        }
        componentDidMount() {
          // 改变Component的state
          this.store.subscribe(() = {
            this.setState({
              storeState: this.store.getState()
            })
          })
        }
        render() {
          // 生成包裹组件Connect
          return (
            <WrappedComponent {...this.nextState} />
          )
        }
      }
      Connect.contextTypes = {
        store: storeShape
      }
      return Connect;
    }
  }
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_25、redux实现原理解析)25、Redux实现原理解析

**为什么要用redux**

> 在`React`中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过`props`）,所以，两个非父子组件之间通信就相对麻烦，`redux`的出现就是为了解决`state`里面的数据问题

**Redux设计理念**

> `Redux`是将整个应用状态存储到一个地方上称为`store`,里面保存着一个状态树`store tree`,组件可以派发(`dispatch`)行为(`action`)给`store`,而不是直接通知其他组件，组件内部通过订阅`store`中的状态`state`来刷新自己的视图

![img](http://poetries1.gitee.io/img-repo/2020/07/68.png)

**Redux三大原则**

- 唯一数据源

> 整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中

- 保持只读状态

> `state`是只读的，唯一改变`state`的方法就是触发`action`，`action`是一个用于描述以发生时间的普通对象

- 数据改变只能通过纯函数来执行

> 使用纯函数来执行修改，为了描述`action`如何改变`state`的，你需要编写`reducers`

**Redux源码**

```js
let createStore = (reducer) => {
    let state;
    //获取状态对象
    //存放所有的监听函数
    let listeners = [];
    let getState = () => state;
    //提供一个方法供外部调用派发action
    let dispath = (action) => {
        //调用管理员reducer得到新的state
        state = reducer(state, action);
        //执行所有的监听函数
        listeners.forEach((l) => l())
    }
    //订阅状态变化事件，当状态改变发生之后执行监听函数
    let subscribe = (listener) => {
        listeners.push(listener);
    }
    dispath();
    return {
        getState,
        dispath,
        subscribe
    }
}
let combineReducers=(renducers)=>{
    //传入一个renducers管理组，返回的是一个renducer
    return function(state={},action={}){
        let newState={};
        for(var attr in renducers){
            newState[attr]=renducers[attr](state[attr],action)

        }
        return newState;
    }
}
export {createStore,combineReducers};
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_26、purecomponent和functioncomponent区别)26、pureComponent和FunctionComponent区别

> `PureComponent`和`Component`完全相同，但是在`shouldComponentUpdate`实现中，`PureComponent`使用了`props`和`state`的浅比较。主要作用是用来提高某些特定场景的性能

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_27-react-hooks-它带来了那些便利)27 react hooks，它带来了那些便利

- 代码逻辑聚合，逻辑复用
- HOC嵌套地狱
- 代替class

> React 中通常使用 类定义 或者 函数定义 创建组件:

在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。

**好处:**

1. 跨组件复用: 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；
2. 类定义更为复杂

- 不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；
- 时刻需要关注this的指向问题；
- 代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；

1. 状态与UI隔离: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。

**注意:**

- 避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；
- 只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；
- 不能在useEffect中使用useState，React 会报错提示；
- 类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；

**重要钩子**

1. 状态钩子 (useState): 用于定义组件的 State，其到类定义中this.state的功能；

```js
// useState 只接受一个参数: 初始状态
// 返回的是组件名和更改该组件对应的函数
const [flag, setFlag] = useState(true);
// 修改状态
setFlag(false)
	
// 上面的代码映射到类定义中:
this.state = {
	flag: true	
}
const flag = this.state.flag
const setFlag = (bool) => {
    this.setState({
        flag: bool,
    })
}
```

1. 生命周期钩子 (useEffect):

> 类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (useEffect)，这里可以看做componentDidMount、componentDidUpdate和componentWillUnmount的结合。

**useEffect(callback, [source])接受两个参数**

- callback: 钩子回调函数；
- source: 设置触发条件，仅当 source 发生改变时才会触发；
- useEffect钩子在没有传入[source]参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；

```js
useEffect(() => {
	// 组件挂载后执行事件绑定
	console.log('on')
	addEventListener()
	
	// 组件 update 时会执行事件解绑
	return () => {
		console.log('off')
		removeEventListener()
	}
}, [source]);


// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):
// --- DidMount ---
// 'on'
// --- DidUpdate ---
// 'off'
// 'on'
// --- DidUpdate ---
// 'off'
// 'on'
// --- WillUnmount --- 
// 'off'
```

**通过第二个参数，我们便可模拟出几个常用的生命周期:**

- componentDidMount: 传入[]时，就只会在初始化时调用一次

```text
const useMount = (fn) => useEffect(fn, [])
```

- componentWillUnmount: 传入[]，回调中的返回的函数也只会被最终执行一次

```js
const useUnmount = (fn) => useEffect(() => fn, [])
```

- mounted: 可以使用 useState 封装成一个高度可复用的 mounted 状态；

```js
const useMounted = () => {
    const [mounted, setMounted] = useState(false);
    useEffect(() => {
        !mounted && setMounted(true);
        return () => setMounted(false);
    }, []);
    return mounted;
}
```

- componentDidUpdate: useEffect每次均会执行，其实就是排除了 DidMount 后即可；

```js
const mounted = useMounted() 
useEffect(() => {
    mounted && fn()
})
```

1. 其它内置钩子:

- `useContext`: 获取 context 对象

- ```
  useReducer
  ```

  : 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:

  - 并不是持久化存储，会随着组件被销毁而销毁；
  - 属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；
  - 配合useContext`的全局性，可以完成一个轻量级的 Redux；(easy-peasy)

- `useCallback`: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；

- `useMemo`: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；

- `useRef`: 获取组件的真实节点；

- ```
  useLayoutEffect
  ```

  - DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同
  - useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发；
  - 可以获取更新后的 state；

1. 自定义钩子(useXxxxx): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的useMounted。又例如，我们需要每个页面自定义标题:

```js
function useTitle(title) {
  useEffect(
    () => {
      document.title = title;
    });
}

// 使用:
function Home() {
	const title = '我是首页'
	useTitle(title)
	
	return (
		<div>{title}</div>
	)
}
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_28、react-portal-有哪些使用场景)28、React Portal 有哪些使用场景

- 在以前， react 中所有的组件都会位于 #app 下，而使用 Portals 提供了一种脱离 #app 的组件
- 因此 Portals 适合脱离文档流(out of flow) 的组件，特别是 position: absolute 与 position: fixed的组件。比如模态框，通知，警告，goTop 等。

以下是官方一个模态框的示例，可以在以下地址中测试效果

```html
<html>
  <body>
    <div id="app"></div>
    <div id="modal"></div>
    <div id="gotop"></div>
    <div id="alert"></div>
  </body>
</html>
const modalRoot = document.getElementById('modal');

class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement('div');
  }

  componentDidMount() {
    modalRoot.appendChild(this.el);
  }

  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }

  render() {
    return ReactDOM.createPortal(
      this.props.children,
      this.el,
    );
  }
}
```

**React Hooks当中的useEffect是如何区分生命周期钩子的**

> useEffect可以看成是`componentDidMount`，`componentDidUpdate`和`componentWillUnmount`三者的结合。useEffect(callback, [source])接收两个参数，调用方式如下

```js
 useEffect(() => {
   console.log('mounted');
   
   return () => {
       console.log('willUnmount');
   }
 }, [source]);
```

> 生命周期函数的调用主要是通过第二个参数[source]来进行控制，有如下几种情况：

- `[source]`参数不传时，则每次都会优先调用上次保存的函数中返回的那个函数，然后再调用外部那个函数；
- `[source]`参数传[]时，则外部的函数只会在初始化时调用一次，返回的那个函数也只会最终在组件卸载时调用一次；
- `[source]`参数有值时，则只会监听到数组中的值发生变化后才优先调用返回的那个函数，再调用外部的函数。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_29、react和vue的区别)29、react和vue的区别

**相同点：**

1. 数据驱动页面，提供响应式的试图组件
2. 都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范
3. 数据流动单向，都支持服务器的渲染SSR
4. 都有支持native的方法，react有React native， vue有wexx

**不同点：**

1. 数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2. 数据渲染：大规模的数据渲染，react更快
3. 使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4. 开发风格：react推荐做法jsx + inline style把html和css都写在js了

> vue是采用webpack +vue-loader单文件组件格式，html, js, css同一个文件

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_30、什么是高阶组件-hoc)30、什么是高阶组件(HOC)

- 高阶组件(Higher Order Componennt)本身其实不是组件，而是一个函数，这个函数接收一个元组件作为参数，然后返回一个新的增强组件，高阶组件的出现本身也是为了逻辑复用，举个例子

```js
function withLoginAuth(WrappedComponent) {
  return class extends React.Component {
      
      constructor(props) {
          super(props);
          this.state = {
            isLogin: false
          };
      }
      
      async componentDidMount() {
          const isLogin = await getLoginStatus();
          this.setState({ isLogin });
      }
      
      render() {
        if (this.state.isLogin) {
            return <WrappedComponent {...this.props} />;
        }
        
        return (<div>您还未登录...</div>);
      }
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_31、react实现的移动应用中-如果出现卡顿-有哪些可以考虑的优化方案)31、React实现的移动应用中，如果出现卡顿，有哪些可以考虑的优化方案

- 增加`shouldComponentUpdate`钩子对新旧`props`进行比较，如果值相同则阻止更新，避免不必要的渲染，或者使用`PureReactComponent`替代`Component`，其内部已经封装了`shouldComponentUpdate`的浅比较逻辑
- 对于列表或其他结构相同的节点，为其中的每一项增加唯一`key`属性，以方便`React`的`diff`算法中对该节点的复用，减少节点的创建和删除操作
- `render`函数中减少类似`onClick={() => {doSomething()}}`的写法，每次调用render函数时均会创建一个新的函数，即使内容没有发生任何变化，也会导致节点没必要的重渲染，建议将函数保存在组件的成员对象中，这样只会创建一次
- 组件的`props`如果需要经过一系列运算后才能拿到最终结果，则可以考虑使用`reselect`库对结果进行缓存，如果props值未发生变化，则结果直接从缓存中拿，避免高昂的运算代价
- `webpack-bundle-analyzer`分析当前页面的依赖包，是否存在不合理性，如果存在，找到优化点并进行优化

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_32、fiber)32、Fiber

**React 的核心流程可以分为两个部分:**

- ```
  reconciliation
  ```

   

  (调度算法，也可称为

   

  ```
  render
  ```

  )

  - 更新 `state` 与 `props`；

  - 调用生命周期钩子；

  - 生成

     

    ```
    virtual dom
    ```

    - 这里应该称为 `Fiber Tree` 更为符合；

  - 通过新旧 vdom 进行 diff 算法，获取 vdom change

  - 确定是否需要重新渲染

- ```
  commit
  ```

  - 如需要，则操作 `dom` 节点更新

> 要了解 Fiber，我们首先来看为什么需要它

- **问题**: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。
- **解决方**案: 解决同步阻塞的方法，通常有两种: 异步 与 任务分割。而 React Fiber 便是为了实现任务分割而诞生的
- 简述
  - 在 `React V16` 将调度算法进行了重构， 将之前的 `stack reconciler` 重构成新版的 fiber `reconciler`，变成了具有链表和指针的 单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启
  - 这里我理解为是一种 任务分割调度算法，主要是 将原先同步更新渲染的任务分割成一个个独立的 小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制
- 核心
  - `Fiber` 这里可以具象为一个 数据结构

```js
class Fiber {
	constructor(instance) {
		this.instance = instance
		// 指向第一个 child 节点
		this.child = child
		// 指向父节点
		this.return = parent
		// 指向第一个兄弟节点
		this.sibling = previous
	}	
}
```

- 链表树遍历算法

  : 通过 节点保存与映射，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提

  - 首先通过不断遍历子节点，到树末尾；
  - 开始通过 `sibling` 遍历兄弟节点；
  - return 返回父节点，继续执行2；
  - 直到 root 节点后，跳出遍历；

- 任务分割

  ，React 中的渲染更新可以分成两个阶段

  - **reconciliation 阶段**: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对
  - **Commit 阶段**: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况

- 分散执行:

   

  任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API:

   

  ```
  requestIdleCallback
  ```

   

  与

   

  ```
  requestAnimationFrame
  ```

  - 低优先级的任务交给`requestIdleCallback`处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 `pollyfill`，而且拥有 `deadline` 参数，限制执行事件，以继续切分任务；
  - 高优先级的任务交给`requestAnimationFrame`处理；

```js
// 类似于这样的方式
requestIdleCallback((deadline) => {
    // 当有空闲时间时，我们执行一个组件渲染；
    // 把任务塞到一个个碎片时间中去；
    while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && nextComponent) {
        nextComponent = performWork(nextComponent);
    }
});
```

- **优先级策略:** 文本框输入 > 本次调度结束需完成的任务 > 动画过渡 > 交互反馈 > 数据更新 > 不会显示但以防将来会显示的任务

> - Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。
> - 核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。
> - 当遇到进程阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_33、setstate)33、setState

> 在了解setState之前，我们先来简单了解下 React 一个包装结构: Transaction:

**事务 (Transaction)**

> 是 React 中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作

- setState: React 中用于修改状态，更新视图。它具有以下特点:

**异步与同步:** setState并不是单纯的异步或同步，这其实与调用时的环境相关:

- 在

  合成事件

   

  和

   

  生命周期钩子

  (除 componentDidUpdate) 中，setState是"异步"的；

  - 原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；
    - 在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；
    - 在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；
  - 问题: 无法在setState后马上从this.state上获取更新后的值。
  - 解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；

- 在

   

  原生事件

   

  和 setTimeout 中，setState是同步的，可以马上获取更新后的值；

  - 原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；

- **批量更新**: 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；

- 函数式

  : 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) => newState)；

  - 使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用；

**注意事项:**

- setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；
- 当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法
  - 将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；
  - 在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_34、hoc-高阶组件)34、HOC(高阶组件)

> HOC(Higher Order Componennt) 是在 React 机制下社区形成的一种组件模式，在很多第三方开源库中表现强大。

**简述:**

- 高阶组件不是组件，是 增强函数，可以输入一个元组件，返回出一个新的增强组件；
- 高阶组件的主要作用是 代码复用，操作 状态和参数；

**用法:**

- 属性代理 (Props Proxy): 返回出一个组件，它基于被包裹组件进行 功能增强；

1. 默认参数: 可以为组件包裹一层默认参数；

```js
function proxyHoc(Comp) {
	return class extends React.Component {
		render() {
			const newProps = {
				name: 'tayde',
				age: 1,
			}
			return <Comp {...this.props} {...newProps} />
		}
	}
}
```

1. 提取状态: 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件:

```js
function withOnChange(Comp) {
	return class extends React.Component {
		constructor(props) {
			super(props)
			this.state = {
				name: '',
			}
		}
		onChangeName = () => {
			this.setState({
				name: 'dongdong',
			})
		}
		render() {
			const newProps = {
				value: this.state.name,
				onChange: this.onChangeName,
			}
			return <Comp {...this.props} {...newProps} />
		}
	}
}
```

使用姿势如下，这样就能非常快速的将一个 Input 组件转化成受控组件。

```js
const NameInput = props => (<input name="name" {...props} />)
export default withOnChange(NameInput)
```

**包裹组件: 可以为被包裹元素进行一层包装，**

```js
function withMask(Comp) {
  return class extends React.Component {
      render() {
		  return (
		      <div>
				  <Comp {...this.props} />
					<div style={{
					  width: '100%',
					  height: '100%',
					  backgroundColor: 'rgba(0, 0, 0, .6)',
				  }} 
			  </div>
		  )
	  }
  }
}
```

> **反向继承** (Inheritance Inversion): 返回出一个组件，继承于被包裹组件，常用于以下操作

```js
function IIHoc(Comp) {
    return class extends Comp {
        render() {
            return super.render();
        }
    };
}
```

**渲染劫持 (Render Highjacking)**

条件渲染: 根据条件，渲染不同的组件

```js
function withLoading(Comp) {
    return class extends Comp {
        render() {
            if(this.props.isLoading) {
                return <Loading />
            } else {
                return super.render()
            }
        }
    };
}
```

可以直接修改被包裹组件渲染出的 React 元素树

**操作状态 (Operate State)**: 可以直接通过 this.state 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。

**应用场景:**

> 权限控制，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染:

```js
function withAdminAuth(WrappedComponent) {
    return class extends React.Component {
		constructor(props){
			super(props)
			this.state = {
		    	isAdmin: false,
			}
		} 
		async componentWillMount() {
		    const currentRole = await getCurrentUserRole();
		    this.setState({
		        isAdmin: currentRole === 'Admin',
		    });
		}
		render() {
		    if (this.state.isAdmin) {
		        return <Comp {...this.props} />;
		    } else {
		        return (<div>您没有权限查看该页面，请联系管理员！</div>);
		    }
		}
    };
}
```

**性能监控**，包裹组件的生命周期，进行统一埋点:

```js
function withTiming(Comp) {
    return class extends Comp {
        constructor(props) {
            super(props);
            this.start = Date.now();
            this.end = 0;
        }
        componentDidMount() {
            super.componentDidMount && super.componentDidMount();
            this.end = Date.now();
            console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`);
        }
        render() {
            return super.render();
        }
    };
}
```

代码复用，可以将重复的逻辑进行抽象。

**使用注意:**

- 纯函数: 增强函数应为纯函数，避免侵入修改元组件；

- 避免用法污染: 理想状态下，应透传元组件的无关参数与事件，尽量保证用法不变；

- 命名空间: 为 HOC 增加特异性的组件名称，这样能便于开发调试和查找问题；

- **引用传递**: 如果需要传递元组件的 refs 引用，可以使用React.forwardRef；

- 静态方法

  : 元组件上的静态方法并无法被自动传出，会导致业务层无法调用；解决:

  - 函数导出
  - 静态方法赋值

- **重新渲**染: 由于增强函数每次调用是返回一个新组件，因此如果在 Render中使用增强函数，就会导致每次都重新渲染整个HOC，而且之前的状态会丢失；

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_35、react如何进行组件-逻辑复用)35、React如何进行组件/逻辑复用?

> 抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:

- 高阶组件:
  - 属性代理
  - 反向继承
- 渲染属性
- react-hooks

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_36、你对-time-slice的理解)36、你对 Time Slice的理解?

**时间分片**

- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式

> 也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果呢？

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_37、setstate到底是异步还是同步)37、setState到底是异步还是同步?

> 先给出答案: 有时表现出异步,有时表现出同步

- `setState`只在合成事件和钩子函数中是“异步”的，在原生事件和`setTimeout` 中都是同步的
- `setState` 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数`setState(partialState, callback)`中的`callback`拿到更新后的结果
- `setState` 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和`setTimeout` 中不会批量更新，在“异步”中如果对同一个值进行多次`setState`，`setState`的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时`setState`多个不同的值，在更新时会对其进行合并批量更新

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_38-react-diff-算法)38 react diff 算法

![img](http://img-repo.poetries.top/images/20210307225249.png)

**diff算法的作用**

计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。

**传统diff算法**

> 通过循环递归对节点进行依次对比，算法复杂度达到 `O(n^3)` ，n是树的节点数，这个有多可怕呢？——如果要展示1000个节点，得执行上亿次比较。。即便是CPU快能执行30亿条命令，也很难在一秒内计算出差异。

**React的diff算法**

1. 什么是调和？

> 将Virtual DOM树转换成actual DOM树的最少操作的过程 称为 调和 。

1. 什么是React diff算法？

> `diff`算法是调和的具体实现。

**diff策略**

> React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度

**策略一（tree diff）：**

- Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。

**策略二（component diff）：**

- 拥有相同类的两个组件 生成相似的树形结构，
- 拥有不同类的两个组件 生成不同的树形结构。

**策略三（element diff）：**

对于同一层级的一组子节点，通过唯一id区分。

**tree diff**

- React通过updateDepth对Virtual DOM树进行层级控制。
- 对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。
- 只需遍历一次，就能完成整棵DOM树的比较。

![image-20210307224725566](http://img-repo.poetries.top/images/image-20210307224725566.png)

那么问题来了，如果DOM节点出现了跨层级操作,diff会咋办呢？

> 答：diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。

![image-20210307224829092](http://img-repo.poetries.top/images/image-20210307224829092.png)

> 如上图所示，以A为根节点的整棵树会被重新创建，而不是移动，因此 官方建议不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，而不是真正地移除、添加DOM节点

### [#](http://interview.poetries.top/excellent-docs/6-React.html#component-diff)component diff

> React对不同的组件间的比较，有三种策略

1. 同一类型的两个组件，按原策略（层级比较）继续比较Virtual DOM树即可。
2. 同一类型的两个组件，组件A变化为组件B时，可能Virtual DOM没有任何变化，如果知道这点（变换的过程中，Virtual DOM没有改变），可节省大量计算时间，所以 用户 可以通过 `shouldComponentUpdate()` 来判断是否需要 判断计算。
3. 不同类型的组件，将一个（将被改变的）组件判断为`dirty component`（脏组件），从而替换 整个组件的所有节点。

> 注意：如果组件D和组件G的结构相似，但是 React判断是 不同类型的组件，则不会比较其结构，而是删除 组件D及其子节点，创建组件G及其子节点。

### [#](http://interview.poetries.top/excellent-docs/6-React.html#element-diff)element diff

> 当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。

- 插入：组件 C 不在集合（A,B）中，需要插入
- 删除：
  - 组件 D 在集合（A,B,D）中，但 D的节点已经更改，不能复用和更新，所以需要删除 旧的 D ，再创建新的。
  - 组件 D 之前在 集合（A,B,D）中，但集合变成新的集合（A,B）了，D 就需要被删除。
- 移动：组件D已经在集合（A,B,C,D）里了，且集合更新时，D没有发生更新，只是位置改变，如新集合（A,D,B,C），D在第二个，无须像传统diff，让旧集合的第二个B和新集合的第二个D 比较，并且删除第二个位置的B，再在第二个位置插入D，而是 （对同一层级的同组子节点） 添加唯一key进行区分，移动即可。

### [#](http://interview.poetries.top/excellent-docs/6-React.html#diff的不足与待优化的地方)diff的不足与待优化的地方

> 尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，会影响React的渲染性能

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_39-redux-中间件)39 redux 中间件

> 中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过 滤，日志输出，异常报告等功能

常见的中间件:

- redux-logger:提供日志输出;
- redux-thunk:处理异步操作;
- redux-promise: 处理异步操作;
- actionCreator 的返回值是 promise

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_40-redux-有什么缺点)40 redux 有什么缺点

- 一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取
- 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 `shouldComponentUpdate` 进行判断

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_41-为什么虚拟-dom-会提高性能)41 为什么虚拟 dom 会提高性能

> 虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要 的 dom 操作，从而提高性能

**具体实现步骤如下:**

1. 用 JavaScript 对象结构表示 DOM 树的结构;然后用这个树构建一个真正的 DOM 树， 插到文档当中;
2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记 录两棵树差异;
3. 把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_42-diff-算法)42 diff 算法?

- 把树形结构按照层级分解，只比较同级元素
- 给列表结构的每个单元添加唯一的 key 属性，方便比较
- React 只会匹配相同 class 的 component(这里面的 class 指的是组件的名字)
- 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个 事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.
- 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_43-react-生命周期函数)43 React 生命周期函数

**挂载阶段**

挂载阶段也可以理解为初始化阶段，也就是把我们的组件插入到 DOM 中。

- `constructor`
- `getDerivedStateFromProps`
- `~~UNSAFE_componentWillMount~~`
- `render`
- `(React Updates DOM and refs)`
- `componentDidMount`

1. constructor

组件的构造函数，第一个被执行。显式定义构造函数时，需要在第一行执行 `super(props)`，否则不能再构造函数中拿到 `this`。

在构造函数中，我们一般会做两件事：

- 初始化 state
- 对自定义方法进行 this 绑定

1. getDerivedStateFromProps

是一个静态函数，所以不能在这里使用 this，也表明了 React 官方不希望调用方滥用这个生命周期函数。每当父组件引发当前组件的渲染过程时，getDerivedStateFromProps 都会被调用，这样我们有机会根据新的 props 和当前的 state 来调整一个新的 state。

这个函数会在收到新的 props，调用了 setState 或 forceUpdate 时被调用。

1. render

React 最核心的方法，class 组件中必须实现的方法。

当 render 被调用时，它会检查 `this.props` 和 `this.state` 的变化并返回一下类型之一：

- 原生的 DOM，如 div
- React 组件
- 数组或 Fragment
- Portals（传送门）
- 字符串或数字，被渲染成文本节点
- 布尔值或 null，不会渲染任何东西

1. componentDidMount

在组件挂载之后立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。这个方法比较适合添加订阅的地方，如果添加了订阅，请记得在卸载的时候取消订阅。

你可以在 componentDidMount 里面直接调用 setState，它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前，如此保证了即使 render 了两次，用户也不会看到中间状态。

**更新阶段**

> 更新阶段是指当组件的 props 发生了改变，或者组件内部调用了 setState 或者发生了 forceUpdate，这个阶段的过程包括：

- `UNSAFE_componentWillReceiveProps`
- `getDerivedStateFromProps`
- `sholdComponentUpdate`
- `UNSAFE_componentWIllUpdate`
- `render`
- `getSnapshotBeforeUpdate`
- `(React Updates DOM and refs)`
- `componentDidUpdate`

1. shouldComponentUpdate

它有两个参数，根据此函数的返回值来判断是否重新进行渲染，首次渲染或者是当我们调用了 forceUpdate 时并不会触发此方法，此方法仅用于性能优化。

但是官方提倡我们使用内置的 PureComponent 而不是自己编写 shouldComponentUpdate。

1. getSnapshotBeforeUpdate

这个生命周期函数发生在 render 之后，在更新之前，给了一个机会去获取 DOM 信息，计算得到并返回一个 snapshot，这个 snapshot 会作为 componentDidUpdate 第三个参数传入。

1. componentDidUpdate

这个函数会在更新后被立即调用，首次渲染不会执行此方法。在这个函数中我们可以操作 DOM，可以发起请求，还可以 setState，但注意一定要用条件语句，否则会导致无限循环。

**卸载阶段**

1. componentWillUnmount

这个生命周期函数会在组件卸载销毁之前被调用，我们可以在这里执行一些清除操作。不要在这里调用 setState，因为组件不会重新渲染。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_44-react的虚拟dom和diff算法的内部实现)44 React的虚拟DOM和Diff算法的内部实现

> 传统 diff 算法的时间复杂度是 O(n^3)，这在前端 render 中是不可接受的。为了降低时间复杂度，react 的 diff 算法做了一些妥协，放弃了最优解，最终将时间复杂度降低到了 O(n)。

那么 react diff 算法做了哪些妥协呢？，参考如下：

1. tree diff：只对比同一层的 dom 节点，忽略 dom 节点的跨层级移动

如下图，react 只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。

这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

![image-20210302195610674](http://img-repo.poetries.top/images/image-20210302195610674.png)

这就意味着，如果 dom 节点发生了跨层级移动，react 会删除旧的节点，生成新的节点，而不会复用。

1. component diff：如果不是同一类型的组件，会删除旧的组件，创建新的组件

![image-20210302195654736](http://img-repo.poetries.top/images/image-20210302195654736.png)

1. element diff：对于同一层级的一组子节点，需要通过唯一 id 进行来区分

- 如果没有 id 来进行区分，一旦有插入动作，会导致插入位置之后的列表全部重新渲染
- 这也是为什么渲染列表时为什么要使用唯一的 key。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_45-react的fiber工作原理-解决了什么问题)45 React的Fiber工作原理，解决了什么问题

- React Fiber 是一种基于浏览器的单线程调度算法。

> React Fiber 用类似 requestIdleCallback 的机制来做异步 diff。但是之前数据结构不支持这样的实现异步 diff，于是 React 实现了一个类似链表的数据结构，将原来的 递归diff 变成了现在的 遍历diff，这样就能做到异步可更新了

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_46-setstate-是同步的还是异步的)46 setState 是同步的还是异步的

有时表现出同步，有时表现出异步

1. setState 只有在 React 自身的合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步的
2. setState 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的异步。当然可以通过 setState 的第二个参数中的 callback 拿到更新后的结果
3. setState 的批量更新优化也是建立在异步（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在异步中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，去最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新

- 合成事件中是异步
- 钩子函数中的是异步
- 原生事件中是同步
- setTimeout中是同步

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_47-调用-setstate-之后发生了什么)47 调用 setState 之后发生了什么

> 在代码中调用 setState 函数之后，React 会将传入的参数与之前的状态进行合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会计算出新的树和老的树之间的差异，然后根据差异对界面进行最小化重新渲染。通过 diff 算法，React 能够精确制导哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。

- 在 setState 的时候，React 会为当前节点创建一个 updateQueue 的更新列队。
- 然后会触发 reconciliation 过程，在这个过程中，会使用名为 Fiber 的调度算法，开始生成新的 Fiber 树， Fiber 算法的最大特点是可以做到异步可中断的执行。
- 然后 React Scheduler 会根据优先级高低，先执行优先级高的节点，具体是执行 doWork 方法。
- 在 doWork 方法中，React 会执行一遍 updateQueue 中的方法，以获得新的节点。然后对比新旧节点，为老节点打上 更新、插入、替换 等 Tag。
- 当前节点 doWork 完成后，会执行 performUnitOfWork 方法获得新节点，然后再重复上面的过程。
- 当所有节点都 doWork 完成后，会触发 commitRoot 方法，React 进入 commit 阶段。
- 在 commit 阶段中，React 会根据前面为各个节点打的 Tag，一次性更新整个 dom 元素

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_48-key的作用)48 key的作用

> 是给每一个 vnode 的唯一 id,可以依靠 key,更准确,更快的拿到 oldVnode 中对应的 vnode 节点

```html
<!-- 更新前 -->
<div>
  <p key="ka">ka</p>
  <h3 key="song">song</he>
</div>

<!-- 更新后 -->
<div>
  <h3 key="song">song</h3>
  <p key="ka">ka</p>
</div>
```

如果没有 key，React 会认为 div 的第一个子节点由 p 变成 h3，第二个子节点由 h3 变成 p，则会销毁这两个节点并重新构造。

但是当我们用 key 指明了节点前后对应关系后，React 知道 `key === "ka"` 的 p 更新后还在，所以可以复用该节点，只需要交换顺序。

key 是 React 用来追踪哪些列表元素被修改、被添加或者被移除的辅助标志。

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React diff 算法中，React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重新渲染。同时，React 还需要借助 key 来判断元素与本地状态的关联关系。

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_49-diff-的瓶颈以及-react-的应对)49 Diff 的瓶颈以及 React 的应对

由于 diff 操作本身会带来性能上的损耗，在 React 文档中提到过，即使最先进的算法中，将前后两棵树完全比对的算法复杂度为`O(n3)`，其中 n 为树中元素的数量。

如果 React 使用了该算法，那么仅仅一千个元素的页面所需要执行的计算量就是十亿的量级，这无疑是无法接受的。

为了降低算法的复杂度，React 的 diff 会预设三个限制：

1. 只对同级元素进行 diff 比对。如果一个元素节点在前后两次更新中跨越了层级，那么 React 不会尝试复用它
2. 两个不同类型的元素会产生出不同的树。如果元素由 div 变成 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点
3. 开发者可以通过 key 来暗示哪些子元素在不同的渲染下能保持稳定

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_50-react-setstate-笔试题-下面的代码输出什么)50 React setState 笔试题，下面的代码输出什么

```js
class Example extends React.Component {
  constructor() {
  super()
  this.state = {
    val: 0
  }
}
componentDidMount() {
  this.setState({ val: this.state.val + 1 })
  console.log(this.state.val)
  // 第 1 次 log
  this.setState({ val: this.state.val + 1 })
  console.log(this.state.val)
  // 第 2 次 log
  setTimeout(() => {
    this.setState({ val: this.state.val + 1 })
    console.log(this.state.val)
    // 第 3 次 log
    this.setState({ val: this.state.val + 1 })
    console.log(this.state.val)
    // 第 4 次 log
    }, 0)
  }
  render() {
    return null
  }
}

// 答：0, 0, 1, 2
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_51-redux-中间件原理)51 Redux 中间件原理

- 指的是action和store之间，沟通的桥梁就是dispatch，action就是个对象。比如你用了redux-thunk，action也可以是个函数，怎么实现这个过程，就是通过中间件这个桥梁帮你实现的。action到达store之前会走中间件，这个中间件会把函数式的action转化为一个对象，在传递给store

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_52-componentwillreceiveprops调用时机)52 componentWillReceiveProps调用时机

- 已经被废弃掉
- 当props改变的时候才调用，子组件第二次接收到props的时候

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_53-react-性能优化)53 React 性能优化

- shouldCompoentUpdate
- pureComponent 自带shouldCompoentUpdate的浅比较优化
- 结合Immutable.js达到最优

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_54-refs的作用是什么-你在什么样的业务场景下使用refs)54 refs的作用是什么，你在什么样的业务场景下使用refs

- 操作DOM，为什么操作DOM?
- 场景
  - 图片渲染好后，操作图片宽高。比如做个放大镜功能

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_55-ref是一个函数又有什么好处)55 ref是一个函数又有什么好处？

- 方便react销毁组件、重新渲染的时候去清空refs的东西，防止内存泄露

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_56-受控组件、非受控组件)56 受控组件、非受控组件

- 受控组件就是改变受控于数据的变化，数据变了页面也变了。受控组件更合适，数据驱动是react核心
- 非受控组件不是通过数据控制页面内容

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_57-哪个生命周期发送ajax)57 哪个生命周期发送ajax

- componentWillMount在新版本react中已经被废弃了
- 在做ssr项目时候，componentWillMount要做服务端数据的获取，不能被占用
- 所以在componentDidMount中请求

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_58-ssr原理是什么)58 ssr原理是什么？

> 核心原理其实就是借助虚拟DOM来实现react代码能够在服务器运行的，node里面可以执行react代码

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_59-组件是什么-类是什么-类变编译成什么)59 组件是什么？类是什么？类变编译成什么

- 组件指的是页面的一部分，本质就是一个类，最本质就是一个构造函数
- 类编译成构造函数

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_60-如何避免重复发起ajax获取数据)60 如何避免重复发起ajax获取数据？

- 数据放在redux里面

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_61-react-router4的核心)61 react-router4的核心

- 路由变成了组件
- 分散到各个页面，不需要配置 比如`<link> <route></route>`

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_62-什么情况下使用异步组件)62 什么情况下使用异步组件

- 提高页面加载速度，使用`reloadable`把各个页面分别单独打包，按需加载

### [#](http://interview.poetries.top/excellent-docs/6-React.html#useeffect-fn-和-componentdidmount-有什么差异)useEffect(fn, []) 和 componentDidMount 有什么差异

> `useEffect` 会捕获 `props` 和 state。所以即便在回调函数里，你拿到的还是初始的 props 和 state。如果想得到“最新”的值，可以使用 ref。

### [#](http://interview.poetries.top/excellent-docs/6-React.html#hooks-为什么不能放在条件判断里)hooks 为什么不能放在条件判断里

以 setState 为例，在 react 内部，每个组件(Fiber)的 hooks 都是以链表的形式存在 memoizeState 属性中

![image-20210302195353472](http://img-repo.poetries.top/images/image-20210302195353472.png)

> update 阶段，每次调用 setState，链表就会执行 next 向后移动一步。如果将 setState 写在条件判断中，假设条件判断不成立，没有执行里面的 setState 方法，会导致接下来所有的 setState 的取值出现偏移，从而导致异常发生。

### [#](http://interview.poetries.top/excellent-docs/6-React.html#react-父组件如何调用子组件中的方法)React 父组件如何调用子组件中的方法？

1. 如果是在方法组件中调用子组件（>= react@16.8），可以使用 useRef 和 `useImperativeHandle`:

```js
const { forwardRef, useRef, useImperativeHandle } = React;

const Child = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({
    getAlert() {
      alert("getAlert from Child");
    }
  }));
  return <h1>Hi</h1>;
});

const Parent = () => {
  const childRef = useRef();
  return (
    <div>
      <Child ref={childRef} />
      <button onClick={() => childRef.current.getAlert()}>Click</button>
    </div>
  );
};
```

1. 如果是在类组件中调用子组件（`>= react@16.4`），可以使用 createRef:

```text
const { Component } = React;

class Parent extends Component {
  constructor(props) {
    super(props);
    this.child = React.createRef();
  }

  onClick = () => {
    this.child.current.getAlert();
  };

  render() {
    return (
      <div>
        <Child ref={this.child} />
        <button onClick={this.onClick}>Click</button>
      </div>
    );
  }
}

class Child extends Component {
  getAlert() {
    alert('getAlert from Child');
  }

  render() {
    return <h1>Hello</h1>;
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_63-react有哪些优化性能的手段)63 React有哪些优化性能的手段

**类组件中的优化手段**

- 使用纯组件 `PureComponent` 作为基类。
- 使用 `React.memo` 高阶函数包装组件。
- 使用 `shouldComponentUpdate` 生命周期函数来自定义渲染逻辑。

**方法组件中的优化手段**

- 使用 `useMemo`。
- 使用 `useCallBack`。

**其他方式**

- 在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。
- 必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。
- 使用 `Suspense` 和 lazy 进行懒加载，例如：

```js
import React, { lazy, Suspense } from "react";

export default class CallingLazyComponents extends React.Component {
  render() {
    var ComponentToLazyLoad = null;

    if (this.props.name == "Mayank") {
      ComponentToLazyLoad = lazy(() => import("./mayankComponent"));
    } else if (this.props.name == "Anshul") {
      ComponentToLazyLoad = lazy(() => import("./anshulComponent"));
    }

    return (
      <div>
        <h1>This is the Base User: {this.state.name}</h1>
        <Suspense fallback={<div>Loading...</div>}>
          <ComponentToLazyLoad />
        </Suspense>
      </div>
    )
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_64-为什么-react-元素有一个-typeof-属性)64 为什么 React 元素有一个 $$typeof 属性

![image-20210302200213923](http://img-repo.poetries.top/images/image-20210302200213923.png)

> 目的是为了防止 XSS 攻击。因为 Synbol 无法被序列化，所以 React 可以通过有没有 $$typeof 属性来断出当前的 element 对象是从数据库来的还是自己生成的。

- 如果没有 $$typeof 这个属性，react 会拒绝处理该元素。
- 在 React 的古老版本中，下面的写法会出现 XSS 攻击：

```text
// 服务端允许用户存储 JSON
let expectedTextButGotJSON = {
  type: 'div',
  props: {
    dangerouslySetInnerHTML: {
      __html: '/* 把你想的搁着 */'
    },
  },
  // ...
};
let message = { text: expectedTextButGotJSON };

// React 0.13 中有风险
<p>
  {message.text}
</p>
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_65-react-如何区分-class组件-和-function组件)65 React 如何区分 Class组件 和 Function组件

一般的方式是借助 typeof 和 Function.prototype.toString 来判断当前是不是 class，如下：

```js
function isClass(func) {
  return typeof func === 'function'
    && /^class\s/.test(Function.prototype.toString.call(func));
}
```

但是这个方式有它的局限性，因为如果用了 babel 等转换工具，将 class 写法全部转为 function 写法，上面的判断就会失效。

> React 区分 Class组件 和 Function组件的方式很巧妙，由于所有的类组件都要继承 React.Component，所以只要判断原型链上是否有 React.Component 就可以了：

```text
AComponent.prototype instanceof React.Component
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_66-为什么-jsx-中的组件名要以大写字母开头)66 为什么 JSX 中的组件名要以大写字母开头

因为 React 要知道当前渲染的是组件还是 HTML 元素

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_67-react-redux-的实现原理)67 react-redux 的实现原理？

> 通过 redux 和 react context 配合使用，并借助高阶函数，实现了 react-redux

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_68-diff算法是怎么运作)68 diff算法是怎么运作

每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_69-react中这两个生命周期会触发死循环)69 react中这两个生命周期会触发死循环

> `componentWillUpdate`生命周期在`shouldComponentUpdate`返回true后被触发。在这两个生命周期只要视图更新就会触发，因此不能再这两个生命周期中使用setState。否则会导致死循环

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_70-dva工作原理)70 Dva工作原理

> 集成`redux+redux-saga`

**工作原理**

> 改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 `dispatch` 发起一个 `action`，如果是同步行为会直接通过 `Reducers` 改变 `State` ，如果是异步行为（副作用）会先触发 `Effects` 然后流向 `Reducers` 最终改变 `State`

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_71-redux内部原理-内部怎么实现dispstch一个函数的)71 Redux内部原理 内部怎么实现dispstch一个函数的

> 以`redux-thunk`中间件作为例子，下面就是`thunkMiddleware`函数的代码

```js
// 部分转为ES5代码，运行middleware函数会返回一个新的函数，如下：
return ({ dispatch, getState }) => {
    // next实际就是传入的dispatch
    return function (next) {
        return function (action) {
            // redux-thunk核心
            if (typeof action === 'function') { 
                return action(dispatch, getState, extraArgument);
            }
            return next(action);
        };
    };
}
```

> `redux-thunk`库内部源码非常的简单，允许`action`是一个函数，同时支持参数传递，否则调用方法不变

- `redux`创建`Store`：通过`combineReducers`函数合并`reducer`函数，返回一个新的函数`combination`（这个函数负责循环遍历运行`reducer`函数，返回全部`state`）。将这个新函数作为参数传入`createStore`函数，函数内部通过dispatch，初始化运行传入的`combination`，state生成，返回store对象
- `redux`中间件：`applyMiddleware`函数中间件的主要目的就是修改`dispatch`函数，返回经过中间件处理的新的`dispatch`函数
- `redux`使用：实际就是再次调用循环遍历调用`reducer`函数，更新`state`

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_72-调和阶段-setstate内部干了什么)72 调和阶段 setState内部干了什么

- 当调用 setState 时，React会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态
- 这将启动一个称为和解（`reconciliation`）的过程。和解（`reconciliation`）的最终目标是以最有效的方式，根据这个新的状态来更新`UI`。 为此，`React`将构建一个新的 `React` 元素树（您可以将其视为 `UI` 的对象表示）
- 一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（ diff ）

> 通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新即可最小化 UI 的占用空间

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_73-createelement过程)73 createElement过程

> React.createElement()： 根据指定的第一个参数创建一个React元素

```text
React.createElement(
  type,
  [props],
  [...children]
)
```

- 第一个参数是必填，传入的是似HTML标签名称，eg: ul, li
- 第二个参数是选填，表示的是属性，eg: className
- 第三个参数是选填, 子节点，eg: 要显示的文本内容

```js
//写法一：

var child1 = React.createElement('li', null, 'one');
    var child2 = React.createElement('li', null, 'two');
    var content = React.createElement('ul', { className: 'teststyle' }, child1, child2); // 第三个参数可以分开也可以写成一个数组
      ReactDOM.render(
          content,
        document.getElementById('example')
      );

//写法二：

var child1 = React.createElement('li', null, 'one');
    var child2 = React.createElement('li', null, 'two');
    var content = React.createElement('ul', { className: 'teststyle' }, [child1, child2]);
      ReactDOM.render(
          content,
        document.getElementById('example')
      );
```

## [#](http://interview.poetries.top/excellent-docs/6-React.html#_74-为什么有些react生命周期钩子被标记为unsafe)74 为什么有些react生命周期钩子被标记为UNSAFE

### [#](http://interview.poetries.top/excellent-docs/6-React.html#componentwillmount)componentWillMount

> componentWillMount生命周期发生在首次渲染前，一般使用的小伙伴大多在这里初始化数据或异步获取外部数据赋值。初始化数据，react官方建议放在constructor里面。而异步获取外部数据，渲染并不会等待数据返回后再去渲染

```js
class Example extends React.Component {   
    state = {
        value: ''
    };
    componentWillMount() {    
        this.setState({       
            value: this.props.source.value
        });       
        this.props.source.subscribe(this.handleChange);
    }   
    componentWillUnmount() {    
        this.props.source.unsubscribe(this.handleChange ); 
    }   
    handleChange = source => {    
        this.setState({
            value: source.value
        });   
    }; 
}
```

- 试想一下，假如组件在第一次渲染的时候被中断，由于组件没有完成渲染，所以并不会执行componentWillUnmount生命周期（注：很多人经常认为componentWillMount和componentWillUnmount总是配对，但这并不是一定的。只有调用componentDidMount后，React才能保证稍后调用componentWillUnmount进行清理）。因此handleSubscriptionChange还是会在数据返回成功后被执行，这时候setState由于组件已经被移除，就会导致内存泄漏。所以建议把异步获取外部数据写在componentDidMount生命周期里，这样就能保证componentWillUnmount生命周期会在组件移除的时候被执行，避免内存泄漏的风险。
- 现在，小伙伴清楚为什么了要用`UNSAFE_componentWillMount`替换`componentWillMount`了吧

### [#](http://interview.poetries.top/excellent-docs/6-React.html#componentwillreceiveprops)componentWillReceiveProps

> componentWillReceiveProps生命周期是在props更新时触发。一般用于props参数更新时同步更新state参数。但如果在componentWillReceiveProps生命周期直接调用父组件的某些有调用setState的函数，会导致程序死循环

```js
// 如下是子组件componentWillReceiveProps里调用父组件改变state的函数示例

class Parent extends React.Component{
    constructor(){
        super();
        this.state={
            list: [],
            selectedData: {}
        };
    }
    
    changeSelectData = selectedData => {
        this.setState({
            selectedData
        });
    }
    
    render(){
        return (
            <Clild list={this.state.list} changeSelectData={this.changeSelectData}/>
        );
    }
}
 
...
class Child extends React.Component{
    constructor(){
        super();
        this.state={
            list: []
        };
    }
    componentWillReceiveProps(nextProps){
        this.setState({
            list: nextProps.list
        })
        nextProps.changeSelectData(nextProps.list[0]); //默认选择第一个
    }
    ...
}
```

- 如上代码，在Child组件的componentWillReceiveProps里直接调用Parent组件的changeSelectData去更新Parent组件state的selectedData值。会触发Parent组件重新渲染，而Parent组件重新渲染会触发Child组件的componentWillReceiveProps生命周期函数执行。如此就会陷入死循环。导致程序崩溃。
- 所以，React官方把componentWillReceiveProps替换为UNSAFE_componentWillReceiveProps，让小伙伴在使用这个生命周期的时候注意它会有缺陷，要注意避免，比如上面例子，Child在componentWillReceiveProps调用changeSelectData时先判断list是否有更新再确定是否要调用，就可以避免死循环。

### [#](http://interview.poetries.top/excellent-docs/6-React.html#componentwillupdate)componentWillUpdate

componentWillUpdate生命周期在视图更新前触发。一般用于视图更新前保存一些数据方便视图更新完成后赋值。 案例三：如下是列表加载更新后回到当前滚动条位置的案例

```js
class ScrollingList extends React.Component {   
    listRef = null;   
    previousScrollOffset = null;   
    componentWillUpdate(nextProps, nextState) {    
        if (this.props.list.length < nextProps.list.length) {      
            this.previousScrollOffset = this.listRef.scrollHeight - this.listRef.scrollTop;    
        } 
    }   
    componentDidUpdate(prevProps, prevState) {    
        if (this.previousScrollOffset !== null) {      
            this.listRef.scrollTop = this.listRef.scrollHeight - this.previousScrollOffset;  
            this.previousScrollOffset = null;    
        }   
    }   
    render() {    
        return (       
            `<div>` {/* ...contents... */}`</div>`     
        );   
    }   
    setListRef = ref => {    this.listRef = ref;   };
```

- 由于componentWillUpdate和componentDidUpdate这两个生命周期函数有一定的时间差（componentWillUpdate后经过渲染、计算、再更新DOM元素，最后才调用componentDidUpdate），如果这个时间段内用户刚好拉伸了浏览器高度，那componentWillUpdate计算的previousScrollOffset就不准确了。如果在componentWillUpdate进行setState操作，会出现多次调用只更新一次的问题，把setState放在componentDidUpdate，能保证每次更新只调用一次。
- 所以，react官方建议把componentWillUpdate替换为UNSAFE_componentWillUpdate。如果真的有以上案例的需求，可以使用16.3新加入的一个周期函数getSnapshotBeforeUpdat

### [#](http://interview.poetries.top/excellent-docs/6-React.html#结论)结论

- React意识到componentWillMount、componentWillReceiveProps和componentWillUpdate这三个生命周期函数有缺陷，比较容易导致崩溃。但是由于旧的项目已经在用以及有些老开发者习惯用这些生命周期函数，于是通过给它加UNSAFE_来提醒用它的人要注意它们的缺陷
- React加入了两个新的生命周期函数getSnapshotBeforeUpdate和getDerivedStateFromProps，目的为了即使不使用这三个生命周期函数，也能实现只有这三个生命周期能实现的功能

# 7 Vue模块

## 1 对于MVVM的理解

> `MVVM`是`Model-View-ViewModel`缩写，也就是把MVC中的Controller演变成`ViewModel`。Model层代表数据模型，`View`代表UI组件，`ViewModel`是`View`和`Model`层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。

- `MVVM` 是 `Model-View-ViewModel` 的缩写
- `Model`: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为
- `View`: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View
- `ViewModel`： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.
- **总结**： `MVVM`模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，`ViewModel` 会自动更新，而 `ViewModel` 变化时，View 也会自动变化。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_2-请详细说下你对vue生命周期的理解)2 请详细说下你对vue生命周期的理解

> 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后

**生命周期是什么**

> Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是Vue的生命周期

**各个生命周期的作用**

| 生命周期      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 组件实例被创建之初，组件的属性生效之前                       |
| created       | 组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用 |
| beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用           |
| mounted       | el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子    |
| beforeUpdate  | 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前              |
| update        | 组件数据更新之后                                             |
| activited     | keep-alive专属，组件被激活时调用                             |
| deadctivated  | keep-alive专属，组件被销毁时调用                             |
| beforeDestory | 组件销毁前调用                                               |
| destoryed     | 组件销毁后调用                                               |

![img](http://poetries1.gitee.io/img-repo/2020/07/61.png)

> 由于Vue会在初始化实例时对属性执行`getter/setter`转化，所以属性必须在`data`对象上存在才能让`Vue`将它转换为响应式的。Vue提供了`$set`方法用来触发视图更新

```js
export default {
    data(){
        return {
            obj: {
                name: 'fei'
            }
        }
    },
    mounted(){
        this.$set(this.obj, 'sex', 'man')
    }

}
```

**什么是vue生命周期？**

- 答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。

**vue生命周期的作用是什么？**

- 答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

**vue生命周期总共有几个阶段？**

- 答：它可以总共分为`8`个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。

**第一次页面加载会触发哪几个钩子？**

- 答：会触发下面这几个`beforeCreate`、`created`、`beforeMount`、`mounted` 。

**DOM 渲染在哪个周期中就已经完成？**

- 答：`DOM` 渲染在 `mounted` 中就已经完成了

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_3-vue实现数据双向绑定的原理-object-defineproperty)3 Vue实现数据双向绑定的原理：Object.defineProperty()

- `vue`实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 `Object.defineProperty()` 来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 `Javascript` 对象传给 Vue 实例来作为它的 `data` 选项时，Vue 将遍历它的属性，用 `Object.defineProperty()` 将它们转为 `getter/setter`。用户看不到 `getter/setter`，但是在内部它们让 `Vue`追踪依赖，在属性被访问和修改时通知变化。
- vue的数据双向绑定 将`MVVM`作为数据绑定的入口，整合`Observer`，`Compile`和`Watcher`三者，通过`Observer`来监听自己的`model`的数据变化，通过`Compile`来解析编译模板指令（`vue`中是用来解析 `{{}}`），最终利用`watcher`搭起`observer`和`Compile`之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（`input`）—>数据`model`变更双向绑定效果。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_4-vue组件间的参数传递)4 Vue组件间的参数传递

**父组件与子组件传值**

> 父组件传给子组件：子组件通过`props`方法接受数据；

- 子组件传给父组件： `$emit` 方法传递参数

**非父子组件间的数据传递，兄弟组件传值**

> `eventBus`，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用`VUEX`，具体来说看需求）

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_5-vue的路由实现-hash模式-和-history模式)5 Vue的路由实现：hash模式 和 history模式

- `hash`模式：在浏览器中符号`“#”`，#以及#后面的字符称之为`hash`，用 `window.location.hash` 读取。特点：`hash`虽然在`URL`中，但不被包括在`HTTP`请求中；用来指导浏览器动作，对服务端安全无用，`hash`不会重加载页面。
- `history`模式：h`istory`采用`HTML5`的新特性；且提供了两个新方法： `pushState()`， `replaceState()`可以对浏览器历史记录栈进行修改，以及`popState`事件的监听到状态变更

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_5-vue路由的钩子函数)5 vue路由的钩子函数

> 首页可以控制导航跳转，`beforeEach`，`afterEach`等，一般用于页面`title`的修改。一些需要登录才能调整页面的重定向功能。

- `beforeEach`主要有3个参数`to`，`from`，`next`。
- `to`：`route`即将进入的目标路由对象。
- `from`：`route`当前导航正要离开的路由。
- `next`：`function`一定要调用该方法`resolve`这个钩子。执行效果依赖n`ext`方法的调用参数。可以控制网页的跳转

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_6-vuex是什么-怎么使用-哪种功能场景使用它)6 vuex是什么？怎么使用？哪种功能场景使用它？

- 只用来读取的状态集中放在`store`中； 改变状态的方式是提交`mutations`，这是个同步的事物； 异步逻辑应该封装在`action`中。
- 在`main.js`引入`store`，注入。新建了一个目录`store`，`… export`
- **场景有**：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车

![img](http://poetries1.gitee.io/img-repo/2020/07/62.png)

- `state`：`Vuex` 使用单一状态树,即每个应用将仅仅包含一个`store` 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。
- `mutations`：`mutations`定义的方法动态修改`Vuex` 的 `store` 中的状态或数据
- `getters`：类似`vue`的计算属性，主要用来过滤一些数据。
- `action`：`actions`可以理解为通过将`mutations`里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。`view` 层通过 `store.dispath` 来分发 `action`

![img](http://poetries1.gitee.io/img-repo/2020/07/63.png)

> `modules`：项目特别复杂的时候，可以让每一个模块拥有自己的`state`、`mutation`、`action`、`getters`，使得结构非常清晰，方便管理

![img](http://poetries1.gitee.io/img-repo/2020/07/64.png)

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_7-v-if-和-v-show-区别)7 v-if 和 v-show 区别

- 答：`v-if`按照条件是否渲染，`v-show`是`display`的`block`或`none`；

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_8-route和-router的区别)8 `$route`和`$router`的区别

- `$route`是“路由信息对象”，包括`path`，`params`，`hash`，`query`，`fullPath`，`matched`，`name`等路由信息参数。
- 而`$router`是“路由实例”对象包括了路由的跳转方法，钩子函数等

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_9-如何让css只在当前组件中起作用)9 如何让CSS只在当前组件中起作用?

> 将当前组件的`<style>`修改为`<style scoped>`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_10-keep-alive-keep-alive-的作用是什么)10 `<keep-alive></keep-alive>`的作用是什么?

> keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载

- `<keep-alive></keep-alive>` 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染

> 比如有一个列表和一个详情，那么用户就会经常执行打开详情=>返回列表=>打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用`<keep-alive></keep-alive>`进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染

- 常用的两个属性`include/exclude`，允许组件有条件的进行缓存
- 两个生命周期`activated/deactivated`，用来得知当前组件是否处于活跃状态

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_11-指令v-el的作用是什么)11 指令v-el的作用是什么?

> 提供一个在页面上已存在的 `DOM`元素作为 `Vue`实例的挂载目标.可以是 CSS 选择器，也可以是一个 `HTMLElement` 实例,

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_12-在vue中使用插件的步骤)12 在Vue中使用插件的步骤

- 采用`ES6`的`import ... from ...`语法或`CommonJS`的`require()`方法引入插件
- 使用全局方法`Vue.use( plugin )`使用插件,可以传入一个选项对象`Vue.use(MyPlugin, { someOption: true })`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_13-请列举出3个vue中常用的生命周期钩子函数)13 请列举出3个Vue中常用的生命周期钩子函数?

- `created`: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, `watch/event`事件回调. 然而, 挂载阶段还没有开始, `$el`属性目前还不可见
- `mounted`: `el`被新创建的 `vm.$el` 替换，并挂载到实例上去之后调用该钩子。如果 `root` 实例挂载了一个文档内元素，当 `mounted`被调用时 `vm.$el` 也在文档内。
- `activated`: `keep-alive`组件激活时调用

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_14-vue-cli-工程技术集合介绍)14 vue-cli 工程技术集合介绍

**问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？**

- `vue.js`：`vue-cli`工程的核心，主要特点是 双向数据绑定 和 组件系统。
- `vue-router`：`vue`官方推荐使用的路由框架。
- `vuex`：专为 `Vue.js` 应用项目开发的状态管理器，主要用于维护`vue`组件间共用的一些 变量 和 方法。
- `axios`（ 或者 `fetch` 、`ajax` ）：用于发起 `GET` 、或 `POST` 等 `http`请求，基于 `Promise` 设计。
- `vuex`等：一个专为`vue`设计的移动端UI组件库。
- 创建一个`emit.js`文件，用于`vue`事件机制的管理。
- `webpack`：模块加载和`vue-cli`工程打包器。

**问题二：vue-cli 工程常用的 npm 命令有哪些？**

- 下载 `node_modules` 资源包的命令：

```text
npm install
```

- 启动 `vue-cli` 开发环境的 npm命令：

```text
npm run dev
```

- `vue-cli` 生成 生产环境部署资源 的 `npm`命令：

```text
npm run build
```

- 用于查看 `vue-cli` 生产环境部署资源文件大小的 `npm`命令：

```text
npm run build --report
```

> 在浏览器上自动弹出一个 展示 `vue-cli` 工程打包后 `app.js`、`manifest.js`、`vendor.js` 文件里面所包含代码的页面。可以具此优化 `vue-cli` 生产环境部署的静态资源，提升 页面 的加载速度

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_15-nexttick)15 NextTick

> 在下次`dom`更新循环结束之后执行延迟回调，可用于获取更新后的`dom`状态

- 新版本中默认是`mincrotasks`, `v-on`中会使用`macrotasks`

- ```
  macrotasks
  ```

  任务的实现:

  - `setImmediate / MessageChannel / setTimeout`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_16-vue的优点是什么)16 vue的优点是什么？

- 低耦合。视图（`View`）可以独立于`Model`变化和修改，一个`ViewModel`可以绑定到不同的`"View"`上，当View变化的时候Model可以不变，当`Model`变化的时候`View`也可以不变
- 可重用性。你可以把一些视图逻辑放在一个`ViewModel`里面，让很多`view`重用这段视图逻辑
- 可测试。界面素来是比较难于测试的，而现在测试可以针对`ViewModel`来写

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_17-路由之间跳转)17 路由之间跳转？

**声明式（标签跳转）**

```text
<router-link :to="index">
```

**编程式（ js跳转）**

```text
router.push('index')
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_18-实现-vue-ssr)18 实现 Vue SSR

**其基本实现原理**

- `app.js` 作为客户端与服务端的公用入口，导出 `Vue` 根实例，供客户端 `entry` 与服务端 `entry` 使用。客户端 `entry` 主要作用挂载到 `DOM` 上，服务端 `entry` 除了创建和返回实例，还进行路由匹配与数据预获取。
- `webpack` 为客服端打包一个 `Client Bundle` ，为服务端打包一个 `Server Bundle` 。
- 服务器接收请求时，会根据 `url`，加载相应组件，获取和解析异步数据，创建一个读取 `Server Bundle` 的 `BundleRenderer`，然后生成 `html` 发送给客户端。
- 客户端混合，客户端收到从服务端传来的 `DOM` 与自己的生成的 DOM 进行对比，把不相同的 `DOM` 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 `stroe` 里，这样，在客户端挂载到 `DOM` 之前，可以直接从 `store`里取数据。首屏的动态数据通过 `window.__INITIAL_STATE__`发送到客户端

> `Vue SSR` 的实现，主要就是把 `Vue` 的组件输出成一个完整 `HTML`, `vue-server-renderer` 就是干这事的

- `Vue SSR`需要做的事多点（输出完整 HTML），除了`complier -> vnode`，还需如数据获取填充至 `HTML`、客户端混合（`hydration`）、缓存等等。 相比于其他模板引擎（`ejs`, `jade` 等），最终要实现的目的是一样的，性能上可能要差点

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_19-vue-组件-data-为什么必须是函数)19 Vue 组件 data 为什么必须是函数

- 每个组件都是 `Vue` 的实例。
- 组件共享 `data` 属性，当 `data` 的值是同一个引用类型的值时，改变其中一个会影响其他

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_20-vue-computed-实现)20 Vue computed 实现

- 建立与其他属性（如：`data`、 `Store`）的联系；
- 属性改变后，通知计算属性重新计算

> 实现时，主要如下

- 初始化 `data`， 使用 `Object.defineProperty` 把这些属性全部转为 `getter/setter`。
- 初始化 `computed`, 遍历 `computed` 里的每个属性，每个 `computed` 属性都是一个 `watch` 实例。每个属性提供的函数作为属性的 `getter`，使用 `Object.defineProperty` 转化。
- `Object.defineProperty getter` 依赖收集。用于依赖发生变化时，触发属性重新计算。
- 若出现当前 `computed` 计算属性嵌套其他 `computed` 计算属性时，先进行其他的依赖收集

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_21-vue-complier-实现)21 Vue complier 实现

- 模板解析这种事，本质是将数据转化为一段 `html` ，最开始出现在后端，经过各种处理吐给前端。随着各种 `mv*` 的兴起，模板解析交由前端处理。
- 总的来说，`Vue complier` 是将 `template` 转化成一个 `render` 字符串。

> 可以简单理解成以下步骤：

- `parse` 过程，将 `template` 利用正则转化成`AST` 抽象语法树。
- `optimize` 过程，标记静态节点，后 `diff` 过程跳过静态节点，提升性能。
- `generate` 过程，生成 `render` 字符串

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_22-怎么快速定位哪个组件出现性能问题)22 怎么快速定位哪个组件出现性能问题

> 用 `timeline` 工具。 大意是通过 `timeline` 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_23-开发中常用的指令有哪些)23 开发中常用的指令有哪些

- `v-model` :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定
- `v-html`: 更新元素的 `innerHTML`
- `v-show` 与 `v-if`: 条件渲染, 注意二者区别

> 使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。 v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏

- `v-on` : `click`: 可以简写为`@click`,`@`绑定一个事件。如果事件触发了，就可以指定事件的处理函数
- `v-for`:基于源数据多次渲染元素或模板块
- `v-bind`: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 `DOM`

> 语法：`v-bind:title="msg"`简写：`:title="msg"`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_24-proxy-相比于-defineproperty-的优势)24 Proxy 相比于 defineProperty 的优势

> Object.defineProperty() 的问题主要有三个：

- 不能监听数组的变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套的对象

> Proxy 在 ES2015 规范中被正式加入，它有以下几个特点

- 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题
- 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。

> 除了上述两点之外，Proxy 还拥有以下优势：

- Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富
- Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_25-vue-router-有哪几种导航守卫)25 vue-router 有哪几种导航守卫?

- 全局守卫
- 路由独享守卫
- 路由组件内的守卫

**全局守卫**

> vue-router全局有三个守卫

- `router.beforeEach` 全局前置守卫 进入路由之前
- `router.beforeResolve` 全局解析守卫(2.5.0+) 在`beforeRouteEnter`调用之后调用
- `router.afterEach` 全局后置钩子 进入路由之后

```js
// main.js 入口文件
import router from './router'; // 引入路由
router.beforeEach((to, from, next) => { 
  next();
});
router.beforeResolve((to, from, next) => {
  next();
});
router.afterEach((to, from) => {
  console.log('afterEach 全局后置钩子');
});
```

**路由独享守卫**

> 如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫

```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => { 
        // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖
        // ...
      }
    }
  ]
})
```

**路由组件内的守卫**

- beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建
- beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this
- beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_26-组件之间的传值通信)26 组件之间的传值通信

> 组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯

**1. 父组件给子组件传值**

- 使用`props`，父组件可以使用`props`向子组件传递数据。
- 父组件`vue`模板`father.vue`:

```html
<template>
    <child :msg="message"></child>
</template>

<script>
import child from './child.vue';
export default {
    components: {
        child
    },
    data () {
        return {
            message: 'father message';
        }
    }
}
</script>
```

> 子组件vue模板child.vue:

```html
<template>
    <div>{{msg}}</div>
</template>

<script>
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    }
}
</script>
```

**2. 子组件向父组件通信**

> 父组件向子组件传递事件方法，子组件通过`$emit`触发事件，回调给父组件

父组件vue模板father.vue:

```html
<template>
    <child @msgFunc="func"></child>
</template>

<script>
import child from './child.vue';
export default {
    components: {
        child
    },
    methods: {
        func (msg) {
            console.log(msg);
        }
    }
}
</script>
```

> 子组件vue模板child.vue:

```html
<template>
    <button @click="handleClick">点我</button>
</template>

<script>
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    },
    methods () {
        handleClick () {
            //........
            this.$emit('msgFunc');
        }
    }
}
</script>
```

**3. 非父子, 兄弟组件之间通信**

> vue2中废弃了broadcast广播和分发事件的方法。父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。Bus.js可以是这样:

```js
import Vue from 'vue'
export default new Vue()
```

> 在需要通信的组件都引入Bus.js:

```html
<template>
	<button @click="toBus">子组件传给兄弟组件</button>
</template>

<script>
import Bus from '../common/js/bus.js'
export default{
	methods: {
	    toBus () {
	        Bus.$emit('on', '来自兄弟组件')
	    }
	  }
}
</script>
```

> 另一个组件也import Bus.js 在钩子函数中监听on事件

```js
import Bus from '../common/js/bus.js'
export default {
    data() {
      return {
        message: ''
      }
    },
    mounted() {
       Bus.$on('on', (msg) => {
         this.message = msg
       })
     }
   }
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_27-vue与angular以及react的区别)27 Vue与Angular以及React的区别？

**Vue与AngularJS的区别**

- Angular采用TypeScript开发, 而Vue可以使用javascript也可以使用TypeScript
- AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。
- AngularJS社区完善, Vue的学习成本较小

**Vue与React的区别**

- vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；
- props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；
- 子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；
- 每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；
- 使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板；
- 多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法；
- Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现；
- react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。
- react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。
- react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_28-vuex是什么-怎么使用-哪种功能场景使用它)28 vuex是什么？怎么使用？哪种功能场景使用它？

- vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data
- state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新
- 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性

> vuex的使用借助官方提供的一张图来说明:

![img](http://poetries1.gitee.io/img-repo/2020/07/65.png)

> Vuex有5种属性: 分别是 state、getter、mutation、action、module;

**state**

> `Vuex` 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据

**mutations**

> `mutations`定义的方法动态修改Vuex 的 store 中的状态或数据。

**getters**

> 类似vue的计算属性，主要用来过滤一些数据

**action**

- actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。
- vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。
- 使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题
- vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 1、组件之间全局共享的数据 2、通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态

> 一般面试官问到这里vue基本知识就差不多了， 如果更深入的研究就是和你探讨关于vue的底层源码；或者是具体在项目中遇到的问题，下面列举几个项目中可能遇到的问题：

- 开发时，改变数组或者对象的数据，但是页面没有更新如何解决？
- vue弹窗后如何禁止滚动条滚动？
- 如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_28-watch与computed的区别)28 watch与computed的区别

**computed:**

- computed是计算属性,也就是计算值,它更多用于计算值的场景
- computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算 computed适用于计算比较消耗性能的计算场景

**watch:**

- 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作
- 无缓存性，页面重新渲染时值不变化也会执行

**小结:**

- 当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed
- 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_29、vue是如何实现双向绑定的)29、Vue是如何实现双向绑定的?

> 利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。

```js
// 这是将要被劫持的对象
const data = {
  name: '',
};

function say(name) {
  if (name === '古天乐') {
    console.log('给大家推荐一款超好玩的游戏');
  } else if (name === '渣渣辉') {
    console.log('戏我演过很多,可游戏我只玩贪玩懒月');
  } else {
    console.log('来做我的兄弟');
  }
}

// 遍历对象,对其属性值进行劫持
Object.keys(data).forEach(function(key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      console.log('get');
    },
    set: function(newVal) {
      // 当属性值发生变化时我们可以进行额外操作
      console.log(`大家好,我系${newVal}`);
      say(newVal);
    },
  });
});

data.name = '渣渣辉';
//大家好,我系渣渣辉
//戏我演过很多,可游戏我只玩贪玩懒月
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_29-vue2-x-响应式原理)29 Vue2.x 响应式原理

> Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

![img](http://poetries1.gitee.io/img-repo/20190922/vue.jpeg)

- `Observer` 遍历数据对象，给所有属性加上 `setter` 和 `getter`，监听数据的变化
- `compile` 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

> `Watcher` 订阅者是 `Observer` 和 `Compile` 之间通信的桥梁，主要做的事情

- 在自身实例化时往属性订阅器 (`dep`) 里面添加自己
- 待属性变动 `dep.notice()` 通知时，调用自身的 `update()` 方法，并触发 `Compile` 中绑定的回调

**Vue3.x响应式数据原理**

> `Vue3.x`改用`Proxy`替代`Object.defineProperty`。因为`Proxy`可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

`Proxy`只会代理对象的第一层，那么`Vue3`又是怎样处理这个问题的呢？

> 判断当前`Reflect.get的`返回值是否为`Object`，如果是则再通过`reactive`方法做代理， 这样就实现了深度观测。

**监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？**

> 我们可以判断`key`是否为当前被代理对象`target`自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行`trigger`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_30-v-model双向绑定原理)30 v-model双向绑定原理

> `v-model`本质上是语法糖，`v-model`在内部为不同的输入元素使用不同的属性并抛出不同的事件

- `text` 和 `textarea` 元素使用 value 属性和 input 事件
- `checkbox` 和 `radio` 使用 checked 属性和 change 事件
- `select` 字段将 value 作为 prop 并将 change 作为事件

**所以我们可以v-model进行如下改写：**

```html
<input v-model="sth" />
//  等同于
<input :value="sth" @input="sth = $event.target.value" />
```

- 这个语法糖必须是固定的，也就是说属性必须为`value`，方法名必须为：`input`。
- 知道了`v-model`的原理，我们可以在自定义组件上实现`v-model`

```text
//Parent
<template>
    {{num}}
    <Child v-model="num">
</template>
export default {
    data(){
        return {
            num: 0
        }
    }
}

//Child
<template>
    <div @click="add">Add</div>
</template>
export default {
    props: ['value'],
    methods:{
        add(){
            this.$emit('input', this.value + 1)
        }
    }
}
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_31-scoped样式穿透)31 scoped样式穿透

> `scoped`虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除`scoped`属性

1. 使用`/deep/`

```text
//Parent
<template>
<div class="wrap">
    <Child />
</div>
</template>

<style lang="scss" scoped>
.wrap /deep/ .box{
    background: red;
}
</style>

//Child
<template>
    <div class="box"></div>
</template>
```

1. 使用两个style标签

```text
//Parent
<template>
<div class="wrap">
    <Child />
</div>
</template>

<style lang="scss" scoped>
//其他样式
</style>
<style lang="scss">
.wrap .box{
    background: red;
}
</style>

//Child
<template>
    <div class="box"></div>
</template>
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_32-ref的作用)32 ref的作用

- 获取`dom`元素`this.$refs.box`
- 获取子组件中的`datathis.$refs.box.msg`
- 调用子组件中的方法`this.$refs.box.open()`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_33-computed和watch区别)33 computed和watch区别

1. 当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed

> `Computed`本质是一个具备缓存的`watcher`，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理

![img](http://poetries1.gitee.io/img-repo/2020/01/25.png)

```js
<template>{{fullName}}</template>
export default {
    data(){
        return {
            firstName: 'xie',
            lastName: 'yu fei',
        }
    },
    computed:{
        fullName: function(){
            return this.firstName + ' ' + this.lastName
        }
    }
}
```

1. `watch`用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么`watch`为最佳选择

> `Watch`没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开`deep：true`选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用`unWatch`手动注销

![img](http://poetries1.gitee.io/img-repo/2020/01/26.png)

```text
<template>{{fullName}}</template>
export default {
    data(){
        return {
            firstName: 'xie',
            lastName: 'xiao fei',
            fullName: 'xie xiao fei'
        }
    },
    watch:{
        firstName(val) {
            this.fullName = val + ' ' + this.lastName
        },
        lastName(val) {
            this.fullName = this.firstName + ' ' + val
        }
    }
}
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_34-vue-router守卫)34 vue-router守卫

> 导航守卫 `router.beforeEach` 全局前置守卫

- `to: Route`: 即将要进入的目标（路由对象）
- `from: Route`: 当前导航正要离开的路由
- `next: Function`: 一定要调用该方法来 `resolve` 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）
- 执行效果依赖 next 方法的调用参数。
- `next()`: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
- `next(false)`:取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)

```js
// main.js 入口文件
import router from './router'; // 引入路由
router.beforeEach((to, from, next) => { 
  next();
});
router.beforeResolve((to, from, next) => {
  next();
});
router.afterEach((to, from) => {
  console.log('afterEach 全局后置钩子');
});
```

> 路由独享的守卫 你可以在路由配置上直接定义 `beforeEnter` 守卫

```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

> 组件内的守卫你可以在路由组件内直接定义以下路由导航守卫

```js
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开
    // 可以访问组件实例 `this`
    // 比如还未保存草稿，或者在用户离开前，
    将setInterval销毁，防止离开之后，定时器还在调用。
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_35-vue修饰符)35 vue修饰符

- `stop`：阻止事件的冒泡
- `prevent`：阻止事件的默认行为
- `once`：只触发一次
- `self`：只触发自己的事件行为时，才会执行

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_36-vue项目中的性能优化)36 vue项目中的性能优化

- 不要在模板里面写过多表达式
- 循环调用子组件时添加key
- 频繁切换的使用v-show，不频繁切换的使用v-if
- 尽量少用float，可以用flex
- 按需加载，可以用require或者import()按需加载需要的组件
- 路由懒加载

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_37-vue-extend和vue-component)37 vue.extend和vue.component

- `extend`是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。
- `Vue.component`你可以创建 ，也可以取组件。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_38-vue的spa-如何优化加载速度)38 Vue的SPA 如何优化加载速度

- 减少入口文件体积
- 静态资源本地缓存
- 开启Gzip压缩
- 使用SSR,nuxt.js

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_39-移动端如何设计一个比较友好的header组件)39 移动端如何设计一个比较友好的Header组件？

> 当时的思路是头部(Header)一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过vue props的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过vue slot插槽的方式对外暴露以实现多样化，同时也可以提供default slot默认插槽来统一页面风格

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_40-proxy与object-defineproperty的优劣对比)40 Proxy与Object.defineProperty的优劣对比?

**Proxy的优势如下:**

- Proxy可以直接监听对象而非属性
- Proxy可以直接监听数组的变化
- Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的
- Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改
- Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

**Object.defineProperty的优势如下:**

兼容性好,支持IE9

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_41-你是如何理解vue的响应式系统的)41 你是如何理解Vue的响应式系统的?

![img](http://poetries1.gitee.io/img-repo/2020/07/66.png)

**响应式系统简述:**

- 任何一个 Vue Component 都有一个与之对应的 Watcher 实例。
- Vue 的 data 上的属性会被添加 getter 和 setter 属性。
- 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)
- data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_42-既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异)42 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?

> 现代前端框架有两种方式侦测变化,一种是pull一种是push

- pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。
- push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_43-vue为什么没有类似于react中shouldcomponentupdate的生命周期)43 Vue为什么没有类似于React中shouldComponentUpdate的生命周期？

考点: Vue的变化侦测原理

前置知识: 依赖收集、虚拟DOM、响应式系统

> 根本原因是Vue与React的变化侦测方式有所不同

- React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.
- Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_44-vue中的key到底有什么用)44 Vue中的key到底有什么用？

- key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速
- diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.

> diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.

> 准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度`O(n)`,`Map`的时间复杂度仅仅为`O(1)`.

![img](http://poetries1.gitee.io/img-repo/2020/07/67.png)

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_45-vue-项目性能优化)45 vue 项目性能优化

**代码层面：**

- 合理使用 `v-if` 和 `v-show`
- 区分 `computed` 和 `watch` 的使用
- `v-for` 遍历为 `item` 添加 `key`
- `v-for` 遍历避免同时使用 `v-if`
- 通过 `addEventListener`添加的事件在组件销毁时要用 `removeEventListener` 手动移除这些事件的监听
- 图片懒加载
- 路由懒加载
- 第三方插件按需引入
- `SSR`服务端渲染，首屏加载速度快，`SEO`效果好

**Webpack 层面优化：**

- 对图片进行压缩
- 使用 `CommonsChunkPlugin` 插件提取公共代码
- 提取组件的 CSS
- 优化 `SourceMap`
- 构建结果输出分析，利用 `webpack-bundle-analyzer` 可视化分析工具

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_46-nexttick)46 nextTick

> ```
> nextTick` 可以让我们在下次 `DOM` 更新循环结束之后执行延迟回调，用于获得更新后的 `DOM
> ```

`nextTick`主要使用了宏任务和微任务。根据执行环境分别尝试采用

- `Promise`
- `MutationObserver`
- `setImmediate`
- 如果以上都不行则采用`setTimeout`

> 定义了一个异步方法，多次调用`nextTick`会将方法存入队列中，通过这个异步方法清空当前队列

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_47-说一下vue2-x中如何监测数组变化)47 说一下vue2.x中如何监测数组变化

> 使用了函数劫持的方式，重写了数组的方法，`Vue`将`data`中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_48-你的接口请求一般放在哪个生命周期中)48 你的接口请求一般放在哪个生命周期中

> 接口请求一般放在`mounted`中，但需要注意的是服务端渲染时不支持`mounted`，需要放到`created`中

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_49-组件中的data为什么是一个函数)49 组件中的data为什么是一个函数

> 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果`data`是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间d`ata`不冲突，data必须是一个函数

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_50-说一下v-model的原理)50 说一下v-model的原理

> `v-model`本质就是一个语法糖，可以看成是`value + input`方法的语法糖。 可以通过`model`属性的`prop`和`event`属性来进行自定义。原生的`v-model`，会根据标签的不同生成不同的事件和属性

```html
<input v-model='searchData'>
```

等价于

```html
<input 
	v-bind:value = 'searchData'
	v-on:input = 'searchData = $event.target.value'
>
```

当在input元素中使用`v-model`实现双数据绑定，其实就是在输入的时候触发元素的input事件，通过这个语法糖，实现了数据的双向绑定。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_51-vue事件绑定原理说一下)51 Vue事件绑定原理说一下

> 原生事件绑定是通过`addEventListener`绑定给真实元素的，组件事件绑定是通过`Vue`自定义的`$on`实现的

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_52-vue模版编译原理知道吗-能简单说一下吗)52 Vue模版编译原理知道吗，能简单说一下吗？

> 简单说，`Vue`的编译过程就是将`template`转化为`render`函数的过程。会经历以下阶段：

- 生成`AST`树
- 优化
- `codegen`
- 首先解析模版，生成`AST`语法树(一种用J`avaScript`对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。
- `Vue`的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。
- 编译的最后一步是将优化后的`AST`树转换为可执行的代码

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_53-vue2-x和vue3-x渲染器的diff算法分别说一下)53 Vue2.x和Vue3.x渲染器的diff算法分别说一下

> 简单来说，`diff`算法有以下过程

- 同级比较，再比较子节点
- 先判断一方有子节点一方没有子节点的情况(如果新的`children`没有子节点，将旧的子节点移除)
- 比较都有子节点的情况(核心`diff`)
- 递归比较子节点
- 正常`Diff`两个树的时间复杂度是`O(n^3)`，但实际情况下我们很少会进行跨层级的移动`DOM`，所以`Vue`将`Diff`进行了优化，从`O(n^3) -> O(n)`，只有当新旧`children`都为多个子节点时才需要用核心的`Diff`算法进行同层级比较。
- `Vue2`的核心`Diff`算法采用了双端比较的算法，同时从新旧`children`的两端开始进行比较，借助`key`值找到可复用的节点，再进行相关操作。相比`React`的`Diff`算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅
- 在创建`VNode`时就确定其类型，以及在`mount/patch`的过程中采用位运算来判断一个`VNode`的类型，在这个基础之上再配合核心的`Diff`算法，使得性能上较`Vue2.x`有了提升

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_54-再说一下虚拟dom以及key属性的作用)54 再说一下虚拟Dom以及key属性的作用

- 由于在浏览器中操作`DOM`是很昂贵的。频繁的操作`DOM`，会产生一定的性能问题。这就是虚拟Dom的产生原因
- `Virtual DOM`本质就是用一个原生的JS对象去描述一个`DOM`节点。是对真实DOM的一层抽象
- `VirtualDOM`映射到真实DOM要经历`VNode`的`create`、`diff`、`patch`等阶段

**key的作用是尽可能的复用 DOM 元素**

- 新旧 `children` 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的
- 需要在新旧 `children` 的节点中保存映射关系，以便能够在旧 `children` 的节点中找到可复用的节点。`key`也就是`children`中节点的唯一标识

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_55-vue中组件生命周期调用顺序说一下)55 Vue中组件生命周期调用顺序说一下

- 渲染顺序：先父后子，完成顺序：先子后父
- 更新顺序：父更新导致子更新，子更新完成后父
- 销毁顺序：先父后子，完成顺序：先子后父

**加载渲染过程**

> ```
> 父beforeCreate`->`父created`->`父beforeMount`->`子beforeCreate`->`子created`->`子beforeMount`- >`子mounted`->`父mounted
> ```

**子组件更新过程**

> ```
> 父beforeUpdate`->`子beforeUpdate`->`子updated`->`父updated
> ```

**父组件更新过程**

> ```
> 父 beforeUpdate` -> `父 updated
> ```

**销毁过程**

> ```
> 父beforeDestroy`->`子beforeDestroy`->`子destroyed`->`父destroyed
> ```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_56-ssr了解吗)56 SSR了解吗

> `SSR`也就是服务端渲染，也就是将`Vue`在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端

`SSR`有着更好的`SEO`、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持`beforeCreate`和`created`两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于`Node.js`的运行环境。还有就是服务器会有更大的负载需求

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_57-你都做过哪些vue的性能优化)57 你都做过哪些Vue的性能优化

**编码阶段**

- 尽量减少`data`中的数据，`data`中的数据都会增加`getter`和`setter`，会收集对应的`watcher`
- `v-if`和`v-for`不能连用
- 如果需要使用`v-for`给每项元素绑定事件时使用事件代理
- `SPA` 页面采用`keep-alive`缓存组件
- 在更多的情况下，使用`v-if`替代`v-show`
- `key`保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

**SEO优化**

- 预渲染
- 服务端渲染`SSR`

**打包优化**

- 压缩代码
- `Tree Shaking/Scope Hoisting`
- 使用`cdn`加载第三方模块
- 多线程打包`happypack`
- `splitChunks`抽离公共文件
- `sourceMap`优化

**用户体验**

- 骨架屏
- `PWA`

> 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启`gzip`压缩等。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_58-vue-js特点)58 Vue.js特点

- 简洁：页面由`HTML`模板+Json数据+`Vue`实例组成
- 数据驱动：自动计算属性和追踪依赖的模板表达式
- 组件化：用可复用、解耦的组件来构造页面
- 轻量：代码量小，不依赖其他库
- 快速：精确有效批量DOM更新
- 模板友好：可通过npm，bower等多种方式安装，很容易融入

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_59-请说出vue-cli项目中src目录每个文件夹和文件的用法)59 请说出vue.cli项目中src目录每个文件夹和文件的用法

- `assets`文件夹是放静态资源；
- `components`是放组件；
- `router`是定义路由相关的配置;
- `view`视图；
- `app.vue`是一个应用主组件；
- `main.js`是入口文件

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_60-vue路由传参数)60 vue路由传参数

- 使用`query`方法传入的参数使用`this.$route.query`接受
- 使用`params`方式传入的参数使用`this.$route.params`接受

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_61-vuex-是什么-有哪几种属性)61 vuex 是什么？ 有哪几种属性？

> - `Vuex` 是一个专为 `Vue.js` 应用程序开发的状态管理模式。
> - 有 5 种，分别是 `state`、`getter`、`mutation`、`action`、`module`

- `Vuex` 是一个专为 `Vue.js` 应用程序开发的状态管理模式。
- 有 5 种，分别是 `state`、`getter`、`mutation`、`action`、`module`
- `vuex` 的 `store` 是什么？
- `vuex` 就是一个仓库，仓库里放了很多对象。其中 `state` 就是数据源存放地，对应于一般 vue 对象里面的 `datastate` 里面存放的数据是响应式的，`vue` 组件从 `store` 读取数据，若是 `store` 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 `mapState` 把全局的 `state` 和 `getters` 映射到当前组件的 `computed` 计算属性

**vuex 的 getter 是什么？**

- `getter` 可以对 `state` 进行计算操作，它就是 `store` 的计算属性虽然在组件内也可以做计算属性，但是 `getters` 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 `getters`

**vuex 的 mutation 是什么？**

- 更改`Vuex`的`store`中的状态的唯一方法是提交`mutation`

**vuex 的 action 是什么？**

- `action` 类似于 `muation`, 不同在于：`action` 提交的是 `mutation`,而不是直接变更状态`action` 可以包含任意异步操作
- `vue` 中 `ajax` 请求代码应该写在组件的 `methods` 中还是 `vuex` 的 `action` 中
- `vuex` 的 `module` 是什么？

> 面对复杂的应用程序，当管理的状态比较多时；我们需要将`vuex`的`store`对象分割成模块(`modules`)。

> 如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 `vuex` 的 `state` 里如果被其他地方复用，请将请求放入 `action` 里，方便复用，并包装成 `promise` 返回

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_62-如何让css只在当前组件中起作用)62 如何让CSS只在当前组件中起作用？

> 将当前组件的`<style>`修改为`<style scoped>`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_63-delete和vue-delete删除数组的区别)63 delete和Vue.delete删除数组的区别？

- `delete`只是被删除的元素变成了 `empty/undefined` 其他的元素的键值还是不变。
- `Vue.delete`直接删除了数组 改变了数组的键值。

```js
var a=[1,2,3,4]
var b=[1,2,3,4]
delete a[0]
console.log(a)  //[empty,2,3,4]
this.$delete(b,0)
console.log(b)  //[2,3,4]
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_64-v-on可以监听多个方法吗)64 v-on可以监听多个方法吗？

可以

```html
<input type="text" :value="name" @input="onInput" @focus="onFocus" @blur="onBlur" />
```

**v-on 常用修饰符**

- `.stop` 该修饰符将阻止事件向上冒泡。同理于调用 `event.stopPropagation()` 方法
- `.prevent` 该修饰符会阻止当前事件的默认行为。同理于调用 `event.preventDefault()` 方法
- `.self` 该指令只当事件是从事件绑定的元素本身触发时才触发回调
- `.once` 该修饰符表示绑定的事件只会被触发一次

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_65-vue子组件调用父组件的方法)65 Vue子组件调用父组件的方法

- 第一种方法是直接在子组件中通过`this.$parent.event`来调用父组件的方法
- 第二种方法是在子组件里用`$emit`向父组件触发一个事件，父组件监听这个事件就行了。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_66-vue如何兼容ie的问题)66 vue如何兼容ie的问题

> babel-polyfill插件

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_67-vue-改变数组触发视图更新)67 Vue 改变数组触发视图更新

> 以下方法调用会改变原始数组：`push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `sort()`, `reverse()`,`Vue.set( target, key, value )`

- 调用方法：

  ```
  Vue.set( target, key, value )
  ```

  - `target`：要更改的数据源(可以是对象或者数组)
  - `key`：要更改的具体数据
  - `value` ：重新赋的值

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_68-dom-渲染在哪个周期中就已经完成)68 DOM 渲染在哪个周期中就已经完成？

> 在`mounted`

注意 `mounted` 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 `vm.$nextTick` 替换掉 `mounted`

```js
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_69-简述每个周期具体适合哪些场景)69 简述每个周期具体适合哪些场景

- `beforecreate` : 可以在这加个`loading`事件，在加载实例时触发
- `created` : 初始化完成时的事件写在这里，如在这结束`loading`事件，异步请求也适宜在这里调用
- `mounted` : 挂载元素，获取到DOM节点 `updated` : 如果对数据统一处理，在这里写上相应函数
- `beforeDestroy` : 可以做一个确认停止事件的确认框

**第一次加载会触发哪几个钩子**

> 会触发`beforeCreate` , `created` ,`beforeMount` ,`mounted`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_70-动态绑定class)70 动态绑定class

> `active` `classname`， `isActive` 变量

```html
<div :class="{ active: isActive }"></div>
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_71-vue3-0-是如何变得更快的)71 Vue3.0 是如何变得更快的

### [#](http://interview.poetries.top/excellent-docs/7-Vue.html#diff-方法优化)diff 方法优化

- `Vue2.x` 中的虚拟 dom 是进行全量的对比。
- `Vue3.0` 中新增了静态标记(PatchFlag):在与上次虚拟结点进行对比的时候，值对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化

### [#](http://interview.poetries.top/excellent-docs/7-Vue.html#hoiststatic-静态提升)hoistStatic 静态提升

- `Vue2.x` : 无论元素是否参与更新，每次都会重新创建。
- `Vue3.0` : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用

### [#](http://interview.poetries.top/excellent-docs/7-Vue.html#cachehandlers-事件侦听器缓存)cacheHandlers 事件侦听器缓存

默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一 个函数，所以没有追踪变化，直接缓存起来复用即可

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_72-说说你对-proxy-的理解)72 说说你对 proxy 的理解

vue 的数据劫持有两个缺点

- 无法监听通过索引修改数组的值的变化
- 无法监听 object 也就是对象的值的变化
- 所以 vue2.x 中才会有`$set` 属性的存在
- proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 `object.defineproperty`。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_73-生命周期详解)73 生命周期详解

***init\***

- `initLifecycle/Event`，往vm上挂载各种属性

- `callHook: beforeCreated`: 实例刚创建

- `initInjection/initState`: 初始化注入和 `data` 响应性

- `created: 创建完成，属性已经绑定， 但还未生成真实`dom`

- 进行元素的挂载： `$el / vm.$mount()`

- 是否有

  ```
  template
  ```

  : 解析成

   

  ```
  render function
  ```

  - `*.vue`文件: `vue-loader`会将`<template>`编译成`render function`

- `beforeMount`: 模板编译/挂载之前

- 执行`render function`，生成真实的`dom`，并替换到`dom tree`中

- `mounted`: 组件已挂载

**update**

- 执行`diff`算法，比对改变是否需要触发`UI`更新

- `flushScheduleQueue`

- `watcher.before`: 触发`beforeUpdate`钩子 - `watcher.run()`: 执行`watcher`中的 `notify`，通知所有依赖项更新UI

- 触发`updated`钩子: 组件已更新

- `actived / deactivated(keep-alive)`: 不销毁，缓存，组件激活与失活

- ```
  destroy
  ```

  - `beforeDestroy`: 销毁开始
  - 销毁自身且递归销毁子组件以及事件监听
    - `remove()`: 删除节点
    - `watcher.teardown()`: 清空依赖
    - `vm.$off()`: 解绑监听
  - `destroyed`: 完成后触发钩子

> 上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化

```js
new Vue({})

// 初始化Vue实例
function _init() {
	 // 挂载属性
    initLifeCycle(vm) 
    // 初始化事件系统，钩子函数等
    initEvent(vm) 
    // 编译slot、vnode
    initRender(vm) 
    // 触发钩子
    callHook(vm, 'beforeCreate')
    // 添加inject功能
    initInjection(vm)
    // 完成数据响应性 props/data/watch/computed/methods
    initState(vm)
    // 添加 provide 功能
    initProvide(vm)
    // 触发钩子
    callHook(vm, 'created')
		
	 // 挂载节点
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}

// 挂载节点实现
function mountComponent(vm) {
	 // 获取 render function
    if (!this.options.render) {
        // template to render
        // Vue.compile = compileToFunctions
        let { render } = compileToFunctions() 
        this.options.render = render
    }
    // 触发钩子
    callHook('beforeMounte')
    // 初始化观察者
    // render 渲染 vdom， 
    vdom = vm.render()
    // update: 根据 diff 出的 patchs 挂载成真实的 dom 
    vm._update(vdom)
    // 触发钩子  
    callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
	nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
	 // 遍历队列中所有修改
    for(){
	    // beforeUpdate
        watcher.before()
         
        // 依赖局部更新节点
        watcher.update() 
        callHook('updated')
    }
}

// 销毁实例实现
Vue.prototype.$destory = function() {
	 // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove() 
    // 删除依赖
    watcher.teardown() 
    // 删除监听
    vm.$off() 
    // 触发钩子
    callHook(vm, 'destoryed')
}
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_74-proxy-相比于-defineproperty-的优势)74 Proxy 相比于 defineProperty 的优势

- 数组变化也能监听到
- 不需要深度遍历监听

```js
let data = { a: 1 }
let reactiveData = new Proxy(data, {
	get: function(target, name){
		// ...
	},
	// ...
})
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_75-vue-router)75 vue-router

**mode**

- `hash`
- `history`

**跳转**

- `this.$router.push()`
- `<router-link to=""></router-link>`

**占位**

```text
<router-view></router-view>
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_76-vuex总结)76 vuex总结

- `state`: 状态中心
- `mutations`: 更改状态
- `actions`: 异步更改状态
- `getters`: 获取状态
- `modules`: 将`state`分成多个`modules`，便于管理

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_77-diff-算法)77 diff 算法

**时间复杂度：** 个树的完全`diff` 算法是一个时间复杂度为`O(n*3）` ，vue进行优化转化成`O(n)` 。

**理解：**

- 最小量更新，

  ```
  key
  ```

   

  很重要。这个可以是这个节点的唯一标识，告诉

  ```
  diff
  ```

   

  算法，在更改前后它们是同一个DOM节点

  - 扩展`v-for` 为什么要有`key` ，没有`key` 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改DOM），加`key` 只会移动减少操作DOM。

- 只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。

- 只进行同层比较，不会进行跨层比较。

**diff算法的优化策略**：四种命中查找，四个指针

1. 旧前与新前（先比开头，后插入和删除节点的这种情况）
2. 旧后与新后（比结尾，前插入或删除的情况）
3. 旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）
4. 旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_78-vue-的响应式原理中-object-defineproperty-有什么缺陷)78 Vue 的响应式原理中 Object.defineProperty 有什么缺陷

- `Object.defineProperty` 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
- `Object.defineProperty` 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象
- `Proxy` 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_79-composition-api)79 Composition API

- `Composition API`出现就是为了解决Options API导致相同功能代码分散的现象

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78168afbb094679a7ff6209aa7b734c~tplv-k3u1fbpfcp-watermark.image)

**compositon api提供了以下几个函数：**

- `setup`
- `ref`
- `reactive`
- `watchEffect`
- `watch`
- `computed`
- `toRefs`
- 生命周期的`hooks`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_80-vue中是如何检测数组变化的呢)80 vue中是如何检测数组变化的呢

> 数组就是使用 `object.defineProperty` 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， `pop` 、 `push` 、 `shift` 、 `unshift` 、 `splice` 、 `sort` 、 `reverse` 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解

- 是用函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新
- 数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）

> `vue3`：改用 `proxy` ，可直接监听对象数组的变化

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_81-vue的事件绑定原理)81 Vue的事件绑定原理

- 原生 DOM 的绑定：Vue在创建真实DOM时会调用 `createElm` ，默认会调用 `invokeCreateHooks` 。会遍历当前平台下相对的属性处理代码，其中就有 `updateDOMLListeners`方法，内部会传入 `add（）` 方法
- 组件绑定事件，原生事件，自定义事件；组件绑定之间是通过`Vue`中自定义的 `$on` 方法实现的

> 可以理解为：组件的 `nativeOnOn` 等价于 普通元素on 组件的on会单独处理

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_82-v-model中的实现原理及如何自定义v-model)82 v-model中的实现原理及如何自定义v-model

> `v-model` 可以看成是 `value+input` 方法的语法糖（组件）。原生的 `v-model` ，会根据标签的不同生成不同的事件与属性。解析一个指令来

自定义：自己写 `model` 属性，里面放上 `prop` 和 `event`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_83-为什么vue采用异步渲染呢)83 为什么Vue采用异步渲染呢

> Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 `nextTick`

`dep.notify（）` 通知 `watcher`进行更新， subs[i].update 依次调用 `watcher` 的 `update` ， `queueWatcher` 将`watcher` 去重放入队列， nextTick（ flushSchedulerQueue ）在下一`tick`中刷新`watcher`队列（异步）

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_84-vuex-工作原理)84 Vuex 工作原理

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。

状态自管理应用包含以下几个部分：

- state，驱动应用的数据源；
- view，以声明方式将 state 映射到视图；
- actions，响应在 view 上的用户输入导致的状态变化。下图单向数据流示意图：

![image-20210220193818922](http://img-repo.poetries.top/images/image-20210220193818922.png)

vuex，多组件共享状态，因-单向数据流简洁性很容易被破坏：

- 多个视图依赖于同一状态。
- 来自不同视图的行为需要变更同一状态

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17eb2230b3f46729cbfbe7144873065~tplv-k3u1fbpfcp-watermark.image?imageslim)

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_85-如何从真实dom到虚拟dom)85 如何从真实DOM到虚拟DOM

涉及到Vue中的模板编译原理，主要过程：

1. 将模板转换成`ast` 树，`ast` 用对象来描述真实的JS语法（将真实DOM转换成虚拟DOM）
2. 优化树
3. 将`ast` 树生成代码

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_86-computed-watch-和-method)86 Computed watch 和 method

- **computed**：默认`computed`也是一个`watcher`具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用`computed`
- **watch**：每次都需要执行函数。 `watch` 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。
- **method**：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_87-为什么要使用异步组件)87 为什么要使用异步组件？

1. 节省打包出的结果，异步组件分开打包，采用`jsonp`的方式进行加载，有效解决文件过大的问题。
2. 核心就是包组件定义变成一个函数，依赖`import（）` 语法，可以实现文件的分割加载。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_88-action-与-mutation-的区别)88 action 与 mutation 的区别

- `mutation` 是同步更新，`$watch` 严格模式下会报错
- `action` 是同步操作，可以获取数据后调用`mutation` 提交最终数据

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_89-插槽与作用域插槽的区别)89 插槽与作用域插槽的区别

**插槽**

- 创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类`{a:[vnode],b[vnode]}`
- 渲染组件时会拿对应的`slot` 属性的节点进行替换操作。（插槽的作用域为父组件）

**作用域插槽**

- 作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。
- 普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_90-vue中相同逻辑如何抽离)90 vue中相同逻辑如何抽离

> 其实就是考察`vue.mixin` 用法，给组件每个生命周期，函数都混入一些公共逻辑。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_91-谈谈对keep-alive的了解)91 谈谈对keep-alive的了解

> ```
> keep-alive` 可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。常用的2个属性`include/exclude` ，2个生命周期`activated` ，`deactivated
> ```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_92-vue性能优化)92 Vue性能优化

**编码优化**：

- 事件代理
- `keep-alive`
- 拆分组件
- `key` 保证唯一性
- 路由懒加载、异步组件
- 防抖节流

**Vue加载性能优化**

- 第三方模块按需导入（`babel-plugin-component` ）
- 图片懒加载

**用户体验**

- `app-skeleton` 骨架屏
- `shellap` p壳
- `pwa`

**SEO优化**

- 预渲染

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_93-vue3-0相对于vue2-x有哪些不同)93 Vue3.0相对于Vue2.x有哪些不同？

**performance**

首先在性能(performance)上有了更多的优化，一方面表现在`virtual dom`的生成上更快了，另外在底层还做了一些监听的缓存，也就是事件在被创建的时候会被推进一个缓存中，后续没有改变会直接取缓存。

**tree-shaking**

tree-shaking它表示的是在打包的时候会去除一些无用的代码。而在Vue3中对它的支持更加友好了，例如像transition、v-model、computed等功能没有用到的话，那么最后打包产生的代码就会将它们去除。也就是说，如果你的Vue项目只写了一个Hello Word的话，那么最后打包的代码中就只有一些核心的代码，如更新算法、响应式等，打包生成的文件可能就只有13.5kb。

**Fragments**

碎片(Fragments)，原本在Vue2.x中每个template下只能允许有一个根节点，但是在Vue3中它可以允许你有多个，用尤大大的话来说就是会将这些内容自动变为一个碎片。

**TS**

再者就是对TS的支持度很好。虽然Vue3本来就是用TS写的，但是不一定要用TS。另外它也支持Class Component，不过不是第一推荐。

**Component API**

语法上，对模版语法是零改变的。只不过更加推荐用Component API来写JS部分。Component API它并不是语法，而是新增的API。它带来的好处一个是逻辑重用，方便我们把一些功能的部分抽离出来。另一个它相对于options来说更加集中，用options来写代码想要追寻一个变量的变化比较麻烦。

**关于兼容性**

目前的Vue3.beta版本是不支持IE11的，因为核心的响应式原理用到了ES6的Proxy，但是以后会去兼容IE11。后面我们在创建一个Vue项目的时候，可以选择不同的版本，支持IE11和不支持IE11的。

**什么时候能使用**

现在的beta版本其实已经可以用了，对于一些新的小的项目可以试试水，这个可以自己评估。正式能够投入到生产使用中可能要等到年中 (终？)。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_94-vue中hash模式和history模式的区别)94 Vue中hash模式和history模式的区别

- 最明显的是在显示上，`hash`模式的`URL`中会夹杂着`#`号，而`history`没有。
- `Vue`底层对它们的实现方式不同。`hash`模式是依靠`onhashchange`事件(监听`location.hash`的改变)，而`history`模式是主要是依靠的`HTML5 history`中新增的两个方法，`pushState()`可以改变`url`地址且不会发送请求，`replaceState()`可以读取历史记录栈,还可以对浏览器记录进行修改。
- 当真正需要通过`URL`向后端发送`HTTP`请求的时候，比如常见的用户手动输入`URL`后回车，或者是刷新(重启)浏览器，这时候`history`模式需要后端的支持。因为`history`模式下，前端的`URL`必须和实际向后端发送请求的`URL`一致，例如有一个`URL`是带有路径`path`的(例如`www.lindaidai.wang/blogs/id`)，如果后端没有对这个路径做处理的话，就会返回`404`错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个`404`页面。

```
hash:
window.onhashchange = function(event){
  // location.hash获取到的是包括#号的，如"#heading-3"
  // 所以可以截取一下
	let hash = location.hash.slice(1);
}
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_95-了解history有哪些方法吗-说下它们的区别)95 了解history有哪些方法吗？说下它们的区别

history 这个对象在html5的时候新加入两个api **history.pushState() 和 history.repalceState()** 这两个 API可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。

从参数上来说：

```javascript
window.history.pushState(state,title,url)
//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取
//title：标题，基本没用，一般传null
//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。
//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/，
//执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/

window.history.replaceState(state,title,url)
//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录
```

另外还有：

- `window.history.back()` 后退
- `window.history.forward()`前进
- `window.history.go(1)` 前进或者后退几步

从触发事件的监听上来说：

- `pushState()`和`replaceState()`不能被`popstate`事件所监听
- 而后面三者可以，且用户点击浏览器前进后退键时也可以

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_96-如何监听-pushstate-和-replacestate-的变化呢)96 如何监听 pushState 和 replaceState 的变化呢？

利用自定义事件`new Event()`创建这两个事件，并全局监听：

```html
<body>
  <button onclick="goPage2()">去page2</button>
  <div>Page1</div>
  <script>
    let count = 0;
    function goPage2 () {
      history.pushState({ count: count++ }, `bb${count}`,'page1.html')
      console.log(history)
    }
    // 这个不能监听到 pushState
    // window.addEventListener('popstate', function (event) {
    //   console.log(event)
    // })
    function createHistoryEvent (type) {
      var fn = history[type]
      return function () {
        // 这里的 arguments 就是调用 pushState 时的三个参数集合
        var res = fn.apply(this, arguments)
        let e = new Event(type)
        e.arguments = arguments
        window.dispatchEvent(e)
        return res
      }
    }
    history.pushState = createHistoryEvent('pushState')
    history.replaceState = createHistoryEvent('replaceState')
    window.addEventListener('pushState', function (event) {
      // { type: 'pushState', arguments: [...], target: Window, ... }
      console.log(event)
    })
    window.addEventListener('replaceState', function (event) {
      console.log(event)
    })
  </script>
</body>
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_97-vue组件内的导航守卫有哪几个)97 Vue组件内的导航守卫有哪几个？

- `beforeRouteEnter`
- `beforeRouteUpdate`
- `beforeLeave`

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_98-beforerouteenter和另外两个有什么不同吗)98 beforeRouteEnter和另外两个有什么不同吗？

`beforeRouteEnter`是支持给`next`传递参数的唯一守卫，因为在这个路由守卫中还**不能访问this**，而为了能让我们访问组件实例，可以通过传一个回调给`next`：

```javascript
beforeRouteEnter(to, from, next) {
	next(vm => {
		// vm 就是组件实例
	})	
}
```

而对于另外两个，`this`已经可用，所以**不支持传递回调**：

```javascript
beforeRouteUpdate (to, from, next) {
  // just use `this`
  this.name = to.params.name
  next()
}
```

离开守卫`beforeRouteLeave`通常用来禁止用户还未保存修改之前离开，可以通过`next(false)`来取消：

```javascript
beforeRouteLeave (to, from, next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_99-完整的导航解析流程)99 完整的导航解析流程

1. 导航被触发。
2. 在失活的组件里调用离开守卫。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫 (2.2+)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫 (2.5+)。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 用创建好的实例调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数。

## [#](http://interview.poetries.top/excellent-docs/7-Vue.html#_100-你是怎么看vue和react的)100 你是怎么看Vue和React的？

首先它们都是当今比较流行的前端框架。

**相同点：**

1. `Virtual DOM`。其中最大的一个相似之处就是都使用了`Virtual DOM`。(当然`Vue`是在`Vue2.x`才引用的)也就是能让我们通过操作数据的方式来改变真实的`DOM`状态。因为其实`Virtual DOM`的本质就是一个`JS`对象，它保存了对真实`DOM`的所有描述，是真实`DOM`的一个映射，所以当我们在进行频繁更新元素的时候，改变这个`JS`对象的开销远比直接改变真实`DOM`要小得多。
2. 组件化的开发思想。第二点来说就是它们都提倡这种组件化的开发思想，也就是建议将应用分拆成一个个功能明确的模块，再将这些模块整合在一起以满足我们的业务需求。
3. `Props`。`Vue`和`React`中都有`props`的概念，允许父组件向子组件传递数据。
4. 构建工具、Chrome插件、配套框架。还有就是它们的构建工具以及Chrome插件、配套框架都很完善。比如构建工具，`React`中可以使用`CRA`，`Vue`中可以使用对应的脚手架`vue-cli`。对于配套框架`Vue`中有`vuex、vue-router`，`React`中有`react-router、redux`。

**不同点**

1. 模版的编写。最大的不同就是模版的编写，`Vue`鼓励你去写近似常规`HTML`的模板，`React`推荐你使用`JSX`去书写。
2. 状态管理与对象属性。在`React`中，应用的状态是比较关键的概念，也就是`state`对象，它允许你使用`setState`去更新状态。但是在`Vue`中，`state`对象并不是必须的，数据是由`data`属性在`Vue`对象中进行管理。
3. 虚拟`DOM`的处理方式不同。`Vue`中的虚拟`DOM`控制了颗粒度，组件层面走`watcher`通知，而组件内部走`vdom`做`diff`，这样，既不会有太多`watcher`，也不会让`vdom`的规模过大。而`React`走了类似于`CPU`调度的逻辑，把`vdom`这棵树，微观上变成了链表，然后利用浏览器的空闲时间来做`diff`。



# 8 Node模块

> 当面试官问你`node`的时候，更多引导面试官用`node`做前端工程化，去引导到`webpack`、`npm`、打包工具上面去说说自己的想法，不要引导到自己会后端，后台不是会一点`node`语法就能写的

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_1-package-json版本号规则)1 package.json版本号规则

**major.minor.patch**

- 主版本号.次版本号.修补版本号
- `patch`：修复`bug`，兼容老版本
- `minor`：新增功能，兼容老版本
- `major`：新的架构调整，不兼容老版本

**~和^的区别**

- `~`会匹配最近的小版本依赖包，比如`~1.2.3`会匹配所有`1.2.x`版本，但是不包括`1.3.0`
- `^`会匹配最新的大版本依赖包，比如`^1.2.3`会匹配所有`1.x.x`的包，包括`1.3.0`，但是不包括`2.0.0`

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_2-npm-模块安装机制)2 npm 模块安装机制

- 发出 `npm install` 命令 `1` 查询 `node_modules` 目录之中是否已经存在指定模块
- 若存在，不再重新安装
- 若不存在
- `npm` 向 `registry` 查询模块压缩包的网址
- 下载压缩包，存放在根目录下的`.npm` 目录里
- 解压压缩包到当前项目的 `node_modules` 目录

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_3-模块化的差异-amd-cmd-commonjs-esmodule)3 模块化的差异 AMD CMD COMMONJS ESMODULE

- `AMD`是依赖前置，`define`写法
- `CMD` 语法`require`
- `AMD`和`CMD`是动态引入，运行时才知道的
- `ESMODULE`是静态引入，好处方便`wepback`打包依赖图谱分析
- `CommonJs` 是单个值导出，`ES6 Module` 可以导出多个
- `CommonJs` 是动态语法可以写在判断里，`ES6 Module` 静态语法只能写在顶层
- `CommonJs` 的 `this` 是当前模块，`ES6 Module`的 `this` 是 `undefined`

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_4-node-的-event-loop-6个阶段)4 Node 的 Event Loop: 6个阶段

- `timer` 阶段: 执行到期的`setTimeout / setInterval`队列回调

- `I/O` 阶段: 执行上轮循环残流的`callback`

- `idle`, `prepare`

- ```
  poll
  ```

  : 等待回调

  - 1. 执行回调

  - 1. 执行定时器

    - 如有到期的`setTimeout / setInterval`， 则返回 `timer` 阶段
    - 如有`setImmediate`，则前往 `check` 阶段

- ```
  check
  ```

  - 执行`setImmediate`

- `close callbacks`

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_5-koa相关)5 Koa相关

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#koa洋葱模型怎么实现的)koa洋葱模型怎么实现的

![img](http://img-repo.poetries.top/images/20210517094050.png)

- 中间件执行就像洋葱一样，最早 use 的中间件，就放在最外层。处理顺序从左到右，左边接收一个 request，右边输出返回 response
- 一般的中间件都会执行两次，调用 next 之前为第一次，调用 next 时把控制传递给下游的下一个中间件。当下游不再有中间件或者没有执行 next 函数时，就将依次恢复上游中间件的行为，让上游中间件执行 next 之后的代码

例如下面这段代码

```js
const Koa = require('koa')
const app = new Koa()
app.use((ctx, next) => {
    console.log(1)
    next()
    console.log(3)
})
app.use((ctx) => {
    console.log(2)
})
app.listen(3001)
//执行结果是1=>2=>3
```

> ```
> app.use()` 把中间件函数存储在`middleware`数组中，最终会调用`koa-compose`导出的函数compose返回一个promise，中间函数的第一个参数`ctx`是包含响应和请求的一个对象，会不断传递给下一个中间件。next是一个函数，返回的是一个`promise
> ```

**koa 中间件实现源码大致思路如下：**

```js
// 注意其中的compose函数，这个函数是实现中间件洋葱模型的关键
// 场景模拟
// 异步 promise 模拟
const delay = async () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, 2000);
  });
}
// 中间间模拟
const fn1 = async (ctx, next) => {
  console.log(1);
  await next();
  console.log(2);
}
const fn2 = async (ctx, next) => {
  console.log(3);
  await delay();
  await next();
  console.log(4);
}
const fn3 = async (ctx, next) => {
  console.log(5);
}

const middlewares = [fn1, fn2, fn3];

// compose 实现洋葱模型
const compose = (middlewares, ctx) => {
  const dispatch = (i) => {
    let fn = middlewares[i];
    if(!fn){ return Promise.resolve() }
    return Promise.resolve(fn(ctx, () => {
      return dispatch(i+1);
    }));
  }
  return dispatch(0);
}

compose(middlewares, 1);
```

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#如果中间件中的next-方法报错了怎么办)如果中间件中的next()方法报错了怎么办

> 中间件链错误会由`ctx.onerror`捕获，该函数中会调用`this.app.emit('error', err, this)`（因为koa继承自events模块，所以有'emit'和on等方法），可以使用`app.on('error', (err) => {})`，或者`app.onerror = (err) => {}`进行捕获。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#co的原理是怎样的)co的原理是怎样的

> co的原理是通过不断调用generator函数的`next`方法来达到自动执行generator函数的，类似async、await函数自动执行

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_6-express、koa实现原理以及对比)6 Express、koa实现原理以及对比

> 底层建立在`node.js`内置的http模块上。http模块生成服务器的原始代码如下

```js
var http = require("http");

var app = http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.end("Hello world!");
});

app.listen(3000, "localhost");
```

- `Express`框架的核心是对http模块的再包装
- `Express`框架等于在http模块之上，加了一个中间层
- 它最大的特点就是，一个中间件处理完，再传递给下一个中间件
- 比如自带 `Router`、路由规则等
- `callback`太多

**koa2特点**

- 洋葱模型
- 没有自带路由，由koa-router管理
- 没有callback

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_7-请介绍一下-require-的模块加载机制)7 请介绍一下 require 的模块加载机制

这道题基本上就可以了解到面试者对 Node 模块机制的了解程度 基本上面试提到

- 先计算模块路径
- 如果模块在缓存里面，取出缓存
- 加载模块
- 输出模块的 `exports` 属性即可

```js
// require 其实内部调用 Module._load 方法
Module._load = function(request, parent, isMain) {
  //  计算绝对路径
  var filename = Module._resolveFilename(request, parent);

  //  第一步：如果有缓存，取出缓存
  var cachedModule = Module._cache[filename];
  if (cachedModule) {
    return cachedModule.exports;

  // 第二步：是否为内置模块
  if (NativeModule.exists(filename)) {
    return NativeModule.require(filename);
  }

  /********************************这里注意了**************************/
  // 第三步：生成模块实例，存入缓存
  // 这里的Module就是我们上面的1.1定义的Module
  var module = new Module(filename, parent);
  Module._cache[filename] = module;

  /********************************这里注意了**************************/
  // 第四步：加载模块
  // 下面的module.load实际上是Module原型上有一个方法叫Module.prototype.load
  try {
    module.load(filename);
    hadException = false;
  } finally {
    if (hadException) {
      delete Module._cache[filename];
    }
  }

  // 第五步：输出模块的exports属性
  return module.exports;
};
```

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_8-exports-xxx-xxx-和-module-exports-有什么区别)8 exports.xxx=xxx 和 Module.exports={}有什么区别

```
exports` 其实就是 `module.exports
// module.exports vs exports
// 很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：

// 方法一：对module.exports赋值：

// hello.js

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

module.exports = {
    hello: hello,
    greet: greet
};

// 方法二：直接使用exports：

// hello.js

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

function hello() {
    console.log('Hello, world!');
}

exports.hello = hello;
exports.greet = greet;

// 但是你不可以直接对exports赋值：

// 代码可以执行，但是模块并没有输出任何变量:
exports = {
    hello: hello,
    greet: greet
};

// 如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：

// 首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量：

var module = {
    id: 'hello',
    exports: {}
};

// load()函数最终返回module.exports：

var load = function (exports, module) {
    // hello.js的文件内容
    ...
    // load函数返回:
    return module.exports;
};

var exportes = load(module.exports, module);

// 也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象{}，于是，我们可以写：

exports.foo = function () { return 'foo'; };
exports.bar = function () { return 'bar'; };

// 也可以写：

module.exports.foo = function () { return 'foo'; };
module.exports.bar = function () { return 'bar'; };

// 换句话说，Node默认给你准备了一个空对象{}，这样你可以直接往里面加东西。

// 但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值：

module.exports = function () { return 'foo'; };

// 给exports赋值是无效的，因为赋值后，module.exports仍然是空对象{}。

// 结论

// 如果要输出一个键值对象{}，可以利用exports这个已存在的空对象{}，并继续在上面添加新的键值；
// 如果要输出一个函数或数组，必须直接对module.exports对象赋值。
// 所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况：

module.exports = {
    foo: function () { return 'foo'; }
};

// 或者：

module.exports = function () { return 'foo'; };

// 最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。
```

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_9-node-的异步-i-o)9 Node 的异步 I/O

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#请介绍一下-node-事件循环的流程)请介绍一下 Node 事件循环的流程

- 在进程启动时，Node 便会创建一个类似于 while(true)的循环，每执行一次循环体的过程我们成为 Tick。
- 每个 Tick 的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。

![img](http://img-repo.poetries.top/images/20210517091829.png)

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#在每个-tick-的过程中-如何判断是否有事件需要处理呢)在每个 tick 的过程中，如何判断是否有事件需要处理呢

- 每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。
- 在 Node 中，事件主要来源于网络请求、文件的 I/O 等，这些事件对应的观察者有文件 I/O 观察者，网络 I/O 的观察者。
- 事件循环是一个典型的生产者/消费者模型。异步 I/O，网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。
- 在 windows 下，这个循环基于 IOCP 创建，在*nix 下则基于多线程创建

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#描述一下整个异步-i-o-的流程)描述一下整个异步 I/O 的流程

![img](http://img-repo.poetries.top/images/20210517091909.png)

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_10-v8-的垃圾回收机制)10 V8 的垃圾回收机制

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#如何查看-v8-的内存使用情况)如何查看 V8 的内存使用情况

使用 `process.memoryUsage()`,返回如下

```text
{
  rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472,
  external: 49879
}
```

> `heapTotal` 和 `heapUsed` 代表 `V8` 的内存使用情况。`external` 代表 `V8` 管理的，绑定到 Javascript 的 C++对象的内存使用情况。rss, 驻留集大小, 是给这个进程分配了多少物理内存(占总分配内存的一部分) 这些物理内存中包含堆，栈，和代码段。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#v8-的内存限制是多少-为什么-v8-这样设计)V8 的内存限制是多少，为什么 V8 这样设计

> 64 位系统下是 `1.4GB`， 32 位系统下是 `0.7GB`。因为 `1.5GB`的垃圾回收堆内存，V8 需要花费 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。这是垃圾回收中引起 Javascript 线程暂停执行的事件，在这样的花销下，应用的性能和影响力都会直线下降。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#v8-的内存分代和回收算法请简单讲一讲)V8 的内存分代和回收算法请简单讲一讲

> 在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象存活时间较短的对象，老生代中的对象存活时间较长，或常驻内存的对象。

![img](http://img-repo.poetries.top/images/20210517092109.png)

**新生代**

> 新生代中的对象主要通过 Scavenge 算法进行垃圾回收。这是一种采用复制的方式实现的垃圾回收算法。它将堆内存一份为二，每一部分空间成为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间

![img](http://img-repo.poetries.top/images/20210517092136.png)

- 当开始垃圾回收的时候，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间发生角色对换。
- 应为新生代中对象的生命周期比较短，就比较适合这个算法。
- 当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象。这种新生代中生命周期较长的对象随后会被移到老生代中。

**老生代**

> 老生代主要采取的是标记清除的垃圾回收算法。与 Scavenge 复制活着的对象不同，标记清除算法在标记阶段遍历堆中的所有对象，并标记活着的对象，只清理死亡对象。活对象在新生代中只占叫小部分，死对象在老生代中只占较小部分，这是为什么采用标记清除算法的原因

**标记清楚算法的问题**

主要问题是每一次进行标记清除回收后，内存空间会出现不连续的状态

![img](http://img-repo.poetries.top/images/20210517092246.png)

- 这种内存碎片会对后续内存分配造成问题，很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。
- 为了解决碎片问题，标记整理被提出来。就是在对象被标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

**哪些情况会造成 V8 无法立即回收内存**

闭包和全局变量

**请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法**

1. 什么是内存泄漏

- 内存泄漏(Memory Leak)指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。
- 如果内存泄漏的位置比较关键，那么随着处理的进行可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢。
- 严重的情况下导致内存达到某个极限(可能是进程的上限，如 v8 的上限;也可能是系统可提供的内存上限)会使得应用程序崩溃。常见内存泄漏的原因 内存泄漏的几种情况:

全局变量

```js
a = 10;
//未声明对象。
global.b = 11;
//全局变量引用
// 这种比较简单的原因，全局变量直接挂在 root 对象上，不会被清除掉。
```

闭包

```js
function out() {
    const bigData = new Buffer(100);
    inner = function () {

    }
}
```

> 闭包会引用到父级函数中的变量，如果闭包未释放，就会导致内存泄漏。上面例子是 inner 直接挂在了 root 上，那么每次执行 out 函数所产生的 bigData 都不会释放，从而导致内存泄漏。需要注意的是，这里举得例子只是简单的将引用挂在全局对象上，实际的业务情况可能是挂在某个可以从 root 追溯到的对象上导致的

事件监听

> Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除(removeListener)，将造成内存泄漏。这种情况很容易在复用对象上添加事件时出现，所以事件重复监听可能收到如下警告

```text
emitter.setMaxListeners() to increase limit
```

**排查方法想要定位内存泄漏，通常会有两种情况**

- 对于只要正常使用就可以重现的内存泄漏，这是很简单的情况只要在测试环境模拟就可以排查了。
- 对于偶然的内存泄漏，一般会与特殊的输入有关系。想稳定重现这种输入是很耗时的过程。如果不能通过代码的日志定位到这个特殊的输入，那么推荐去生产环境打印内存快照了。
- 需要注意的是，打印内存快照是很耗 CPU 的操作，可能会对线上业务造成影响。快照工具推荐使用 heapdump 用来保存内存快照，使用 devtool 来查看内存快照。
- 使用 heapdump 保存内存快照时，只会有 Node.js 环境中的对象，不会受到干扰(如果使用 node-inspector 的话，快照中会有前端的变量干扰)。

> PS：安装 heapdump 在某些 Node.js 版本上可能出错，建议使用 `npm install heapdump -target=Node.js` 版本来安装。

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_11-buffer-模块)11 Buffer 模块

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#新建-buffer-会占用-v8-分配的内存吗)新建 Buffer 会占用 V8 分配的内存吗

不会，Buffer 属于堆外内存，不是 V8 分配的。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#buffer-alloc-和-buffer-allocunsafe-的区别)Buffer.alloc 和 Buffer.allocUnsafe 的区别

> `Buffer.allocUnsafe` 创建的 Buffer 实例的底层内存是未初始化的。新创建的 Buffer 的内容是未知的，可能包含敏感数据。使用 Buffer.alloc() 可以创建以零初始化的 Buffer 实例。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#buffer-的内存分配机制)Buffer 的内存分配机制

- 为了高效的使用申请来的内存，Node 采用了 slab 分配机制。slab 是一种动态的内存管理机制。Node 以 8kb 为界限来来区分 Buffer 为大对象还是小对象，如果是小于 8kb 就是小 `Buffer`，大于 8kb 就是大 Buffer。例如第一次分配一个 1024 字节的 Buffer，`Buffer.alloc(1024)`,那么这次分配就会- 用到一个 slab，接着如果继续 `Buffer.alloc(1024)`,那么上一次用的 slab 的空间还没有用完，因为总共是 8kb，`1024+1024 = 2048` 个字节，没有 8kb，所以就继续用这个 slab 给 Buffer 分配空间。如果超过 8kb，那么直接用 C++底层地宫的 `SlowBuffer` 来给 `Buffer` 对象提供空间。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#buffer-乱码问题)Buffer 乱码问题

例如一个份文件 test.md 里的内容如下：

```text
床前明月光，疑是地上霜，举头望明月，低头思故乡
```

我们这样读取就会出现乱码：

```text
var rs = require('fs').createReadStream('test.md', {highWaterMark: 11});
// 床前明???光，疑???地上霜，举头???明月，???头思故乡
```

一般情况下，只需要设置 `rs.setEncoding('utf8')` 即可解决乱码问题

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_12-websocket)12 webSocket

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#websocket-与传统的-http-有什么优势)webSocket 与传统的 http 有什么优势

- 客户端与服务器只需要一个 TCP 连接，比 `http` 长轮询使用更少的连接
- `webSocket` 服务端可以推送数据到客户端
- 更轻量的协议头，减少数据传输量

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#websocket-协议升级简述一下)webSocket 协议升级简述一下

> 首先，WebSocket 连接必须由浏览器发起，因为请求协议是一个标准的 HTTP 请求，格式如下：

```text
GET ws://localhost:3000/ws/chat HTTP/1.1
Host: localhost
Upgrade: websocket
Connection: Upgrade
Origin: http://localhost:3000
Sec-WebSocket-Key: client-random-string
Sec-WebSocket-Version: 13
```

该请求和普通的 HTTP 请求有几点不同：

- `GET` 请求的地址不是类似`/path/`，而是以 `ws://开头的地址`；
- 请求头 `Upgrade: websocket` 和 `Connection: Upgrade`表示这个连接将要被转换为 `WebSocket` 连接；
- `Sec-WebSocket-Key` 是用于标识这个连接，并非用于加密数据；
- `Sec-WebSocket-Version` 指定了 `WebSocket` 的协议版本。

随后，服务器如果接受该请求，就会返回如下响应：

```text
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: server-random-string
```

该响应代码 `101` 表示本次连接的 `HTTP` 协议即将被更改，更改后的协议就是 `Upgrade: websocket` 指定的 `WebSocket` 协议

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_13-https)13 https

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#https-用哪些端口进行通信-这些端口分别有什么用)https 用哪些端口进行通信，这些端口分别有什么用

- `443` 端口用来验证服务器端和客户端的身份，比如验证证书的合法性
- `80` 端口用来传输数据（在验证身份合法的情况下，用来数据传输）

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#身份验证过程中会涉及到密钥-对称加密-非对称加密-摘要的概念-请解释一下)身份验证过程中会涉及到密钥， 对称加密，非对称加密，摘要的概念，请解释一下

- **密钥**：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。
- **对称加密**：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有 `DES、3DES、TDEA、Blowfish、RC5` 和 `IDEA`。
- **非对称加密**：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。
- **摘要**：摘要算法又称哈希/散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用 16 进制的字符串表示）。算法不可逆。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#为什么需要-ca-机构对证书签名)为什么需要 CA 机构对证书签名

> 如果不签名会存在中间人攻击的风险，签名之后保证了证书里的信息，比如公钥、服务器信息、企业信息等不被篡改，能够验证客户端和服务器端的“合法性”。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#https-验证身份也就是-tsl-ssl-身份验证的过程)https 验证身份也就是 TSL/SSL 身份验证的过程

![img](http://img-repo.poetries.top/images/20210517093635.png)

## [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#_14-进程通信)14 进程通信

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#请简述一下-node-的多进程架构)请简述一下 node 的多进程架构

> 面对 node 单线程对多核 CPU 使用不足的情况，Node 提供了 `child_process` 模块，来实现进程的复制，node 的多进程架构是主从模式，如下所示：

![img](http://img-repo.poetries.top/images/20210517093720.png)

```js
var fork = require('child_process').fork;
var cpus = require('os').cpus();
for(var i = 0; i < cpus.length; i++){
    fork('./worker.js');
}
```

> 在 linux 中，我们通过 `ps aux | grep worker.js` 查看进程

![img](http://img-repo.poetries.top/images/20210517093745.png)

这就是著名的主从模式，`Master-Worker`

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#请问创建子进程的方法有哪些-简单说一下它们的区别)请问创建子进程的方法有哪些，简单说一下它们的区别

- `spawn()`：启动一个子进程来执行命令
- `exec()`: 启动一个子进程来执行命令，与 spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况
- `execFlie()`: 启动一个子进程来执行可执行文件
- `fork()`: 与 `spawn()`类似，不同电在于它创建 Node 子进程需要执行 js 文件
- `spawn()`与 `exec()`、`execFile()`不同的是，后两者创建时可以指定 `timeout` 属性设置超时时间，一旦创建的进程超过设定的时间就会被杀死
- `exec()`与 `execFile()`不同的是，`exec()`适合执行已有命令，`execFile()`适合执行文件。

### [#](http://interview.poetries.top/excellent-docs/8-Node模块.html#实现一个-node-子进程被杀死-然后自动重启代码的思路)实现一个 node 子进程被杀死，然后自动重启代码的思路

在创建子进程的时候就让子进程监听 `exit` 事件，如果被杀死就重新 `fork` 一下

```js
var createWorker = function(){
    var worker = fork(__dirname + 'worker.js')
    worker.on('exit', function(){
        console.log('Worker' + worker.pid + 'exited');
        // 如果退出就创建新的worker
        createWorker()
    })
}
```



# 9 前端工程相关

## 1 webpack原理简述

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_1-1-核心概念)1.1 核心概念

> JavaScript 的 模块打包工具 (module bundler)。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。

- Entry: 入口文件，Webpack会从该文件开始进行分析与编译；
- Output: 出口路径，打包后创建 bundler的文件路径以及文件名；
- Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；
- Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；
- Loader: 模块加载器，进行各种文件类型的加载与转换；
- Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_1-2-工作流程-加载-编译-输出)1.2 工作流程 (加载 - 编译 - 输出)

1. 读取配置文件，按命令 初始化 配置参数，创建 Compiler 对象；
2. 调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译；
3. 按文件类型，调用相应的 Loader 对模块进行 编译，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 依赖查找 到所依赖的模块，递归执行第三步；
4. 将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 输出内容。这个步骤，仍然可以通过 Plugin 进行文件的修改;
5. 最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程；

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_1-3-模块包装)1.3 模块包装:

```js
(function(modules) {
	// 模拟 require 函数，从内存中加载模块；
	function __webpack_require__(moduleId) {
		// 缓存模块
		if (installedModules[moduleId]) {
			return installedModules[moduleId].exports;
		}
		
		var module = installedModules[moduleId] = {
			i: moduleId,
			l: false,
			exports: {}
		};
		
		// 执行代码；
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		
		// Flag: 标记是否加载完成；
		module.l = true;
		
		return module.exports;
	}
	
	// ...
	
	// 开始执行加载入口文件；
	return __webpack_require__(__webpack_require__.s = "./src/index.js");
 })({
 	"./src/index.js": function (module, __webpack_exports__, __webpack_require__) {
		// 使用 eval 执行编译后的代码；
		// 继续递归引用模块内部依赖；
		// 实际情况并不是使用模板字符串，这里是为了代码的可读性；
		eval(`
			__webpack_require__.r(__webpack_exports__);
			//
			var _test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("test", ./src/test.js");
		`);
	},
	"./src/test.js": function (module, __webpack_exports__, __webpack_require__) {
		// ...
	},
 })
```

**总结:**

- **模块机制**: webpack自己实现了一套模拟模块的机制，将其包裹于业务代码的外部，从而提供了一套模块机制；
- **文件编译**: webpack 规定了一套编译规则，通过 Loader 和 Plugin，以管道的形式对文件字符串进行处理；

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_1-4-webpack的打包原理)1.4 webpack的打包原理

- `初始化参数`：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
- `开始编译`：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- `确定入口`：根据配置中的 entry 找出所有的入口文件
- `编译模块`：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
- `完成模块编译`：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
- `输出资源`：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- `输出完成`：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_1-5-总结)1.5 总结

1. 初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。
2. 开始编译：从上一步得到的参数初始化 `Compiler` 对象，加载所有配置的插件，执行对象的 `run` 方法开始执行编译。
3. 确定入口：根scope据配置中的 `entry` 找出所有的入口文件。
4. 编译模块：从入口文件出发，调用所有配置的 `loader` 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。
5. 完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `chunk`，再把每个 `chunk` 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_2-webpack热更新原理)2 webpack热更新原理

![img](http://img-repo.poetries.top/images/20210319101659.png)

- 当修改了一个或多个文件；
- 文件系统接收更改并通知 `webpack`；
- `webpack` 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；
- `HMR Server` 使用 `webSocket` 通知 `HMR runtime` 需要更新，`HMR` 运行时通过 `HTTP` 请求更新 `jsonp`
- `HMR` 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_3-webpack-loader)3 webpack Loader

> 由于 Webpack 是基于 Node，因此 Webpack 其实是只能识别 js 模块，比如 css / html / 图片等类型的文件并无法加载，因此就需要一个对 不同格式文件转换器。其实 Loader 做的事，也并不难理解: 对 Webpack 传入的字符串进行按需修改。例如一个最简单的 Loader:

```js
// html-loader/index.js
module.exports = function(htmlSource) {
	// 返回处理后的代码字符串
	// 删除 html 文件中的所有注释
	return htmlSource.replace(/<!--[\w\W]*?-->/g, '')
}
```

> 当然，实际的 Loader 不会这么简单，通常是需要将代码进行分析，构建 AST (抽象语法树)， 遍历进行定向的修改后，再重新生成新的代码字符串。如我们常用的 Babel-loader 会执行以下步骤:

- `babylon` 将 `ES6/ES7` 代码解析成 `AST`
- `babel-traverse` 对 `AST` 进行遍历转译，得到新的 AST
- 新 `AST` 通过 `babel-generator` 转换成 `ES5`

**Loader 特性:**

- 链式传递，按照配置时相反的顺序链式执行；
- 基于 Node 环境，拥有 较高权限，比如文件的增删查改；
- 可同步也可异步；

**常用 Loader:**

- `file-loader`: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能；
- `url-loader`: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；
- `babel-loader`: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；
- `ts-loader`: 加载 ts / tsx 文件，编译 TypeScript；
- `style-loader`: 将 css 代码以`<style>`标签的形式插入到 html 中；
- `css-loader`: 分析@import和url()，引用 css 文件与对应的资源；
- `postcss-loader`: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等；
- `less-loader / sass-loader`: css预处理器，在 css 中新增了许多语法，提高了开发效率；

**编写原则:**

- 单一原则: 每个 Loader 只做一件事；
- 链式调用: Webpack 会按顺序链式调用每个 Loader；
- 统一原则: 遵循 Webpack制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_4-webpack-plugin)4 webpack Plugin

> 插件系统是 Webpack 成功的一个关键性因素。在编译的整个生命周期中，Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。

**一个最简单的 plugin 是这样的:**

```js
class Plugin{
  	// 注册插件时，会调用 apply 方法
  	// apply 方法接收 compiler 对象
  	// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作
  	apply(compiler){
  		// compilation 是监听每次编译循环
  		// 每次文件变化，都会生成新的 compilation 对象并触发该事件
    	compiler.plugin('compilation',function(compilation) {})
  	}
}
```

**注册插件:**

```js
// webpack.config.js
module.export = {
	plugins:[
		new Plugin(options),
	]
}
```

**事件流机制:**

> Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 与 Plugin 的一道道处理，最后输出结果。

- 通过链式调用，按顺序串起一个个 Loader；
- 通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中；

> Webpack 事件流编程范式的核心是基础类 Tapable，是一种 观察者模式 的实现事件的订阅与广播：

```js
const { SyncHook } = require("tapable")

const hook = new SyncHook(['arg'])

// 订阅
hook.tap('event', (arg) => {
	// 'event-hook'
	console.log(arg)
})

// 广播
hook.call('event-hook')
```

> `Webpack` 中两个最重要的类 `Compiler` 与 `Compilation` 便是继承于 `Tapable`，也拥有这样的事件流机制。

- **Compiler**: 可以简单的理解为 Webpack 实例，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递；
- `Compilation`: 可以称为 编译实例。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可以监听每次编译过程中触发的事件钩子；
- **区别:**
  - `Compiler` 全局唯一，且从启动生存到结束；
  - `Compilation`对应每次编译，每轮编译循环均会重新创建；
- **常用 Plugin:**
  - UglifyJsPlugin: 压缩、混淆代码；
  - CommonsChunkPlugin: 代码分割；
  - ProvidePlugin: 自动加载模块；
  - html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；
  - extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量；
  - optimize-css-assets-webpack-plugin: CSS 代码去重；
  - webpack-bundle-analyzer: 代码分析；
  - compression-webpack-plugin: 使用 gzip 压缩 js 和 css；
  - happypack: 使用多进程，加速代码构建；
  - EnvironmentPlugin: 定义环境变量；
- 调用插件 `apply` 函数传入 `compiler` 对象
- 通过 `compiler` 对象监听事件

**loader和plugin有什么区别？**

> webapck默认只能打包JS和JOSN模块，要打包其它模块，需要借助loader，loader就可以让模块中的内容转化成webpack或其它laoder可以识别的内容。

- `loader`就是模块转换化，或叫加载器。不同的文件，需要不同的`loader`来处理。
- `plugin`是插件，可以参与到整个webpack打包的流程中，不同的插件，在合适的时机，可以做不同的事件。

**webpack中都有哪些插件，这些插件有什么作用？**

- `html-webpack-plugin` 自动创建一个HTML文件，并把打包好的JS插入到HTML文件中
- `clean-webpack-plugin` 在每一次打包之前，删除整个输出文件夹下所有的内容
- `mini-css-extrcat-plugin` 抽离CSS代码，放到一个单独的文件中
- `optimize-css-assets-plugin` 压缩css

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#实现一个编译结束退出命令的插件)实现一个编译结束退出命令的插件

```js
apply (compiler) {
  const afterEmit = (compilation, cb) => {
    cb()
    setTimeout(function () {
      process.exit(0)
    }, 1000)
  }

  compiler.plugin('after-emit', afterEmit)
}
}

module.exports = BuildEndPlugin
<script>
export default {
  mounted () {
    var isGithub = location.href.indexOf('FE-Interview-Questions')!==-1
    var sId = isGithub ? '59154049' : '66575297'
    var script = document.createElement("script");
    script.type = "text/javascript"
    script.charset="UTF-8"
    script.src = `http://tajs.qq.com/stats?sId=${sId}`
    document.body.appendChild(script);
  }
}
</script>
```

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_5-webpack编译优化)5 webpack编译优化

**代码优化:**

> 无用代码消除，是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 删除不可能执行的代码；

例如我们的 `UglifyJs`，它就会帮我们在生产环境中删除不可能被执行的代码，例如:

```js
var fn = function() {
	return 1;
	// 下面代码便属于 不可能执行的代码；
	// 通过 UglifyJs (Webpack4+ 已内置) 便会进行 DCE；
	var a = 1;
	return a;
}
```

> 摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 "摇" 我们打包后的 js 代码，将没有使用到的无用代码 "摇" 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。

- 原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。

- 问题: 具有 副作用 的函数无法被

   

  ```
  tree-shaking
  ```

  - 在引用一些第三方库，需要去观察其引入的代码量是不是符合预期；
  - 尽量写纯函数，减少函数的副作用；
  - 可使用 `webpack-deep-scope-plugin`，可以进行作用域分析，减少此类情况的发生，但仍需要注意；

**code-spliting: 代码分割技术**，将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载；

- `Webpack` 中使用 `SplitChunksPlugin` 进行拆分；
- 按 页面 拆分: 不同页面打包成不同的文件；
- 按 功能 拆分:
  - 将类似于播放器，计算库等大模块进行拆分后再懒加载引入；
  - 提取复用的业务代码，减少冗余代码；
- 按 文件修改频率 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存；

**scope hoisting**: 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；

**编译性能优化:**

- 升级至 最新 版本的 `webpack`，能有效提升编译性能；

- 使用

   

  ```
  dev-server
  ```

   

  / 模块热替换 (

  ```
  HMR
  ```

  ) 提升开发体验；

  - 监听文件变动 忽略 node_modules 目录能有效提高监听时的编译效率；

- 缩小编译范围

  - `modules`: 指定模块路径，减少递归搜索；
  - `mainFields`: 指定入口文件描述字段，减少搜索；
  - `noParse`: 避免对非模块化文件的加载；
  - `includes/exclude`: 指定搜索范围/排除不必要的搜索范围；
  - `alias`: 缓存目录，避免重复寻址；

- ```
  babel-loader
  ```

  - 忽略`node_moudles`，避免编译第三方库中已经被编译过的代码
  - 使用`cacheDirectory`，可以缓存编译结果，避免多次重复编译

- 多进程并发

  - `webpack-parallel-uglify-plugin`: 可多进程并发压缩 js 文件，提高压缩速度；
  - `HappyPack`: 多进程并发文件的 `Loader` 解析；

- 第三方库模块缓存:

  - `DLLPlugin` 和 `DLLReferencePlugin` 可以提前进行打包并缓存，避免每次都重新编译；

- 使用分析

  - `Webpack Analyse / webpack-bundle-analyzer` 对打包后的文件进行分析，寻找可优化的地方
  - 配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方

- ```
  source-map
  ```

  :

  - 开发: `cheap-module-eval-source-map`
  - 生产: `hidden-source-map`；

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#优化webpack打包速度)优化webpack打包速度

- 减少文件搜索范围
  - 比如通过别名
  - `loader` 的 `test`，`include & exclude`
- `Webpack4` 默认压缩并行
- `Happypack` 并发调用
- `babel` 也可以缓存编译

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_6-webpack-import-原理)6 webpack import()原理

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#动态导入原理)动态导入原理

> 用于动态加载的`import()`方法

- 这个功能可以实现按需加载我们的代码，并且使用了`promise`式的回调，获取加载的包
- 在代码中所有被`import()`的模块，都将打成一个单独的包，放在`chunk`存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载

```js
// 这里是一个简单的demo。
// 可以看到，import()的语法十分简单。该函数只接受一个参数，就是引用包的地址
import('lodash').then(_ => {
  // Do something with lodash (a.k.a '_')...
 })
```

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#webpack中如何实现动态导入)webpack中如何实现动态导入？

1. 使用`import(/** webpackChunkName: "lodash" **/ 'lodash').then(_ => {})`，同时可以在`webpack.config.js`中配置一下`output的chunkFilename`为`[name].bunld.js`将要导入的模块单独抽离到一个`bundle`中，以此实现代码分离。
2. 使用`async`，由于`import()`返回的是一个`promise`, 因此我们可以使用`async`函数来简化它，不过需要`babel`这样的预处理器及处理转换`async`的插件。`const _ = await import(/* webpackChunkName: "lodash" */ 'lodash');`

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_7-webpack有哪几种文件指纹)7 webpack有哪几种文件指纹？

- `hash`是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的`hash`值都会更改，并且全部文件都共用相同的`hash`值。(粒度整个项目)
- `chunkhash`是根据不同的入口进行依赖文件解析，构建对应的`chunk`(模块)，生成对应的`hash`值。只有被修改的`chunk`(模块)在重新构建之后才会生成新的`hash`值，不会影响其它的`chunk`。(粒度`entry`的每个入口文件)
- `contenthash`是跟每个生成的文件有关，每个文件都有一个唯一的`hash`值。当要构建的文件内容发生改变时，就会生成新的`hash`值，且该文件的改变并不会影响和它同一个模块下的其它文件。(粒度每个文件的内容)

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#webpack如果使用了hash命名-那是每次都会重写生成hash吗)webpack如果使用了hash命名，那是每次都会重写生成hash吗

有三种情况：

- 如果是`hash`的话，是和整个项目有关的，有一处文件发生更改则所有文件的`hash`值都会发生改变且它们共用一个`hash`值；
- 如果是`chunkhash`的话，只和`entry`的每个入口文件有关，也就是同一个`chunk`下的文件有所改动该`chunk`下的文件的`hash`值就会发生改变
- 如果是`contenthash`的话，和每个生成的文件有关，只有当要构建的文件内容发生改变时才会给该文件生成新的`hash`值，并不会影响其它文件。

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_8-webpack中如何处理图片的)8 webpack中如何处理图片的？

在`webpack`中有两种处理图片的`loader`：

- `file-loader`：解决`CSS`等中引入图片的路径问题；(解决通过`url`,`import/require()`等引入图片的问题)
- `url-loader`：当图片小于设置的`limit`参数值时，`url-loader`将图片进行`base64`编码(当项目中有很多图片，通过`url-loader`进行`base64`编码后会减少`http`请求数量，提高性能)，大于limit参数值，则使用`file-loader`拷贝图片并输出到编译目录中；

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_9-webpack常用插件总结)9 webpack常用插件总结

**1. 功能类**

**1.1 html-webpack-plugin**

> 自动生成`html`，基本用法：

```text
new HtmlWebpackPlugin({
  filename: 'index.html', // 生成文件名
  template: path.join(process.cwd(), './index.html') // 模班文件
})
```

**1.2 copy-webpack-plugin**

> 拷贝资源插件

```text
new CopyWebpackPlugin([
  {
    from: path.join(process.cwd(), './vendor/'),
    to: path.join(process.cwd(), './dist/'),
    ignore: ['*.json']
  }
])
```

**1.3 webpack-manifest-plugin && assets-webpack-plugin**

> 俩个插件效果一致，都是生成编译结果的资源单，只是资源单的数据结构不一致而已

**webpack-manifest-plugin 基本用法**

```text
module.exports = {
  plugins: [
    new ManifestPlugin()
  ]
}
```

**assets-webpack-plugin 基本用法**

```text
module.exports = {
  plugins: [
    new AssetsPlugin()
  ]
}
```

**1.4 clean-webpack-plugin**

> 在编译之前清理指定目录指定内容

```text
// 清理目录
const pathsToClean = [
  'dist',
  'build'
]
 
// 清理参数
const cleanOptions = {
  exclude:  ['shared.js'], // 跳过文件
}
module.exports = {
  // ...
  plugins: [
    new CleanWebpackPlugin(pathsToClean, cleanOptions)
  ]
}
```

**1.5 compression-webpack-plugin**

> 提供带 `Content-Encoding` 编码的压缩版的资源

```text
module.exports = {
  plugins: [
    new CompressionPlugin()
  ]
}
```

**1.6 progress-bar-webpack-plugin**

> 编译进度条插件

```text
module.exports = {
  //...
  plugins: [
    new ProgressBarPlugin()
  ]
}
```

**2. 代码相关类**

**2.1 webpack.ProvidePlugin**

> 自动加载模块，如 `$` 出现，就会自动加载模块；`$` 默认为`'jquery'`的`exports`

```text
new webpack.ProvidePlugin({
  $: 'jquery',
})
```

**2.2 webpack.DefinePlugin**

> 定义全局常量

```text
new webpack.DefinePlugin({
  'process.env': {
    NODE_ENV: JSON.stringify(process.env.NODE_ENV)
  }
})
```

**2.3 mini-css-extract-plugin && extract-text-webpack-plugin**

> 提取css样式，对比

- `mini-css-extract-plugin` 为`webpack4`及以上提供的`plugin`，支持`css chunk`
- `extract-text-webpack-plugin` 只能在`webpack3` 及一下的版本使用，不支持`css chunk`

**基本用法 extract-text-webpack-plugin**

```text
const ExtractTextPlugin = require("extract-text-webpack-plugin");
 
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: "style-loader",
          use: "css-loader"
        })
      }
    ]
  },
  plugins: [
    new ExtractTextPlugin("styles.css"),
  ]
}
```

**基本用法 mini-css-extract-plugin**

```text
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
    module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '/'  // chunk publicPath
            }
          },
          "css-loader"
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "[name].css", // 主文件名
      chunkFilename: "[id].css"  // chunk文件名
    })
  ]
}
```

**3. 编译结果优化类**

**3.1 wbepack.IgnorePlugin**

> 忽略`regExp`匹配的模块

```text
new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)
```

**3.2 uglifyjs-webpack-plugin**

> 代码丑化，用于js压缩

```text
module.exports = {
  //...
  optimization: {
    minimizer: [new UglifyJsPlugin({
      cache: true,   // 开启缓存
      parallel: true, // 开启多线程编译
      sourceMap: true,  // 是否sourceMap
      uglifyOptions: {  // 丑化参数
        comments: false,
        warnings: false,
        compress: {
          unused: true,
          dead_code: true,
          collapse_vars: true,
          reduce_vars: true
        },
        output: {
          comments: false
        }
      }
    }]
  }
};
```

**3.3 optimize-css-assets-webpack-plugin**

> css压缩，主要使用 `cssnano` 压缩器 https://github.com/cssnano/cssnano

```text
module.exports = {
  //...
  optimization: {
    minimizer: [new OptimizeCssAssetsPlugin({
      cssProcessor: require('cssnano'),   // css 压缩优化器
      cssProcessorOptions: { discardComments: { removeAll: true } } // 去除所有注释
    })]
  }
};
```

**3.4 webpack-md5-hash**

> 使你的`chunk`根据内容生成`md5`，用这个`md5`取代 `webpack chunkhash`。

```text
var WebpackMd5Hash = require('webpack-md5-hash');
 
module.exports = {
  // ...
  output: {
    //...
    chunkFilename: "[chunkhash].[id].chunk.js"
  },
  plugins: [
    new WebpackMd5Hash()
  ]
};
```

**3.5 SplitChunksPlugin**

- `CommonChunkPlugin` 的后世，用于`chunk`切割。

> `webpack` 把 `chunk` 分为两种类型，一种是初始加载`initial chunk`，另外一种是异步加载 `async chunk`，如果不配置`SplitChunksPlugin`，`webpack`会在`production`的模式下自动开启，默认情况下，`webpack`会将 `node_modules` 下的所有模块定义为异步加载模块，并分析你的 `entry`、动态加载（`import()`、`require.ensure`）模块，找出这些模块之间共用的`node_modules`下的模块，并将这些模块提取到单独的`chunk`中，在需要的时候异步加载到页面当中，其中默认配置如下

```text
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async', // 异步加载chunk
      minSize: 30000,
      maxSize: 0,
      minChunks: 1,
      maxAsyncRequests: 5,
      maxInitialRequests: 3,
      automaticNameDelimiter: '~', // 文件名中chunk分隔符
      name: true,
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,  // 
          priority: -10
        },
        default: {
          minChunks: 2,  // 最小的共享chunk数
          priority: -20,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```

**4. 编译优化类**

**4.1 DllPlugin && DllReferencePlugin && autodll-webpack-plugin**

- `dllPlugin`将模块预先编译，`DllReferencePlugin` 将预先编译好的模块关联到当前编译中，当 `webpack` 解析到这些模块时，会直接使用预先编译好的模块。
- `autodll-webpack-plugin` 相当于 `dllPlugin` 和 `DllReferencePlugin` 的简化版，其实本质也是使用 `dllPlugin && DllReferencePlugin`，它会在第一次编译的时候将配置好的需要预先编译的模块编译在缓存中，第二次编译的时候，解析到这些模块就直接使用缓存，而不是去编译这些模块

**dllPlugin 基本用法：**

```text
const output = {
  filename: '[name].js',
  library: '[name]_library',
  path: './vendor/'
}

module.exports = {
  entry: {
    vendor: ['react', 'react-dom']  // 我们需要事先编译的模块，用entry表示
  },
  output: output,
  plugins: [
    new webpack.DllPlugin({  // 使用dllPlugin
      path: path.join(output.path, `${output.filename}.json`),
      name: output.library // 全局变量名， 也就是 window 下 的 [output.library]
    })
  ]
}
```

**DllReferencePlugin 基本用法：**

```text
const manifest = path.resolve(process.cwd(), 'vendor', 'vendor.js.json')

module.exports = {
  plugins: [
    new webpack.DllReferencePlugin({
      manifest: require(manifest), // 引进dllPlugin编译的json文件
      name: 'vendor_library' // 全局变量名，与dllPlugin声明的一致
    }
  ]
}
```

**autodll-webpack-plugin 基本用法：**

```text
module.exports = {
  plugins: [
    new AutoDllPlugin({
      inject: true, // 与 html-webpack-plugin 结合使用，注入html中
      filename: '[name].js',
      entry: {
        vendor: [
          'react',
          'react-dom'
        ]
      }
    })
  ]
}
```

**4.2 happypack && thread-loader**

> 多线程编译，加快编译速度，`thread-loader`不可以和 `mini-css-extract-plugin` 结合使用

**happypack 基本用法**

```text
const HappyPack = require('happypack');
const os = require('os');
const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });
const happyLoaderId = 'happypack-for-react-babel-loader';

module.exports = {
  module: {
    rules: [{
      test: /\.jsx?$/,
      loader: 'happypack/loader',
      query: {
        id: happyLoaderId
      },
      include: [path.resolve(process.cwd(), 'src')]
    }]
  },
  plugins: [new HappyPack({
    id: happyLoaderId,
    threadPool: happyThreadPool,
    loaders: ['babel-loader']
  })]
}
```

**thread-loader 基本用法**

```text
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve("src"),
        use: [
          "thread-loader",
          // your expensive loader (e.g babel-loader)
          "babel-loader"
        ]
      }
    ]
  }
}
```

**4.3 hard-source-webpack-plugin && cache-loader**

> 使用模块编译缓存，加快编译速度

**hard-source-webpack-plugin 基本用法**

```text
module.exports = {
  plugins: [
    new HardSourceWebpackPlugin()
  ]
}
```

**cache-loader 基本用法**

```text
module.exports = {
  module: {
    rules: [
      {
        test: /\.ext$/,
        use: [
          'cache-loader',
          ...loaders
        ],
        include: path.resolve('src')
      }
    ]
  }
}
```

**5. 编译分析类**

**5.1 webpack-bundle-analyzer**

> 编译模块分析插件

```text
new BundleAnalyzerPlugin({
  analyzerMode: 'server',
  analyzerHost: '127.0.0.1',
  analyzerPort: 8889,
  reportFilename: 'report.html',
  defaultSizes: 'parsed',
  generateStatsFile: false,
  statsFilename: 'stats.json',
  statsOptions: null,
  logLevel: 'info'
}),
```

**5.2 stats-webpack-plugin && PrefetchPlugin**

> `stats-webpack-plugin` 将构建的统计信息写入文件，该文件可在 http://webpack.github.io/analyse中上传进行编译分析，并根据分析结果，可使用 `PrefetchPlugin` 对部分模块进行预解析编译

**stats-webpack-plugin 基本用法：**

```text
module.exports = {
  plugins: [
    new StatsPlugin('stats.json', {
      chunkModules: true,
      exclude: [/node_modules[\\\/]react/]
    })
  ]
};
```

**PrefetchPlugin 基本用法：**

```text
module.exports = {
  plugins: [
    new webpack.PrefetchPlugin('/web/', 'app/modules/HeaderNav.jsx'),
    new webpack.PrefetchPlugin('/web/', 'app/pages/FrontPage.jsx')
];
}
```

**5.3 speed-measure-webpack-plugin**

> 统计编译过程中，各`loader`和`plugin`使用的时间

```text
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
 
const smp = new SpeedMeasurePlugin();
 
const webpackConfig = {
  plugins: [
    new MyPlugin(),
    new MyOtherPlugin()
  ]
}
module.exports = smp.wrap(webpackConfig);
```

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_10-抽象语法树ast)10 抽象语法树AST

> **抽象语法树（`Abstract Syntax Tree`）**，是将代码逐字母解析成 **树状对象** 的形式。这是语言之间的转换、代码语法检查、代码风格检查、代码格式化、代码高亮、代码错误提示、代码自动补全等等的基础

```js
// 转换前
function square(n) {
  return n * n
}

// 转换后
const element = {
  type: "FunctionDeclaration",
  start: 0,
  end: 35,
  id: Identifier,
  expression: false,
  generator: false,
  params: [1, element],
  body: BlockStatement
}
```

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_11-使用babel-loader会有哪些问题-可以怎样优化)11 使用babel-loader会有哪些问题？可以怎样优化？

1. 会使得编译很慢。解决办法是可以在`webpack`的`babel-loader`配置中使用`exclude`这个可选项来去除一些不需要编译的文件夹(例如`node_modules`和`bower_components`)，另一种可以设置`cacheDirectory`选项为`true`, 开启缓存, 转译的结果将会缓存到文件系统中, 这样使`babel-loader`至少提速两倍(代码量越多效果应该越明显)。
2. `babel-loader`使得打包文件体积过大。Babel 对一些公共方法使用了非常小的辅助代码, 比如 `_extend`.默认情况下会被添加到每一个需要它的文件中, 所以会导致打包文件体积过大.解决办法: 引入`babel runtime`作为一个单独的模块, 来避免重复。也就是可以使用`@babel/plugin-transform-runtime`和`babel-runtime`。

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_12-babel-原理)12 Babel 原理

> `babel` 的编译过程分为三个阶段：**parsing**、**transforming**、**generating**，以 ES6 编译为 ES5 作为例子：

1. `ES6` 代码输入；
2. `babylon` 进行解析得到 AST；
3. `plugin` 用 `babel-traverse` 对 `AST`树进行遍历编译，得到新的 `AST`树；
4. 用 `babel-generator` 通过 `AST`树生成 `ES5` 代码。

[Babel原理及其使用(opens new window)](http://interview.poetries.top/principle-docs/webpack/05-Babel原理及其使用.html)

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_13-babel是如何编译class的)13 Babel是如何编译Class的？

就拿下面的类来说：

```javascript
class Person {
  constructor ({ name }) {
    this.name = name
    this.getSex = function () {
      return 'boy'
    }
  }
  getName () {
    return this.name
  }
  static getLook () {
    return 'sunshine'
  }
}
```

当我们在使用`babel`的这些`plugin`或者使用`preset`的时候，有一个配置属性`loose`它默认是为`false`，在这样的条件下：

`Class`编译后：

- 总体来说`Class`会被封装成一个`IIFE`立即执行函数
- 立即执行函数返回的是一个与类同名的构造函数
- 实例属性和方法定义在构造函数内(如`name`和`getSex()`)
- 类内部声明的属性方法(`getName`)和静态属性方法(`getLook`)是会被`Object.defineProperty`所处理，将其可枚举属性设置为`false`

编译后的代码：

```javascript
"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var Person = /*#__PURE__*/ (function () {
  function Person(_ref) {
    var name = _ref.name;

    _classCallCheck(this, Person);

    this.name = name;

    this.getSex = function () {
      return "boy";
    };
  }

  _createClass(
    Person,
    [
      {
        key: "getName",
        value: function getName() {
          return this.name;
        },
      },
    ],
    [
      {
        key: "getLook",
        value: function getLook() {
          return "sunshine";
        },
      },
    ]
  );

  return Person;
})();
```

为什么`Babel`对于类的处理会使用`Object.defineProperty`这种形式呢？它和直接使用原型链有什么不同吗？

- 通过原型链声明的属性和方法是可枚举的，也就是可以被`for...of...`搜寻到
- 而类内部声明的方法是不可枚举的

所以，babel为了符合ES6真正的语义，编译类时采取了`Object.defineProperty`来定义原型方法。

但是可以通过设置`babel`的`loose`模式(宽松模式)为`true`，它会不严格遵循ES6的语义，而采取更符合我们平常编写代码时的习惯去编译代码，在`.babelrc`中可以如下设置：

```javascript
{
  "presets": [["env", { "loose": true }]]
}
```

比如上述的`Person`类的属性方法将会编译成直接在原型链上声明方法：

```javascript
"use strict";

var Person = /*#__PURE__*/function () {
  function Person(_ref) {
    var name = _ref.name;
    this.name = name;

    this.getSex = function () {
      return 'boy';
    };
  }

  var _proto = Person.prototype;

  _proto.getName = function getName() {
    return this.name;
  };

  Person.getLook = function getLook() {
    return 'sunshine';
  };

  return Person;
}();
```

**总结**

- 当使用`Babel`编译时默认的`loose`为`false`，即非宽松模式

- 无论哪种模式，转换后的定义在类内部的属性方法是被定义在构造函数的原型对象上的；静态属性被定义到构造函数上

- 只不过非宽松模式时，这些属性方法会被`_createClass`函数处理，函数内通过`Object.defineProperty()`设置属性的可枚举值`enumerable`为`false`

- 由于在`_createClass`函数内使用了`Object`，所以非宽松模式下是会产生副作用的，而宽松模式下不会。

- `webpack`中的`UglifyJS`依旧还是会将宽松模式认为是有副作用的，而`rollup`有**程序流程分析**的功能，可以更好的判断代码是否真正产生副作用，所以它会认为宽松模式没有副作用。

  (副作用大致理解为：一个函数会、或者可能会对函数外部变量产生影响的行为。)

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_14-babel-polyfill是什么)14 babel-polyfill是什么

ployfill是补丁

![img](http://img-repo.poetries.top/images/20210409165913.png)

`babel-polyfill`现在已经被弃用

- `babel 7.4`之后弃用`babel-polyfill`
- 直接推荐使用`core-js`和`regenerator`

**babel-polyfill按需引入**

- 文件较大
- 只用一部分功能，无需全部引入
- 配置按需引入

![img](http://img-repo.poetries.top/images/20210409170227.png) ![img](http://img-repo.poetries.top/images/20210409170237.png)

**babel-polyfill的问题**

- 会污染全局环境
- 如果做一个独立的web系统，无碍
- 如果做一个第三个的lib，会有问题

![img](http://img-repo.poetries.top/images/20210409170414.png) ![img](http://img-repo.poetries.top/images/20210409170424.png)

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_15-tree-shaking原理是什么)15 Tree Shaking原理是什么

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#对tree-shaking的了解)对tree-shaking的了解

**作用：**

它表示在打包的时候会去除一些无用的代码

**原理**：

- `ES6`的模块引入是静态分析的，所以在编译时能正确判断到底加载了哪些模块
- 分析程序流，判断哪些变量未被使用、引用，进而删除此代码

**特点：**

- 在生产模式下它是默认开启的，但是由于经过`babel`编译全部模块被封装成`IIFE`，它存在副作用无法被`tree-shaking`掉
- 可以在`package.json`中配置`sideEffects`来指定哪些文件是有副作用的。它有两种值，一个是布尔类型，如果是`false`则表示所有文件都没有副作用；如果是一个数组的话，数组里的文件路径表示改文件有副作用
- `rollup`和`webpack`中对`tree-shaking`的层度不同，例如对`babel`转译后的`class`，如果`babel`的转译是宽松模式下的话(也就是`loose`为`true`)，`webpack`依旧会认为它有副作用不会`tree-shaking`掉，而`rollup`会。这是因为`rollup`有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。

### [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#原理)原理

- `ES6 Module` 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
- 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

> 依赖于`import/export`

通过导入所有的包后再进行条件获取。如下：

```js
import foo from "foo";
import bar from "bar";

if(condition) {
    // foo.xxxx
} else {
    // bar.xxx
}
```

> ES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码

**CommonJS的动态特性模块意味着tree shaking不适用**。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：

```js
// 不可行，ES6 的import是完全静态的
if(condition) {
    myDynamicModule = require("foo");
} else {
    myDynamicModule = require("bar");
}
```

## [#](http://interview.poetries.top/excellent-docs/9-前端工程模块.html#_16-vite了解吗)16 Vite了解吗

> 是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。在生产环境下使用Rollup打包

**Vite 特点**

- Dev Server 无需等待，即时启动；
- 几乎实时的模块热更新；
- 所需文件按需编译，避免编译用不到的文件；
- 开箱即用，避免各种 Loader 和 Plugin 的配置；

**开箱即用**

- `TypeScript` - 内置支持
- `less/sass/stylus/postcss` - 内置支持（需要单独安装所对应的编译器）

**生产环境需要打包吗**

> 可以不打包，需要启动server，需要浏览器支持

![img](http://img-repo.poetries.top/images/20210315165345.png)

**手写实现**

> Vite 的核心功能：`Static Server + Compile + HMR`

核心思路：

- 将当前项目目录作为静态文件服务器的根目录
- 拦截部分文件请求
  - 处理代码中 `import node_modules` 中的模块
  - 处理 `vue` 单文件组件（`SFC`）的编译
- 通过 `WebSocket` 实现 `HMR`

```js
#!/usr/bin/env node

const path = require('path')
const { Readable } = require('stream')
const Koa = require('koa')
const send = require('koa-send')
const compilerSfc = require('@vue/compiler-sfc')

const cwd = process.cwd()

const streamToString = stream =>
  new Promise((resolve, reject) => {
    const chunks = []
    stream.on('data', chunk => chunks.push(chunk))
    stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')))
    stream.on('error', reject)
  })

const app = new Koa()

// 重写请求路径，/@modules/xxx => /node_modules/
app.use(async (ctx, next) => {
  if (ctx.path.startsWith('/@modules/')) {
    const moduleName = ctx.path.substr(10) // => vue
    const modulePkg = require(path.join(cwd, 'node_modules', moduleName, 'package.json'))
    ctx.path = path.join('/node_modules', moduleName, modulePkg.module)
  }
  await next()
})

// 根据请求路径得到相应文件 /index.html
app.use(async (ctx, next) => {
  // ctx.path // http://localhost:3080/
  // ctx.body = 'my-vite'
  await send(ctx, ctx.path, { root: cwd, index: 'index.html' }) // 有可能还需要额外处理相应结果
  await next()
})

// .vue 文件请求的处理，即时编译
app.use(async (ctx, next) => {
  if (ctx.path.endsWith('.vue')) {
    const contents = await streamToString(ctx.body)
    const { descriptor } = compilerSfc.parse(contents)
    let code

    if (ctx.query.type === undefined) {
      code = descriptor.script.content
      code = code.replace(/export\s+default\s+/, 'const __script = ')
      code += `
  import { render as __render } from "${ctx.path}?type=template"
  __script.render = __render
  export default __script`
      // console.log(code)
      ctx.type = 'application/javascript'
      ctx.body = Readable.from(Buffer.from(code))
    } else if (ctx.query.type === 'template') {
      const templateRender = compilerSfc.compileTemplate({
        source: descriptor.template.content
      })
      code = templateRender.code
    }

    ctx.type = 'application/javascript'
    ctx.body = Readable.from(Buffer.from(code))
  }
  await next()
})

// 替换代码中特殊位置
app.use(async (ctx, next) => {
  if (ctx.type === 'application/javascript') {
    const contents = await streamToString(ctx.body)
    ctx.body = contents
      .replace(/(from\s+['"])(?![\.\/])/g, '$1/@modules/')
      .replace(/process\.env\.NODE_ENV/g, '"production"')
  }
})

app.listen(3080)

console.log('Server running @ http://localhost:3080')
```

# 10 移动多端开发

## 1 移动端适配

**为什么要做适配**

- 为了适应各种移动端设备，完美呈现应有的布局效果
- 各个移动端设备，分辨率大小不一致，网页想铺满整个屏幕，并在各种分辨下等比缩放

### [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#适配方案)适配方案

- 固定高度，宽度百分比适配-布局非常均匀，适合百分比布局
- 固定宽度，改变缩放比例适配-什么情况都可以
- Rem适配
- 像素比适配

**单位**

- `em`根据元素自身的字体大小计算,元素自身 `16px 1em=16px`
- `Rem R -> root` 根节点( html ) 根据html的字体大小计算其他元素尺寸

**百分比适配**

> 固定高度，宽度百分比适配

- 根据设置的大小去设置高度，单位可以用px 百分比 auto
- 常用Flex布局
- 百分比宽度

> 以640设计稿为例，在外层容器上设置最大以及最小的宽

```css
#wrapper {
    max-width: 640px; /*设置设计稿的宽度*/
    min-width: 300px;
    margin: 0 auto;
}
```

> 后面的区块布局都用百分比，具体元素大小用`px`计算

**Rem适配(常用)**

- 根据屏幕的分辨率动态设置`html`的文字大小，达到等比缩放的功能
- 保证`html`最终算出来的字体大小，不能小于`12px`
- 在不同的移动端显示不同的元素比例效果
- 如果`html`的`font-size:20px`的时候，那么此时的`1rem = 20px`
- 把设计图的宽度分成多少分之一，根据实际情况
- `rem`做盒子的宽度，`viewport`缩放

> `head`加入常见的`meta`属性

```html
<meta name="format-detection" content="telephone=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<!--这个是关键-->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0，minimum-scale=1.0">
```

> 把这段代码加入`head`中的`script`预先加载

```js
// rem适配用这段代码动态计算html的font-size大小
(function(win) {
    var docEl = win.document.documentElement;
    var timer = '';

    function changeRem() {
        var width = docEl.getBoundingClientRect().width;
        if (width > 750) { // 750是设计稿大小
            width = 750;
        }
        var fontS = width / 10; // 把设备宽度十等分 1rem=10px
        docEl.style.fontSize = fontS + "px";
    }
    win.addEventListener("resize", function() {
        clearTimeout(timer);
        timer = setTimeout(changeRem, 30);
    }, false);
    win.addEventListener("pageshow", function(e) {
        if (e.persisted) { //清除缓存
            clearTimeout(timer);
            timer = setTimeout(changeRem, 30);
        }
    }, false);
    changeRem();
})(window)
```

**像素比适配**

- `window.devicePixelRatio`
- 物理像素是手机屏幕分辨率
- 独立像素 指`css`像素 屏幕宽度
- 像素比 = 物理像素 / `css`宽度
- 获取设备的像素比 `window.devicePixelRatio`

## [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_2-移动端300ms延迟)2 移动端300ms延迟

> 由来：300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作， 当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作 因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕

**解决方案**：

1. 禁用缩放，设置meta标签 `user-scalable=no`
2. `fastclick.js`

> 原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即发出click事件，并把浏览器在300ms之后真正的click事件阻止掉。fastclick.js还可以解决穿透问题

- fastclick可以解决在手机上点击事件的300ms延迟
- zepto的touch模块，tap事件也是为了解决在click的延迟问题

**触摸事件的响应顺序**

- `ontouchstart`
- `ontouchmove`
- `ontouchend`
- `onclick`

## [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_3-如何解决移动端-retina-屏-1px-像素问题)3 如何解决移动端 Retina 屏 1px 像素问题

- `伪元素 + transform scaleY(.5)`
- `border-image`
- `background-image`
- `box-shadow`

> 一般来说，在PC端浏览器中，设备像素比（dpr）等于1，1个css像素就代表1个物理像素；但是在`retina`屏幕中，dpr普遍是2或3，1个css像素不再等于1个物理像素，因此比实际设计稿看起来粗不少

1. 伪元素+scale

```html
<style>
    .box{
        width: 100%;
        height: 1px;
        margin: 20px 0;
        position: relative;
    }
    .box::after{
        content: '';
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 1px;
        transform: scaleY(0.5);
        transform-origin: 0 0; 
        background: red;
    }
</style>

<div class="box"></div>
```

1. border-image

```css
div{
    border-width: 1px 0px;
    -webkit-border-image: url(border.png) 2 0 stretch;
    border-image: url(border.png) 2 0 stretch;
}
```

## [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_4-如何解决移动端击穿-穿透-问题)4 如何解决移动端击穿（穿透）问题

> 在移动端开发的时候，我们有时候会遇到这样一个bug：点击关闭遮罩层的时候，遮罩层下面的带有点击的元素也会被触发，给人一种击穿了页面的感觉，这是为什么呢？

- 点击“打开弹框”按钮，显示遮罩层
- 点击“关闭弹框”按钮，遮罩层消失，底下的连接被触发

![img](http://blog.poetries.top/img-repo/2020/03/3.png)

上图事例js部分代码

```js
var show = document.getElementById('show') // 打开按钮
var mask = document.getElementById('mask') // 遮罩层
var btn = document.getElementById('btn')   // 关闭按钮

show.onclick = function () {
    mask.style.display = 'block'
}

btn.addEventListener('touchstart', function () {
    mask.style.display = 'none'
}, false)
```

- 这样问题的形成原因是什么呢？
- 我们先来看一段代码：(以下代码需在移动端上运行)

```js
<div id="btn">我是一个按钮</div>
var btn = document.getElementById('btn')
btn.addEventListener('touchstart', function () {
    console.log('start')    
}, false)

btn.addEventListener('touchmove', function () {
    console.log('move')
}, false)

btn.addEventListener('touchend', function () {
    console.log('touchend')
}, false)

btn.addEventListener('click', function () {
    console.log('click')
}, false)
```

> 以上代码会出现2种运行情况

```text
start ===> move ===> end
start ===> end ===> click
```

> 看到这里相信大家都明白了，由于「关闭弹框」按钮绑定的事件是`touch`，a标签是`click`事件，在`touch`事件触发后，我们弹出框的遮罩层就消失了，这时候的`click`事件就被a标签给捕获到了，形成了击穿的效果

**方法一、阻止默认事件**

```js
btn.addEventListener('touchend', function (e) {
    mask.style.display = 'none'
    e.preventDefault()
}, false)
```

> 在执行 touchstart 和 touchend 事件时，隐藏执行完隐藏命令后，立即阻止后续事件(推荐在touchend时，阻止后续的默认事件)

**方法二、统一使用click事件**

```js
btn.addEventListener('click', function () {
    mask.style.display = 'none'
}, false)
```

> 这个方法简单，就是交互的效率没有`click`事件高，另外，用户在`touch`的时候，有可能微微滑动了一下，就会无法触发点击事件。影响用户体验。

**方法三、延迟执行**

```js
btn.addEventListener('touchend', function () {
    setTimeout(function () {
        mask.style.display = 'none'  // 可以使用fadeOut动画
    }, 300)
}, false)
```

> 点击之后，我们不立即隐藏。让遮罩在350ms毫秒内淡出消失。（我为了演示方便就没有添加动画了，采用了定时器方法。）

**方法四、 css属性pointer-events**

```js
click.setAttribute('style', 'pointer-events:none')
mask.style.display = 'none'
setTimeout(function () {
    click.setAttribute('style', 'pointer-events:auto')
}, 350)
```

> 这样做法是，在遮罩消失之前，先让a标签忽略点击事件，这样遮罩层的点击事件，就不会被a标签捕获到。还是等350毫秒之后，再次赋予a标签的点击能力。这个方法跟方法三原理相似，只是利用了不同的css属性而已。个人觉得方法三比较好一点。方法四有明显的2个缺点：

- 遮罩层下面可能有多个带有事件的元素，那么你需要给所有可点击元素添加`pointer-events`属性 然后删除。不仅容易出错，还影响性能
- 如果用户在`350`毫秒内点击了元素，会造成页面失效的错觉，影响体验。

**方法五、fastClick库**

> 这个库的引用方法，在我上一篇文章中已经讲到。fastClick的原理就是使用了方法一的做法。fastClick 在 touchend 阶段 调用 event.preventDefault，然后通过 document.createEvent 创建一个 MouseEvents，然后 通过 `eventTarget.dispatchEvent` 触发对应目标元素上绑定的 click 事件

## [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_5-移动端的兼容问题)5 移动端的兼容问题

- 给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个`fastclick.js`文件，解决`300s`的延迟 一般在移动端用`ontouchstart`、`ontouchmove`、`ontouchend`
- 移动端点透问题,`touchstart` 早于 `touchend` 早于`click`,`click`的触发是有延迟的，这个时间大概在`300ms`左右，也就是说我们`tap`触发之后蒙层隐藏， 此时 `click`还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上尽量都使用`touch`事件来替换`click`事件。例如用touchend事件(推荐)。用`fastclick`，`github.com/ftlabs/fast…`用`preventDefault`阻止`a`标签的`click`消除 `IE10` 里面的那个叉号`input:-ms-clear{display:none;}`
- 设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置`no-cache`。
- 圆角`BUG` 某些Android手机圆角失效 b`ackground-clip: padding-box;` 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置`meta`中的`viewport`
- 设置用户截止缩放，一般写视口的时候就已经写好了

## [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_6-jsbridge原理是什么-如何设计一个jsbridge)6 JSBridge原理是什么？如何设计一个JSBridge？

### [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_6-1-jsbridge原理)6.1 JSBridge原理

> `JSBridge`的作用就是让`native`可以调用`web`的`js`代码，让`web`可以调用原生的代码，实现数据通信，它在做`native`代码和js代码相互转换的事情。

![img](http://img-repo.poetries.top/images/20210319155725.png)

**实现数据间的通讯关键是以下两点：**

- 将`Native`端的接口封装成js接口
- 将`Web`端js接口封装成原生接口

### [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_6-2-jsbridge的核心)6.2 JsBridge的核心

- 拦截Url
- `load url("javascript:js_method()");`

### [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_6-3-为什么是-js-bridge)6.3 为什么是‘JS’Bridge

> 因为Web端支持JavaScript，而`Native(iOS/Android)`端的`Webview`控件对JavaScript也有所支持，页面加载完成后调用页面的JavaScript代码

### [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_6-4-应用场景)6.4 应用场景

> 它有什么用？我们在使用混合开发模式(`Hybrid App`)混合使用`Native`和`Web`技术用到。例如目前的使用此技术的主流框架`React Native`、`Weex`、微信小程序等

### [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_6-5-jsbridge实现-native端调用web端代码)6.5 JSBridge实现 —— Native端调用Web端代码

> `WebView`是`Native`中加载网页的一个控件，该组件提供一个`evaluateJavascript()`方法运行JS代码。我们要做的是在Native端执行一个js方法，在Web端进行监听

**1. 执行一段JS代码**

```js
webView.evaluateJavascript("window.showWebDialog('123')",null);
```

**2. Web端进行监听**

```html
<script>
    window.showWebDialog = text => window.alert(text);
</script>
```

### [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_6-6-jsbridge实现-web端调用native端代码-拦截url-schema)6.6 JSBridge实现 —— Web端调用Native端代码（拦截URL Schema）

> 当Web端要请求`Native`端的方法时，我们首先要自定义一个`URL Schema`，向Native端发起一个请求，最后在`Native`端的`WebView`进行监听，下面我们看看具体实现：

![img](http://img-repo.poetries.top/images/20210319160140.png)

**1. URL schema介绍**

> ```
> URL schema` 是类`URL`的请求格式，如：`<protocol>://<domain>/<path>?<query>
> ```

接下来可以自定义通信的`URL schema`，如：

```text
jsbridge://<method>?<params>
jsbridge://showToast?text=hello&a=b
```

**2. 发送URL schema请求**

> 请求自定义`URL Schema`方法：`jsbridge://showToast?text=`

向Native端发起请求：

```html
<script>
    function showNativeDialog(text) {
        window.alert('jsbridge://showToast?text=' + text);
    }
</script>
```

**3. Native端实现监听**

```js
   webView.setWebChromeClient(new WebChromeClient() {
        @Override
        public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
            if (!message.startsWith("jsbridge://")) {
                return super.onJsAlert(view, url, message, result);
            }

            UrlSchema urlschema = new UrlSchema(message);
            if ("showToast".equals(urlchema.getMethodName())) {
                String text = urlschema.getParams("text");
                Toast.makeText(mContext, text, Toast.LENGTH_LONG).show();
            }

            result.confirm();
            return true;
        }
    }
```

### [#](http://interview.poetries.top/excellent-docs/10-移动多端开发.html#_6-7-jsbridge实现-web端调用native端代码-注入api)6.7 JSBridge实现 —— Web端调用Native端代码（注入api)

> 注入API 方式的是Native端通过 WebView 提供的接口，向 JavaScript 的 `Context（window）`中注入对象。在Web中通过注入的对象调用Native方法

![img](http://img-repo.poetries.top/images/20210319160503.png)

**1. 向WebView注入JS对象**

创建一个JS对象，并实现监听的方法

```js
class NativeBridge{
    private Context context;

    NativeBridge(Context context){
        this.context = context;
    }

    @JavascriptInterface
    public void showNativeDialog(String text){
        Toast.makeText(context,text,Toast.LENGTH_LONG).show();
    }
}
```

Native端通过WebView的接口注入JS对象

```js
webView.addJavascriptInterface(new NativeBridge(mContext),"NativeBridge");
```

**2. 通过注入的JS对象调用Native代码**

Web中获取JS对象，调用Native代码：

```html
<script>
    function showNativeDialog(text) {
        //window.alert('jsbridge://showToast?text=' + text);
        window.NativeBridge.showNativeDialog(text);
    }
</script>
```



# 11 小程序模块

## 1 登录

**unionid和openid**

> 了解小程序登陆之前，我们写了解下小程序/公众号登录涉及到两个最关键的用户标识：

- `OpenId` 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。
- `UnionId` 是一个用户对于同主体微信小程序／公众号／`APP`的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过`UnionId`，实现多个小程序、公众号、甚至APP 之间的数据互通了。

**关键Api**

- `wx.login` 官方提供的登录能力
- `wx.checkSession`校验用户当前的`session_key`是否有效
- `wx.authorize` 提前向用户发起授权请求
- `wx.getUserInfo` 获取用户基本信息

**登录流程设计**

- **利用现有登录体系**

> 直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可

- **利用`OpenId` 创建用户体系**

> `OpenId` 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下

- 小程序客户端通过 `wx.login` 获取 `code`
- 传递 `code` 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 `openid` 和会话密钥 `session_key` ，此时开发者服务端便可以利用 `openid` 生成用户入库，再向小程序客户端返回自定义登录态
- 小程序客户端缓存 （通过`storage`）自定义登录态（`token`），后续调用接口时携带该登录态作为用户身份标识即可

**利用 Unionid 创建用户体系**

> 如果想实现多个小程序，公众号，已有登录系统的数据互通，可以通过获取到用户 `unionid` 的方式建立用户体系。因为 `unionid` 在同一开放平台下的所所有应用都是相同的，通过 `unionid` 建立的用户体系即可实现全平台数据的互通，更方便的接入原有的功能，那如何获取 `unionid` 呢，有以下两种方式

- 如果户关注了某个相同主体公众号，或曾经在某个相同主体`App`、公众号上进行过微信登录授权，通过 `wx.login` 可以直接获取 到 `unionid`

- 结合

   

  ```
  wx.getUserInfo
  ```

   

  和

   

  ```
  <button open-type="getUserInfo"><button/>
  ```

   

  这两种方式引导用户主动授权，主动授权后通过返回的信息和服务端交互 (这里有一步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到

   

  ```
  unionid
  ```

   

  建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录，附上微信提供的最佳实践

  - 调用 `wx.login` 获取 `code`，然后从微信后端换取到 `session_key`，用于解密 `getUserInfo`返回的敏感数据

  - 使用

     

    ```
    wx.getSetting
    ```

     

    获取用户的授权情况

    - 如果用户已经授权，直接调用 `API` `wx.getUserInfo` 获取用户最新的信息；
    - 用户未授权，在界面中显示一个按钮提示用户登入，当用户点击并授权后就获取到用户的最新信息

  - 获取到用户数据后可以进行展示或者发送给自己的后端。

注意事项

- 需要获取 `unionid` 形式的登录体系，在以前（18年4月之前）是通过以下这种方式来实现，但后续微信做了调整（因为一进入小程序，主动弹起各种授权弹窗的这种形式，比较容易导致用户流失），调整为必须使用按钮引导用户主动授权的方式，这次调整对开发者影响较大，开发者需要注意遵守微信的规则，并及时和业务方沟通业务形式，不要存在侥幸心理，以防造成小程序不过审等情况

```text
 wx.login(获取code) ===> wx.getUserInfo(用户授权) ===> 获取 unionid
```

- 因为小程序不存在 `cookie` 的概念， 登录态必须缓存在本地，因此强烈建议为登录态设置过期时间
- 值得一提的是如果需要支持风控安全校验，多平台登录等功能，可能需要加入一些公共参数，例如`platform`，`channel`，`deviceParam`等参数。在和服务端确定方案时，作为前端同学应该及时提出这些合理的建议，设计合理的系统。
- `openid` ， `unionid` 不要在接口中明文传输，这是一种危险的行为，同时也很不专业

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_2-图片导出)2 图片导出

> 这是一种常见的引流方式，一般同时会在图片中附加一个小程序二维码。

**基本原理**

- 借助 `canvas` 元素，将需要导出的样式首先在 `canvas` 画布上绘制出来 （`api`基本和`h5`保持一致，但有轻微差异，使用时注意即可
- 借助微信提供的 `canvasToTempFilePath` 导出图片，最后再使用 `saveImageToPhotosAlbum` （需要授权）保存图片到本地

**如何优雅实现**

- 绘制出需要的样式这一步是省略不掉的。但是我们可以封装一个绘制库，包含常见图形的绘制，例如矩形，圆角矩形，圆， 扇形， 三角形， 文字，图片减少绘制代码，只需要提炼出样式信息，便可以轻松的绘制，最后导出图片存入相册。笔者觉得以下这种方式绘制更为优雅清晰一些，其实也可以使用加入一个type参数来指定绘制类型，传入的一个是样式数组，实现绘制。
- 结合上一步的实现，如果对于同一类型的卡片有多次导出需求的场景，也可以使用自定义组件的方式，封装同一类型的卡片为一个通用组件，在需要导出图片功能的地方，引入该组件即可。

```js
class CanvasKit {
   constructor() {
   }
   drawImg(option = {}) {
     ...
     return this
   }
   drawRect(option = {}) {
     return this
   }
   drawText(option = {}) {
     ...
     return this
   }
   static exportImg(option = {}) {
     ...
   }
 }

 let drawer = new CanvasKit('canvasId').drawImg(styleObj1).drawText(styleObj2)
 drawer.exportImg()
```

注意事项

- 小程序中无法绘制网络图片到`canvas`上，需要通过`downLoadFile` 先下载图片到本地临时文件才可以绘制
- 通常需要绘制二维码到导出的图片上，有一种方式导出二维码时，需要携带的参数必须做编码，而且有具体的长度（`32`可见字符）限制，可以借助服务端生成 短链接 的方式来解决

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_3-数据统计)3 数据统计

> 数据统计作为目前一种常用的分析用户行为的方式，小程序端也是必不可少的。小程序采取的曝光，点击数据埋点其实和h5原理是一样的。但是埋点作为一个和业务逻辑不相关的需求，我们如果在每一个点击事件，每一个生命周期加入各种埋点代码，则会干扰正常的业务逻辑，和使代码变的臃肿，笔者提供以下几种思路来解决数据埋点

**设计一个埋点sdk**

> 小程序的代码结构是，每一个 `Page` 中都有一个 `Page` 方法，接受一个包含生命周期函数，数据的 业务逻辑对象 包装这层数据，借助小程序的底层逻辑实现页面的业务逻辑。通过这个我们可以想到思路，对`Page`进行一次包装，篡改它的生命周期和点击事件，混入埋点代码，不干扰业务逻辑，只要做一些简单的配置即可埋点，简单的代码实现如下

```js
// 代码仅供理解思路
 page = function(params) {
   let keys = params.keys()
   keys.forEach(v => {
       if (v === 'onLoad') {
         params[v] = function(options) {
           stat()   //曝光埋点代码
           params[v].call(this, options)
         }
       }
       else if (v.includes('click')) {
         params[v] = funciton(event) {
           let data = event.dataset.config
           stat(data)  // 点击埋点
           param[v].call(this)
         }
       }
   })
 }
```

> 这种思路不光适用于埋点，也可以用来作全局异常处理，请求的统一处理等场景。

**分析接口**

> 对于特殊的一些业务，我们可以采取 接口埋点，什么叫接口埋点呢？很多情况下，我们有的`api`并不是多处调用的，只会在某一个特定的页面调用，通过这个思路我们可以分析出，该接口被请求，则这个行为被触发了，则完全可以通过服务端日志得出埋点数据，但是这种方式局限性较大，而且属于分析结果得出过程，可能存在误差，但可以作为一种思路了解一下。

**微信自定义数据分析**

> 微信本身提供的数据分析能力，微信本身提供了常规分析和自定义分析两种数据分析方式，在小程序后台配置即可。借助小程序数据助手这款小程序可以很方便的查看

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_4-工程化)4 工程化

**工程化做什么**

> 目前的前端开发过程，工程化是必不可少的一环，那小程序工程化都需要做些什么呢，先看下目前小程序开发当中存在哪些问题需要解决：

- 不支持 `css`预编译器,作为一种主流的 `css`解决方案，不论是 `less`,`sass`,`stylus` 都可以提升`css`效率
- 不支持引入npm包 （这一条，从微信公开课中听闻，微信准备支持）
- 不支持`ES7`等后续的`js`特性，好用的`async await`等特性都无法使用
- 不支持引入外部字体文件，只支持`base64`
- 没有 `eslint` 等代码检查工具

**方案选型**

> 对于目前常用的工程化方案，`webpack`，`rollup`，`parcel`等来看，都常用与单页应用的打包和处理，而小程序天生是 “多页应用” 并且存在一些特定的配置。根据要解决的问题来看，无非是文件的编译，修改，拷贝这些处理，对于这些需求，我们想到基于流的 `gulp`非常的适合处理，并且相对于`webpack`配置多页应用更加简单。所以小程序工程化方案推荐使用 `gulp`

**具体开发思路**

> 通过 `gulp` 的 `task` 实现：

- 实时编译 `less` 文件至相应目录
- 引入支持`async`，`await`的运行时文件
- 编译字体文件为`base64` 并生成相应`css`文件，方便使用
- 依赖分析哪些地方引用了`npm`包，将`npm`包打成一个文件，拷贝至相应目录
- 检查代码规范

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_5-小程序架构)5 小程序架构

![img](https://user-images.githubusercontent.com/2350193/44563914-ff97c380-a792-11e8-8e77-6d0970891e24.png)

> 微信小程序的框架包含两部分 `View` 视图层、`App Service`逻辑层。`View` 层用来渲染页面结构，`AppService` 层用来逻辑处理、数据请求、接口调用。

它们在两个线程里运行。

> 视图层和逻辑层通过系统层的 `JSBridage` 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理

![img](https://user-images.githubusercontent.com/2350193/44186238-db146980-a14a-11e8-8096-bcb8fa6d28b2.png)

- 视图层使用 `WebView` 渲染，`iOS`中使用自带 `WKWebView`，在 `Android` 使用腾讯的 `x5`内核（基于 `Blink`）运行。
- 逻辑层使用在 `iOS` 中使用自带的 `JSCore` 运行，在 `Android`中使用腾讯的 `x5` 内核（基于 `Blink`）运行。
- 开发工具使用 `nw.js` 同时提供了视图层和逻辑层的运行环境。

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_6-wxml-wxss)6 WXML && WXSS

**WXML**

- 支持数据绑定
- 支持逻辑算术、运算
- 支持模板、引用
- 支持添加事件（`bindtap`）
- `Wxml`编译器：`Wcc` 把 `Wxml`文件 转为 `JS`
- 执行方式：`Wcc index.wxml`
- 使用 `Virtual DOM`，进行局部更新

**WXSS**

- wxss编译器：`wcsc` 把`wxss`文件转化为 `js`
- 执行方式： `wcsc index.wxss`

**尺寸单位 rpx**

> `rpx（responsive pixel`）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 `750rpx`。公式：

```js
const dsWidth = 750

export const screenHeightOfRpx = function () {
  return 750 / env.screenWidth * env.screenHeight
}

export const rpxToPx = function (rpx) {
  return env.screenWidth / 750 * rpx
}

export const pxToRpx = function (px) {
  return 750 / env.screenWidth * px
}
```

**样式导入**

> 使用 `@import`语句可以导入外联样式表，`@import`后跟需要导入的外联样式表的相对路径，用 `;` 表示语句结束

**内联样式**

> 静态的样式统一写到 `class` 中。`style` 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 `style` 中，以免影响渲染速度

**全局样式与局部样式**

> 定义在 `app.wxss` 中的样式为全局样式，作用于每一个页面。在`page` 的 `wxss` 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 `app.wxss` 中相同的选择器

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_7-小程序的问题)7 小程序的问题

- 小程序仍然使用 `WebView` 渲染，并非原生渲染。（部分原生）

- 服务端接口返回的头无法执行，比如：`Set-Cookie`。

- 依赖浏览器环境的 `JS`库不能使用。

- 不能使用 `npm`，但是可以自搭构建工具或者使用 `mpvue`。（未来官方有计划支持）

- 不能使用 `ES7`，可以自己用`babel+webpack`自搭或者使用 `mpvue`。

- 不支持使用自己的字体（未来官方计划支持）。

- 可以用 `base64` 的方式来使用 `iconfont`。

- 小程序不能发朋友圈（可以通过保存图片到本地，发图片到朋友前。二维码可以使用B接口）。

- 获取二维码/小程序接口的限制

- 程序推送只能使用“服务通知” 而且需要用户主动触发提交 `formId`，`formId` 只有7天有效期。（现在的做法是在每个页面都放入`form`并且隐藏以此获取更多的 `formId`。后端使用原则为：优先使用有效期最短的）

- 小程序大小限制 2M，分包总计不超过 8M

- 转发（分享）小程序不能拿到成功结果，原来可以。链接（小游戏造的孽）

- 拿到相同的

   

  ```
  unionId
  ```

   

  必须绑在同一个开放平台下。开放平台绑定限制：

  - `50`个移动应用
  - `10`个网站
  - `50`个同主体公众号
  - `5`个不同主体公众号
  - `50`个同主体小程序
  - `5`个不同主体小程序

- 公众号关联小程序

  - 所有公众号都可以关联小程序。
  - 一个公众号可关联10个同主体的小程序，3个不同主体的小程序。
  - 一个小程序可关联500个公众号。
  - 公众号一个月可新增关联小程序13次，小程序一个月可新增关联500次。

- 一个公众号关联的10个同主体小程序和3个非同主体小程序可以互相跳转

- 品牌搜索不支持金融、医疗

- 小程序授权需要用户主动点击

- 小程序不提供测试 `access_token`

- 安卓系统下，小程序授权获取用户信息之后，删除小程序再重新获取，并重新授权，得到旧签名，导致第一次授权失败

- 开发者工具上，授权获取用户信息之后，如果清缓存选择全部清除，则即使使用了`wx.checkSession`，并且在`session_key`有效期内，授权获取用户信息也会得到新的`session_key`

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_8-授权获取用户信息流程)8 授权获取用户信息流程

![img](https://user-images.githubusercontent.com/35895755/44379940-fa403c00-a53a-11e8-9165-21b217496aad.png)

- `session_key` 有有效期，有效期并没有被告知开发者，只知道用户越频繁使用小程序，`session_key` 有效期越长
- 在调用 `wx.login` 时会直接更新 `session_key`，导致旧 `session_key` 失效
- 小程序内先调用 `wx.checkSession` 检查登录态，并保证没有过期的 `session_key` 不会被更新，再调用 `wx.login` 获取 `code`。接着用户授权小程序获取用户信息，小程序拿到加密后的用户数据，把加密数据和 `code` 传给后端服务。后端通过 `code` 拿到 `session_key` 并解密数据，将解密后的用户信息返回给小程序

**面试题：先授权获取用户信息再 login 会发生什么？**

![img](https://user-images.githubusercontent.com/35895755/44244965-268d4d00-a209-11e8-8ef4-b80cc7a78af7.png)

![img](https://user-images.githubusercontent.com/35895755/44379952-0af0b200-a53b-11e8-86be-640bf651bc9e.png)

- 用户授权时，开放平台使用旧的 `session_key` 对用户信息进行加密。调用 `wx.login` 重新登录，会刷新 `session_key`，这时后端服务从开放平台获取到新 `session_key`，但是无法对老 `session_key` 加密过的数据解密，用户信息获取失败
- 在用户信息授权之前先调用 `wx.checkSession` 呢？`wx.checkSession` 检查登录态，并且保证 wx.login 不会刷新 `session_key`，从而让后端服务正确解密数据。但是这里存在一个问题，如果小程序较长时间不用导致 `session_key` 过期，则 `wx.login` 必定会重新生成 `session_key`，从而再一次导致用户信息解密失败

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_9-性能优化)9 性能优化

> 我们知道`view`部分是运行在`webview`上的，所以前端领域的大多数优化方式都有用

**加载优化**

![img](https://user-images.githubusercontent.com/2350193/44184904-d8624600-a143-11e8-8ab9-c932573bd243.png)

> 代码包的大小是最直接影响小程序加载启动速度的因素。代码包越大不仅下载速度时间长，业务代码注入时间也会变长。所以最好的优化方式就是减少代码包的大小

小程序加载的三个阶段的表示

![img](https://user-images.githubusercontent.com/2350193/44184987-4c9ce980-a144-11e8-9f28-764209b37341.png)

**优化方式**

- 代码压缩。
- 及时清理无用代码和资源文件。
- 减少代码包中的图片等资源文件的大小和数量。
- 分包加载。

**首屏加载的体验优化建议**

- 提前请求: 异步数据请求不需要等待页面渲染完成。
- 利用缓存: 利用 `storage API` 对异步请求数据进行缓存，二次启动时先利用缓存数据渲染页面，在进行后台更新。
- 避免白屏：先展示页面骨架页和基础内容。
- 及时反馈：即时地对需要用户等待的交互操作给出反馈，避免用户以为小程序无响应

**使用分包加载优化**

![img](https://user-images.githubusercontent.com/2350193/44185607-2298f680-a147-11e8-8440-24ca42033623.png)

- 在构建小程序分包项目时，构建会输出一个或多个功能的分包，其中每个分包小程序必定含有一个主包，所谓的主包，即放置默认启动页面/`TabBar` 页面，以及一些所有分包都需用到公共资源/`JS` 脚本，而分包则是根据开发者的配置进行划分
- 在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。

**优点**：

- 对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务
- 对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能

**限制**

- 整个小程序所有分包大小不超过 `8M`
- 单个分包/主包大小不能超过 `2M`
- 原生分包加载的配置 假设支持分包的小程序目录结构如下

```text
├── app.js
├── app.json
├── app.wxss
├── packageA
│   └── pages
│       ├── cat
│       └── dog
├── packageB
│   └── pages
│       ├── apple
│       └── banana
├── pages
│   ├── index
│   └── logs
└── utils
```

> 开发者通过在 `app.json` `subPackages` 字段声明项目分包结构

```js
{
  "pages":[
    "pages/index",
    "pages/logs"
  ],
  "subPackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat",
        "pages/dog"
      ]
    }, {
      "root": "packageB",
      "pages": [
        "pages/apple",
        "pages/banana"
      ]
    }
  ]
}
```

**分包原则**

- 声明 `subPackages` 后，将按 `subPackages` 配置路径进行打包，`subPackages` 配置路径外的目录将被打包到 `app`（主包） 中
- `app`（主包）也可以有自己的 `pages`（即最外层的 `pages` 字段
- `subPackage` 的根目录不能是另外一个 `subPackage` 内的子目录
- 首页的 `TAB`页面必须在 `app`（主包）内

**引用原则**

- ``packageA`无法`require packageB JS `文件，但可以`require app`、自己`package`内的`JS` 文件
- ``packageA`无法`import packageB`的`template`，但可以`require app`、自己`package`内的`template`
- ``packageA `无法使用`packageB`的资源，但可以使用`app`、自己`package` 内的资源

> 官方即将推出 分包预加载

![img](https://user-images.githubusercontent.com/2350193/44185655-63910b00-a147-11e8-9987-40f235ae08e9.png)

独立分包

![img](https://user-images.githubusercontent.com/2350193/44185690-96d39a00-a147-11e8-9647-bd1cbc017f5a.png)

**渲染性能优化**

![img](https://user-images.githubusercontent.com/2350193/44185879-af907f80-a148-11e8-8dcb-22aadd4e49a6.png)

- 每次 `setData` 的调用都是一次进程间通信过程，通信开销与 `setData` 的数据量正相关。
- `setData` 会引发视图层页面内容的更新，这一耗时操作一定时间中会阻塞用户交互。
- `setData` 是小程序开发使用最频繁，也是最容易引发性能问题的

**避免不当使用 setData**

- 使用 `data` 在方法间共享数据，可能增加 `setData`传输的数据量。。`data` 应仅包括与页面渲染相关的数据。
- 使用 `setData` 传输大量数据，通讯耗时与数据正相关，页面更新延迟可能造成页面更新开销增加。仅传输页面中发生变化的数据，使用 `setData` 的特殊 `key`实现局部更新。
- 短时间内频繁调用 `setData`，操作卡顿，交互延迟，阻塞通信，页面渲染延迟。避免不必要的 `setData`，对连续的`setData`调用进行合并。
- 在后台页面进行 `setData`，抢占前台页面的渲染资源。页面切入后台后的 `setData` 调用，延迟到页面重新展示时执行。

![img](https://user-images.githubusercontent.com/2350193/44186238-db146980-a14a-11e8-8096-bcb8fa6d28b2.png)

**避免不当使用onPageScroll**

- 只在有必要的时候监听 `pageScroll` 事件。不监听，则不会派发。
- 避免在 `onPageScroll` 中执行复杂逻辑
- 避免在 `onPageScroll` 中频繁调用 `setData`
- 避免滑动时频繁查询节点信息（`SelectQuery`）用以判断是否显示，部分场景建议使用节点布局橡胶状态监听（`inersectionObserver`）替代

**使用自定义组件**

> 在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其他部分内容复杂性影响

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_10-wepy-vs-mpvue)10 wepy vs mpvue

**数据流管理**

> 相比传统的小程序框架，这个一直是我们作为资深开发者比较期望去解决的，在 `Web` 开发中，随着 `Flux`、`Redu`x、`Vuex` 等多个数据流工具出现，我们也期望在业务复杂的小程序中使用

- `WePY` 默认支持 `Redux`，在脚手架生成项目的时候可以内置
- `Mpvue` 作为 `Vue` 的移植版本，当然支持 `Vuex`，同样在脚手架生成项目的时候可以内置

**组件化**

- `WePY` 类似 `Vue`实现了单文件组件，最大的差别是文件后缀 `.wpy`，只是写法上会有差异

```js
export default class Index extends wepy.page {}
```

- `Mpvue` 作为 `Vue` 的移植版本，支持单文件组件，`template`、`script` 和 `style` 都在一个 `.vue` 文件中，和 `vue` 的写法类似，所以对 `Vue` 开发熟悉的同学会比较适应

**工程化**

> 所有的小程序开发依赖官方提供的开发者工具。开发者工具简单直观，对调试小程序很有帮助，现在也支持腾讯云（目前我们还没有使用，但是对新的一些开发者还是有帮助的），可以申请测试报告查看小程序在真实的移动设备上运行性能和运行效果，但是它本身没有类似前端工程化中的概念和工具

- `wepy` 内置了构建，通过 `wepy init` 命令初始化项目，大致流程如下：
  - `wepy-cli` 会判断模版是在远程仓库还是在本地，如果在本地则会立即跳到第 `3` 步，反之继续进行。
  - 会从远程仓库下载模版，并保存到本地。
  - 询问开发者 `Project name` 等问题，依据开发者的回答，创建项目
- `mpvue` 沿用了 `vue` 中推崇的 `webpack`作为构建工具，但同时提供了一些自己的插件以及配置文件的一些修改，比如
  - 不再需要 `html-webpack-plugin`
  - 基于 `webpack-dev-middleware` 修改成 `webpack-dev-middleware-hard-disk`
  - 最大的变化是基于 `webpack-loader` 修改成 `mpvue-loader`
  - 但是配置方式还是类似，分环境配置文件，最终都会编译成小程序支持的目录结构和文件后缀

## [#](http://interview.poetries.top/excellent-docs/11-小程序模块.html#_11-mpvue)11 mpvue

mpvue

`Vue.js` 小程序版, `fork` 自 `vuejs/vue@2.4.1`，保留了 `vue runtime` 能力，添加了小程序平台的支持。 `mpvue` 是一个使用 `Vue.js` 开发小程序的前端框架。框架基于 `Vue.js` 核心，`mpvue` 修改了 `Vue.js` 的 `runtime` 和 `compiler` 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 `Vue.js` 开发体验

**框架原理**

> 两个大方向

- 通过`mpvue`提供 `mp` 的 `runtime` 适配小程序
- 通过`mpvue-loader`产出微信小程序所需要的文件结构和模块内容

> 七个具体问题

- 要了解 `mpvue` 原理必然要了解 `Vue` 原理，这是大前提

现在假设您对 Vue 原理有个大概的了解

- 由于 `Vue` 使用了 `Virtual DOM`，所以 `Virtual DOM`可以在任何支持 `JavaScript` 语言的平台上操作，譬如说目前 `Vue` 支持浏览器平台或 `weex`，也可以是 `mp`(小程序)。那么最后 `Virtual DOM` 如何映射到真实的 `DOM`节点上呢？`vue`为平台做了一层适配层，浏览器平台见 `runtime/node-ops.js`、`weex`平台见`runtime/node-ops.js`，小程序见`runtime/node-ops.js`。不同平台之间通过适配层对外提供相同的接口，`Virtual DOM`进行操作`Real DOM`节点的时候，只需要调用这些适配层的接口即可，而内部实现则不需要关心，它会根据平台的改变而改变
- 所以思路肯定是往增加一个 `mp` 平台的 `runtime`方向走。但问题是小程序不能操作 `DOM`，所以 `mp` 下的`node-ops.js`里面的实现都是直接 `return obj`
- 新 `Virtual DOM` 和旧 `Virtual DOM` 之间需要做一个 `patch`，找出 `diff`。`patch`完了之后的 `diff` 怎么更新视图，也就是如何给这些 `DOM` 加入 `attr`、`class`、`style`等 DOM 属性呢？ `Vue`中有 `nextTick` 的概念用以更新视图，`mpvue`这块对于小程序的 `setData` 应该怎么处理呢？
- 另外个问题在于小程序的 `Virtual DOM` 怎么生成？也就是怎么将 `template`编译成`render function`。这当中还涉及到运行时-编译器-vs-只包含运行时，显然如果要提高性能、减少包大小、输出 `wxml`、`mpvue` 也要提供预编译的能力。因为要预输出 `wxml` 且没法动态改变 `DOM`，所以动态组件，自定义 `render`，和`<script type="text/x-template">`字符串模版等都不支持

**另外还有一些其他问题，最后总结一下**

- 1.如何预编译生成`render function`
- 2.如何预编译生成 `wxml`，`wxss`，`wxs`
- 3.如何 p`atch` 出 `diff`
- 4.如何更新视图
- 5.如何建立小程序事件代理机制，在事件代理函数中触发与之对应的`vue`组件事件响应
- 6.如何建立`vue`实例与小程序 `Page`实例关联
- 7.如何建立小程序和`vue`生命周期映射关系，能在小程序生命周期中触发`vue`生命周期

> `platform/mp`的目录结构

```text
.
├── compiler //解决问题1，mpvue-template-compiler源码部分
├── runtime //解决问题3 4 5 6 7
├── util //工具方法
├── entry-compiler.js //mpvue-template-compiler的入口。package.json相关命令会自动生成mpvue-template-compiler这个package。
├── entry-runtime.js //对外提供Vue对象，当然是mpvue
└── join-code-in-build.js //编译出SDK时的修复
```

**mpvue-loader**

> ```
> mpvue-loader` 是 `vue-loader` 的一个扩展延伸版，类似于超集的关系，除了`vue-loader` 本身所具备的能力之外，它还会利用`mpvue-template-compiler`生成`render function
> ```

**entry**

- 它会从 `webpack` 的配置中的 `entry` 开始，分析依赖模块，并分别打包。在`entry` 中 `app` 属性及其内容会被打包为微信小程序所需要的 `app.js／app.json／app.wxss`，其余的会生成对应的
- 页面`page.js`/`page.json`/`page.wxml`/`page.wxss`，如示例的 `entry` 将会生成如下这些文件，文件内容下文慢慢讲来：

```js
// webpack.config.js
{
    // ...
    entry: {
        app: resolve('./src/main.js'),               // app 字段被识别为 app 类型
        index: resolve('./src/pages/index/main.js'),   // 其余字段被识别为 page 类型
        'news/home': resolve('./src/pages/news/home/index.js')
    }
}

// 产出文件的结构
.
├── app.js
├── app.json
├──· app.wxss
├── components
│   ├── card$74bfae61.wxml
│   ├── index$023eef02.wxml
│   └── news$0699930b.wxml
├── news
│   ├── home.js
│   ├── home.wxml
│   └── home.wxss
├── pages
│   └── index
│       ├── index.js
│       ├── index.wxml
│       └── index.wxss
└── static
    ├── css
    │   ├── app.wxss
    │   ├── index.wxss
    │   └── news
    │       └── home.wxss
    └── js
        ├── app.js
        ├── index.js
        ├── manifest.js
        ├── news
        │   └── home.js
        └── vendor.js
```

> `wxml` 每一个 `.vue` 的组件都会被生成为一个 `wxml` 规范的 `template`，然后通过 `wxml` 规范的 `import` 语法来达到一个复用，同时组件如果涉及到 `props`的 `data` 数据，我们也会做相应的处理，举个实际的例子：

```vue
<template>
    <div class="my-component" @click="test">
        <h1>{{msg}}</h1>
        <other-component :msg="msg"></other-component>
    </div>
</template>
<script>
import otherComponent from './otherComponent.vue'

export default {
  components: { otherComponent },
  data () {
    return { msg: 'Hello Vue.js!' }
  },
  methods: {
    test() {}
  }
}
</script>
```

> 这样一个 `Vue`的组件的模版部分会生成相应的 `wxml`

```html
<import src="components/other-component$hash.wxml" />
<template name="component$hash">
    <view class="my-component" bindtap="handleProxy">
        <view class="_h1">{{msg}}</view>
        <template is="other-component$hash" wx:if="{{ $c[0] }}" data="{{ ...$c[0] }}"></template>
    </view>
</template>
```

> 可能已经注意到了 `other-component(:msg="msg")` 被转化成了 。`mpvue` 在运行时会从根组件开始把所有的组件实例数据合并成一个树形的数据，然后通过 `setData` 到 `appData`,`$c`是 `$children` 的缩写。至于那个 `0` 则是我们的 `compiler`处理过后的一个标记，会为每一个子组件打一个特定的不重复的标记。 树形数据结构如下

```js
// 这儿数据结构是一个数组，index 是动态的
{
  $child: {
    '0'{
      // ... root data
      $child: {
        '0': {
          // ... data
          msg: 'Hello Vue.js!',
          $child: {
            // ...data
          }
        }
      }
    }
  }
}
```

**wxss**

> 这个部分的处理同 `web` 的处理差异不大，唯一不同在于通过配置生成 `.css` 为 `.wxss` ，其中的对于 `css`的若干处理，在 `postcss-mpvue-wxss` 和 `px2rpx-loader` 这两部分的文档中又详细的介绍

- 推荐和小程序一样，将 `app.json／page.json` 放到页面入口处，使用 `copy-webpack-plugin` `copy` 到对应的生成位置。

> 这部分内容来源于 `app` 和`page` 的`entry` 文件，通常习惯是 `main.js`，你需要在你的入口文件中 `export default { config: {} }`，这才能被我们的 `loader` 识别为这是一个配置，需要写成 `json` 文件

```js
import Vue from 'vue';
import App from './app';

const vueApp = new Vue(App);
vueApp.$mount();

// 这个是我们约定的额外的配置
export default {
    // 这个字段下的数据会被填充到 app.json ／ page.json
    config: {
        pages: ['static/calendar/calendar', '^pages/list/list'], // Will be filled in webpack
        window: {
            backgroundTextStyle: 'light',
            navigationBarBackgroundColor: '##455A73',
            navigationBarTitleText: '美团汽车票',
            navigationBarTextStyle: '##fff'
        }
    }
};
```



# 12 前端安全模块

## 1 代码注入XSS

> 跨网站指令码（英语：`Cross-site scripting`，通常简称为：`XSS`）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 `HTML` 以及使用者端脚本语言

> ```
> XSS` 分为三种：反射型，存储型和 `DOM-based
> ```

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_1-1-如何攻击)1.1 如何攻击

- `XSS` 通过修改 `HTML`节点或者执行 `JS`代码来攻击网站。
- 例如通过 `URL` 获取某些参数

```html
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>    
```

> 上述 `URL` 输入可能会将 `HTML` 改为 `<div><script>alert(1)</script></div>` ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 `DOM-based` 攻击

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_1-2-如何防御)1.2 如何防御

> 最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义

```js
function escape(str) {
	str = str.replace(/&/g, "&amp;");
	str = str.replace(/</g, "&lt;");
	str = str.replace(/>/g, "&gt;");
	str = str.replace(/"/g, "&quto;");
	str = str.replace(/'/g, "&##39;");
	str = str.replace(/`/g, "&##96;");
    str = str.replace(/\//g, "&##x2F;");
    return str
}
```

> 通过转义可以将攻击代码 `<script>alert(1)</script>` 变成

```js
// -> &lt;script&gt;alert(1)&lt;&##x2F;script&gt;
escape('<script>alert(1)</script>')
```

> 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式

```js
var xss = require("xss");
var html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>');
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html);
```

> 以上示例使用了 `js-xss`来实现。可以看到在输出中保留了 `h1` 标签且过滤了 `script` 标签

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_1-3-cookie-如何防范-xss-攻击)1.3 cookie 如何防范 XSS 攻击

> XSS(跨站脚本攻击)是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些 攻击，需要在 HTTP 头部配上，set-cookie

- `httpOnly` 这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 `cookie`
- `secure`- 这个属性告诉浏览器仅在请求为 `https` 的时候发送 `cookie`

## [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_2-跨站请求伪造csrf)2 跨站请求伪造CSRF

> - `CSRF` 就是利用用户的登录态发起恶意请求
> - `CSRF（Cross-site request forgery）` 跨站请求伪造，是一种常见的攻击方式。是指 `A` 网站正常登陆后，`cookie` 正常保存登录信息，其他网站 B 通过某种方式调用 A 网站接口进行操作，`A` 的接口会在请求时会自动带上 `cookie`。

- 同源策略可以通过 `html` 标签加载资源，而且同源策略不阻止接口请求而是拦截请求结果，`CSRF` 恰恰占了这两个便宜。
- 对于 `GET` 请求，直接放到 `<img>` 就能神不知鬼不觉地请求跨域接口。
- 对于 `POST` 请求，很多例子都使用 `form` 提交：

```html
<form action="<nowiki>http://bank.com/transfer.do</nowiki>" method="POST">
  <input type="hidden" name="acct" value="MARIA" />
  <input type="hidden" name="amount" value="100000" />
  <input type="submit" value="View my pictures" />
</form>
```

> **浏览器同源策略不能作为防范 CSRF 的方法** 浏览器允许这么做，归根到底就是因为**你无法用 js 直接操作获得的结果。**

**如何攻击**

> 假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口

```text
<img src="http://www.domain.com/xxx?comment='attack'"/>
```

![img](http://img-repo.poetries.top/images/20210506174602.png)

```js
res.setHeader('Set-Cookie', `username=poetry2;sameSite = strict;path=/;httpOnly;expires=${getCookirExpires()}`)
```

> 在B网站，危险网站向A网站发起请求

```html
<!DOCTYPE html>
<html>
  <body>
  <!-- 利用img自动发送请求 -->
    <img src="http://localhost:8000/api/user/login" />
  </body>
</html>
```

会带上A网站的cookie

![img](http://img-repo.poetries.top/images/20210506174856.png)

```js
// 在A网站下发cookie的时候，加上sameSite=strict，这样B网站在发送A网站请求，不会自动带上A网站的cookie，保证了安全


// NAME=VALUE    赋予Cookie的名称及对应值
// expires=DATE  Cookie 的有效期
// path=PATH     赋予Cookie的名称及对应值
// domain=域名   作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） (一般不指定)
// Secure        仅在 HTTPS 安全通信时才会发送 Cookie
// HttpOnly      加以限制，使 Cookie 不能被 JavaScript 脚本访问
// SameSite      Lax|Strict|None  它允许您声明该Cookie是否仅限于第一方或者同一站点上下文

res.setHeader('Set-Cookie', `username=poetry;sameSite=strict;path=/;httpOnly;expires=${getCookirExpires()}`)
```

![img](http://img-repo.poetries.top/images/20210506175834.png)

**如何防御**

- `Get` 请求不对数据进行修改
- 不让第三方网站访问到用户 `Cookie`
- 阻止第三方网站请求接口
- 请求时附带验证信息，比如验证码或者 `token`
- `SameSite Cookies`: 只能当前域名的网站发出的http请求，携带这个`Cookie`。当然，由于这是新的cookie属性，在兼容性上肯定会有问题

> CSRF攻击，仅仅是利用了http携带cookie的特性进行攻击的，但是攻击站点还是无法得到被攻击站点的cookie。这个和XSS不同，XSS是直接通过拿到Cookie等信息进行攻击的

**在CSRF攻击中，就Cookie相关的特性：**

- http请求，会自动携带Cookie。
- 携带的cookie，还是http请求所在域名的cookie。

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#csrf怎么获取用户的登录态)CSRF怎么获取用户的登录态

> 攻击全称不需要获取cookie，只是在危险的网站欺骗用户去点击已登录的网站链接，利用已登录的网站的自动发送cookie达到目的。因为http请求都会带着请求目标域下的`cookie`的，向同一个服务器发请求时会带上浏览器保存的对于那个服务器的cookie，而不管你从哪个网站向目标网站发请求

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#cookie通常是不能跨域访问的-那问什么会有csrf攻击)cookie通常是不能跨域访问的，那问什么会有csrf攻击

**疑问：**

> csrf说用户访问了A网站，然后又访问恶意网站B, B中也发送请求到A，携带A站的cookie，这样就构成了csrf。 可是cookie好像是不支持跨域的吧？

**回答**

- 浏览器会依据加载的域名附带上对应域名`cookie`，又不是发送b站的`cookie`。
- 就是如果用户在`a`站登录了生成了授权的`cookie` 之类的，然后访问`b`站，b站故意构造请求a站的请求，如删除操作之类的，用`script`，`img`或者`iframe`之类的加载`a`站着个地址，浏览器会附带上`a`站此登录用户的授权`cookie`信息，这样就构成`crsf`，会删除掉当前用户的数据

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#总结)总结

- ```
  XSS
  ```

  攻击: 注入恶意代码

  - `cookie` 设置 `httpOnly`
  - 转义页面上的输入内容和输出内容

- ```
  CSRF
  ```

  : 跨站请求伪造，防护:

  - `get`不修改数据
  - 不被第三方网站访问到用户的 `cookie`
  - 设置白名单，不被第三方网站请求
  - 请求校验

## [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_3-浏览器同源策略-sop)3 浏览器同源策略 SOP

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_3-1-同源)3.1 同源

> 先解释何为同源：协议、域名、端口都一样，就是同源。

| url                                                          | 同源 |
| ------------------------------------------------------------ | ---- |
| [https://niconico.com(opens new window)](https://niconico.com/) | 基准 |
| https://niconico.com/spirit                                  | o    |
| https://sub.niconico.com/spirit                              | x    |
| http://niconico.com/spirit                                   | x    |
| https://niconico.com:8080/spirit                             | x    |

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_3-2-限制)3.2 限制

- 你之所以会遇到 **跨域问题**，正是因为 SOP 的各种限制。但是具体来说限制了什么呢？
- 如果你说 SOP 就是“限制非同源资源的获取”，这不对，最简单的例子是引用图片、css、js 文件等资源的时候就允许跨域。
- 如果你说 SOP 就是“禁止跨域请求”，这也不对，本质上 SOP 并不是禁止跨域请求，而是在请求后拦截了请求的回应。

**其实表面上 SOP 分两种情况：**

- 可以正常引用 iframe、图片等各种资源，**但是**限制对其内容进行操作
- 直接限制 ajax 请求，准确来说是**限制操作 ajax 响应结果**，**这会引起后面说到的 CSRF**

> 但是，本质上这两条是一样的：总之，对于非同源的资源，浏览器可以“直接使用”，但是程序员和用户不可以对这些数据进行操作，杜绝某些居心不良的行为。这就是现代安全浏览器对用户的保护之一。

**下面是 3 个在实际应用中会遇到的例子：**

- 使用 ajax 请求其他跨域 API，最常见的情况，前端新手噩梦
- iframe 与父页面交流（如 DOM 或变量的获取），出现率比较低，而且解决方法也好懂
- 对跨域图片（例如来源于 `<img>` ）进行操作，在 canvas 操作图片的时候会遇到这个问题

**如果没有了 SOP：**

- `iframe` 里的机密信息被肆意读取
- 更加肆意地进行 `CSRF`
- 接口被第三方滥用

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_3-3-绕过跨域)3.3 绕过跨域

> `SOP` 虽然让用户更安全，同时也会对程序员带来一定程度的麻烦，因为有时候业务上就是有跨域的需求。绕过跨域的方案由于篇幅所限，并且网上也很多相关文章，所以不在这里展开解决跨域的方案，只给出几个关键词：

**对于 ajax**

- 使用 `JSONP`
- 后端进行 `CORS` 配置
- 后端反向代理
- 使用 `WebSocket`

**对于 iframe**

- 使用 `location.hash` 或 `window.name` 进行信息交流
- 使用 `postMessage`

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_3-4-浏览器同源策略与ajax)3.4 浏览器同源策略与ajax

> 对于 ajax 请求，在获得数据之后你能肆意进行 js 操作。这时候虽然同源策略会阻止响应，但依然会发出请求。因为**执行响应拦截的是浏览器**而不是后端程序。事实上你的**请求已经发到服务器**并返回了结果，但是迫于安全策略，浏览器不允许你**继续进行 js 操作**，所以报出你熟悉的 `blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.`。

**所以再强调一次，同源策略不能作为防范 CSRF 的方法**。

不过**可以防范 CSRF 的例外**还是有的，浏览器并不是让所有请求都发送成功，上述情况仅限于**简单请求**，相关知识会在下面 CORS 一节详细解释。

## [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_4-跨域资源共享-cors)4 跨域资源共享 CORS

跨域是浏览器限制，跨域资源共享（Cross-origin resource sharing）也是服务器与浏览器协调的结果。

> 如果服务器设置了 CORS 相关配置，在返回浏览器的请求头会加上 `Access-Control-Allow-Origin`，浏览器看到这个字段的值与当前的源匹配，就会解锁跨域限制。

```text
HTTP/1.1 200 OK
Date: Sun, 24 Apr 2016 12:43:39 GMT
Server: Apache
Access-Control-Allow-Origin: http://www.acceptmeplease.com
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: application/xml
Content-Length: 423
```

对于 CORS，请求分两种。

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_4-1-简单请求)4.1 简单请求

- 请求方法使用 `GET`、`POST` 或 `HEAD`
- `Content-Type` 设为 `application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`

符合上面两个条件的都为 `CORS` 简单请求。简单请求都会直接发到服务器，会造成 `CSRF`。

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_4-2-预检请求)4.2 预检请求

> 不符合简单请求要求的请求都需要先发送预检请求（Preflight Request）。浏览器会在真正请求前发送 OPTION 方法的请求向服务器询问当前源是否符合 CORS 目标，验证通过后才会发送正式请求。

例如**使用 application/json 传参的 POST 请求**就是非简单请求，会在预检中被拦截。

再例如使用 `PUT` 方法请求，也会发送预检请求。

上面提到的**可以防范 CSRF 的例外**，就是指预检请求。即使跨域成功请求预检，但真正请求并不能发出去，这就保证了 `CSRF` 无法成功。

### [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_4-3-cors-与-cookie)4.3 CORS 与 cookie

- 与同域不同，用于跨域的 `CORS` 请求默认不发送 `Cookie` 和 `HTTP` 认证信息，前后端都要在配置中设定请求时带上 `cookie`。
- 这就是为什么在进行 `CORS` 请求时 `axios` 需要设置 `withCredentials: true`。

下面是 `node.js` 的后台 `koa` 框架的 CORS 设置：

```text
/**
 * CORS middleware
 *
 * @param {Object} [options]
 *  - {String|Function(ctx)} origin `Access-Control-Allow-Origin`, default is request Origin header
 *  - {String|Array} allowMethods `Access-Control-Allow-Methods`, default is 'GET,HEAD,PUT,POST,DELETE,PATCH'
 *  - {String|Array} exposeHeaders `Access-Control-Expose-Headers`
 *  - {String|Array} allowHeaders `Access-Control-Allow-Headers`
 *  - {String|Number} maxAge `Access-Control-Max-Age` in seconds
 *  - {Boolean} credentials `Access-Control-Allow-Credentials`
 *  - {Boolean} keepHeadersOnError Add set headers to `err.header` if an error is thrown
 * @return {Function} cors middleware
 * @api public
 */
```

> 顺带一提，`Access-Control-Allow-Credentials` 设为 `true` 时，`Access-Control-Allow-Origin` 强制不能设为 `*`，为了安全，也是挺麻烦

## [#](http://interview.poetries.top/excellent-docs/12-前端安全模块.html#_5-密码安全)5 密码安全

**加盐**

> 对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系

- 通常需要对密码加盐，然后进行几次不同加密算法的加密

```js
// 加盐也就是给原密码添加字符串，增加原密码长度
sha256(sha1(md5(salt + password + salt)))
```

> 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误

**前端加密**

> 虽然前端加密对于安全防护来说意义不大，但是在遇到中间人攻击的情况下，可以避免明文密码被第三方获取

# 13 性能优化相关

## 1 性能优化方式

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_1-1-dns-预解析)1.1 DNS 预解析

- `DNS` 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 `IP`

```html
<link rel="dns-prefetch" href="//blog.poetries.top">
```

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_1-2-缓存)1.2 缓存

- 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度
- 通常浏览器缓存策略分为两种：强缓存和协商缓存

**强缓存**

> 实现强缓存可以通过两种响应头实现：`Expires`和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code`为 `200`

```text
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

> `Expires` 是 `HTTP / 1.0` 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效

```text
Cache-control: max-age=30
```

> `Cache-Control` 出现于 `HTTP / 1.1`，优先级高于 `Expires` 。该属性表示资源会在 `30` 秒后过期，需要再次请求

**协商缓存**

- 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304
- 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式

```
Last-Modified` 和 `If-Modified-Since
```

- `Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified`的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来
- 但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 `HTTP / 1.1` 出现了 `ETag`

```
ETag` 和 `If-None-Match
```

- `ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高

**选择合适的缓存策略**

> 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_1-3-使用-http-2-0)1.3 使用 HTTP / 2.0

- 因为浏览器会有并发请求限制，在 `HTTP / 1.1` 时代，每个请求都需要建立和断开，消耗了好几个 `RTT` 时间，并且由于 `TCP` 慢启动的原因，加载体积大的文件会需要更多的时间
- 在 `HTTP / 2.0` 中引入了多路复用，能够让多个请求使用同一个 `TCP` 链接，极大的加快了网页的加载速度。并且还支持 `Header` 压缩，进一步的减少了请求的数据大小

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_1-4-预加载)1.4 预加载

- 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载
- 预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com">
```

> 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_1-5-预渲染)1.5 预渲染

> 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://poetries.com">
```

- 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_1-6-懒执行与懒加载)1.6 懒执行与懒加载

**懒执行**

- 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒

**懒加载**

- 懒加载就是将不关键的资源延后加载

> 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载

- 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_1-7-文件优化)1.7 文件优化

**图片优化**

> 对于如何优化图片，有 2 个思路

- 减少像素点
- 减少每个像素点能够显示的颜色

**图片加载优化**

- 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 `CSS` 去代替。
- 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片
- 小图使用 `base64`格式
- 将多个图标文件整合到一张图片中（雪碧图）
- 选择正确的图片格式：
  - 对于能够显示 `WebP` 格式的浏览器尽量使用 `WebP` 格式。因为 `WebP` 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
  - 小图使用 `PNG`，其实对于大部分图标这类图片，完全可以使用 `SVG` 代替
  - 照片使用 `JPEG`

**其他文件优化**

- `CSS`文件放在 `head` 中
- 服务端开启文件压缩功能
- 将 `script` 标签放在 `body` 底部，因为 `JS` 文件执行会阻塞渲染。当然也可以把 `script` 标签放在任意位置然后加上 `defer` ，表示该文件会并行下载，但是会放到 `HTML` 解析完成后顺序执行。对于没有任何依赖的 `JS`文件可以加上 `async` ，表示加载和渲染后续文档元素的过程将和 `JS` 文件的加载与执行并行无序进行。 执行 `JS`代码过长会卡住渲染，对于需要很多时间计算的代码
- 可以考虑使用 `Webworker`。`Webworker`可以让我们另开一个线程执行脚本而不影响渲染。

**CDN**

> 静态资源尽量使用 `CDN` 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 `CDN` 域名。对于 `CDN` 加载静态资源需要注意 `CDN` 域名要与主站不同，否则每次请求都会带上主站的 `Cookie`

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_1-8-其他)1.8 其他

**使用 Webpack 优化项目**

- 对于 `Webpack4`，打包项目使用 `production` 模式，这样会自动开启代码压缩
- 使用 `ES6` 模块来开启 `tree shaking`，这个技术可以移除没有使用的代码
- 优化图片，对于小图可以使用 `base64` 的方式写入文件中
- 按照路由拆分代码，实现按需加载
- 给打包出来的文件名添加哈希，实现浏览器缓存文件

**监控**

> 对于代码运行错误，通常的办法是使用 `window.onerror` 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外

- 对于跨域的代码运行错误会显示 `Script error`. 对于这种情况我们需要给 `script` 标签添加 `crossorigin` 属性
- 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 `arguments.callee.caller` 来做栈递归
- 对于异步代码来说，可以使用 `catch` 的方式捕获错误。比如 `Promise` 可以直接使用 catch 函数，`async await` 可以使用 `try catch`
- 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 `sourceMap` 文件便于 `debug`。
- 对于捕获的错误需要上传给服务器，通常可以通过 `img` 标签的 `src`发起一个请求

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_2-首屏渲染优化)2 首屏渲染优化

- css / js 分割，使首屏依赖的文件体积最小，内联首屏关键 css / js；

- 非关键性的文件尽可能的 异步加载和懒加载，避免阻塞首页渲染；

- 使用dns-prefetch / preconnect / prefetch / preload等浏览器提供的资源提示，加快文件传输；

- 谨慎控制好 Web字体，一个大字体包足够让你功亏一篑

  - 控制字体包的加载时机；
  - 如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积； 合理利用 Localstorage / server-worker 等存储方式进行 数据与资源缓存

- 分清轻重缓急

  - 重要的元素优先渲染；
  - 视窗内的元素优先渲染

- 服务端渲染(SSR)

  :

  - 减少首屏需要的数据量，剔除冗余数据和请求；
  - 控制好缓存，对数据/页面进行合理的缓存；
  - 页面的请求使用流的形式进行传递；

- 优化用户感知

  - 利用一些动画 过渡效果，能有效减少用户对卡顿的感知；
  - 尽可能利用 骨架屏(Placeholder) / Loading 等减少用户对白屏的感知；
  - 动画帧数尽量保证在 30帧 以上，低帧数、卡顿的动画宁愿不要；
  - js 执行时间避免超过 100ms，超过的话就需要做
    - 寻找可 缓存 的点
    - 任务的 分割异步 或 web worker 执行

**移动端的性能优化**

1. 首屏加载和按需加载，懒加载
2. 资源预加载
3. 图片压缩处理，使用`base64`内嵌图片
4. 合理缓存dom对象
5. 使用`touchstart`代替`click`（`click 300`毫秒的延迟）
6. 利用`transform:translateZ(0)`，开启硬件GUP加速
7. 不滥用web字体，不滥用`float`（布局计算消耗性能），减少`font-size`声明
8. 使用`viewport`固定屏幕渲染，加速页面渲染内容
9. 尽量使用事件代理，避免直接事件绑定

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_3-页面基础优化)3 页面基础优化

- 引入位置: css 文件

  ```
  <head>
  ```

  中引入， js 文件

  ```
  <body>
  ```

  底部引入

  - 影响首屏的，优先级很高的 js 也可以头部引入，甚至内联

- **减少请求** (http 1.0 - 1.1)，合并请求，正确设置 http 缓存

- 减少文件体积

  - 删除多余代码:
    - tree-shaking
    - UglifyJs
    - code-spliting
  - 混淆 / 压缩代码，开启 gzip 压缩；
  - 多份编译文件按条件引入
    - 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件
    - 可以利用`<script type="module"> / <script type="module">`进行条件引入用
  - 动态 `polyfill`，只针对不支持的浏览器引入 `polyfill；`

- 图片优化:

  - 根据业务场景，与UI探讨选择 合适质量，合适尺寸；
  - 根据需求和平台，选择 合适格式，例如非透明时可用 jpg；非苹果端，使用 webp；
  - 小图片合成 雪碧图，低于 5K 的图片可以转换成 base64 内嵌
  - 合适场景下，使用 `iconfont` 或者 `svg`；

- 使用缓存

  - **浏览器缓存**: 通过设置请求的过期时间，合理运用浏览器缓存；

  - CDN缓存

    : 静态文件合理使用 CDN 缓存技术

    - HTML 放于自己的服务器上；
    - 打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
    - 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；

  - **服务器缓存**: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上

  - **数据缓存**: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_4-性能优化方向)4 性能优化方向

> 前端性能优化分为两个方向，一是工程化方向，另一个是细节方向

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_4-1-工程化方向)4.1 工程化方向

- 客户端Gzip离线包，服务器资源Gzip压缩。
- JS瘦身，`Tree shaking`，`ES Module`，动态`Import`，动态`Polyfill`
- 图片加载优化，`Webp`，考虑兼容性，可以提前加载一张图片，嗅探是否支持`Webp`
- 服务端渲染，客户端预渲染
- CDN静态资源
- `Webpack Dll`，通用优先打包抽离，利用浏览器缓存
- 骨架图
- 数据预取，包括接口数据，和加载详情页图片
- Webpack本身提供的优化，Base64，资源压缩，Tree shaking，拆包chunk
- 减少重定向

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_4-2-细节方向)4.2 细节方向

- 图片，图片占位，图片懒加载。 雪碧图

- 使用

   

  ```
  prefetch / preload
  ```

   

  预加载等新特性

  - `Preload` 来告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级。比如，对于那些本来请求优先级较低的关键请求，我们可以通过设置 `Preload` 来提升这些请求的优先级
  - `Prefetch` 来告诉浏览器用户将来可能在其他页面（非本页面）可能使用到的资源，那么浏览器会在空闲时，就去预先加载这些资源放在 `http` 缓存内，最常见的 `dns-prefetch`。比如，当我们在浏览A页面，如果会通过A页面中的链接跳转到B页面，而B页面中我们有些资源希望尽早提前加载，那么我们就可以在A页面里添加这些资源 `Prefetch` ，那么当浏览器空闲时，就会去加载这些资源
  - 所以，对于那些可能在当前页面使用到的资源可以利用 `Preload`，而对一些可能在将来的某些页面中被使用的资源可以利用 `Prefetch`。如果从加载优先级上看，`Preload` 会提升请求优先级；而`Prefetch`会把资源的优先级放在最低，当浏览器空闲时才去预加载

- 服务器合理设置缓存策略

- `async`（加载完当前js立即执行）/ `defer`(所有资源加载完之后执行js)

- 减少Dom的操作，减少重排重绘

- 从客户端层面，首屏减少和客户端交互，合并接口请求

- 数据缓存

- 首页不加载不可视组件

- 防止渲染抖动，控制时序

- 减少组件层级

- 优先使用Flex布局

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_5-长列表优化)5 长列表优化

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#vue-virtual-scroll-list优化长列表)vue-virtual-scroll-list优化长列表

> 虚拟列表的实现原理：只渲染可视区的 dom 节点，其余不可见的数据卷起来，只会渲染可视区域的 dom 节点，提高渲染性能及流畅性，优点是支持海量数据的渲染；

github地址：https://github.com/tangbc/vue-virtual-scroll-list

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#object-freeze优化长列表)Object.freeze优化长列表

- `Object.freeze()`方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。
- 对于`data()`或vuex中冻结的对象，vue不会做`getter`和`setter`的转换。因此对于一个不变的、大数据量的数组或Object数据来说，使用`Object.freeze()`可以有效地提升性能。

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_6-卡顿问题解决)6 卡顿问题解决

- CSS动画效率比JS高，`css`可以用`GPU`加速，`3d`加速。如果非要用JS动画，可以用`requestAnimationFrame`
- 批量进行DOM操作，固定图片容器大小，避免屏幕抖动
- 减少重绘重排
- 节流和防抖
- 减少临时大对象产生，利用对象缓存，主要是减少内存碎片
- 异步操作，`IntersectionObserver`，`PostMessage`，`RequestIdleCallback`

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_7-编码优化)7 编码优化

> 编码优化，指的就是 在代码编写时的，通过一些 最佳实践，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于 程序猿的自我修养，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。

**数据读取:**

- 通过作用域链 / 原型链 读取变量或方法时，需要更多的耗时，且越长越慢
- 对象嵌套越深，读取值也越慢；
- 最佳实践
  - 尽量在局部作用域中进行 变量缓存；
  - 避免嵌套过深的数据结构，数据扁平化 有利于数据的读取和维护

**循环**: 循环通常是编码性能的关键点；

- 代码的性能问题会再循环中被指数倍放大
- 最佳实践
  - 尽可能 减少循环次数
    - 减少遍历的数据量；
    - 完成目的后马上结束循环
  - 避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存；
  - js 中使用 倒序循环 会略微提升性能；
  - 尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环；

**条件流程性能**: Map / Object > switch > if-else

```js
// 使用 if-else
if(type === 1) {

} else if (type === 2) {

} else if (type === 3) {

}

// 使用 switch
switch (type) {
	case 1:
		break;4
	case 2:
		break;
	case 3:
		break;
    default:
        break;
}

// 使用 Map
const map = new Map([
	[1, () => {}],
	[2, () => {}],
	[3, () => {}],
])
map.get(type)()

// 使用 Objext
const obj = {
	1: () => {},
	2: () => {},
	3: () => {},
}
obj[type]()
```

**减少 cookie 体积**: 能有效减少每次请求的体积和响应时间；

- 去除不必要的 `cookie`；
- 压缩 `cookie` 大小；
- 设置 `domain` 与 过期时间；

**dom 优化:**

- 减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；
- 减少重绘与回流:
  - 多次操作合并为一次；
  - 减少对计算属性的访问
    - 例如 offsetTop， getComputedStyle 等
    - 因为浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用；
  - 大量操作时，可将 dom 脱离文档流或者隐藏，待操作完成后再重新恢复；
  - 使用DocumentFragment / cloneNode / replaceChild进行操作；
- 使用事件委托，避免大量的事件绑定；

**css 优化:**

- 层级扁平，避免过于多层级的选择器嵌套；
- 特定的选择器 好过一层一层查找: `.xxx-child-text{}` - 优于 `.xxx .child .text{}`
- 减少使用通配符与属性选择器；
- 减少不必要的多余属性；
- 使用 动画属性实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画；
- 使用 `<link>` 替代原生 `@import`；

**html 优化:**

- 减少 dom 数量，避免不必要的节点或嵌套

- 避免

  ```
  <img src="" />
  ```

  空标签，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求

  - IE 向页面所在的目录发送请求；
  - Safari、Chrome、Firefox 向页面本身发送请求；
  - Opera 不执行任何操作。

- 图片提前 指定宽高 或者 脱离文档流，能有效减少因图片加载导致的页面回流；

- 语义化标签 有利于 SEO 与浏览器的解析时间；

- 减少使用 table 进行布局，避免使用`<br />`与`<hr />`

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_8-如何根据chrome的timing优化)8 如何根据chrome的timing优化

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_8-1-性能优化api)8.1 性能优化API

- `Performance`。`performance.now()`与`new Date()`区别，它是高精度的，且是相对时间，相对于页面加载的那一刻。但是不一定适合单页面场景
- `window.addEventListener("load", "");` `window.addEventListener("domContentLoaded", "");`
- `Img`的`onload`事件，监听首屏内的图片是否加载完成，判断首屏事件
- `RequestFrameAnmation` 和 `RequestIdleCallback`
- `IntersectionObserver`、`MutationObserver`，`PostMessage`
- `Web Worker`，耗时任务放在里面执行

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_8-2-检测工具)8.2 检测工具

- `Chrome Dev Tools`
- `Page Speed`
- `Jspref`

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_8-3-前端指标)8.3 前端指标

![image-20210307184052955](http://img-repo.poetries.top/images/image-20210307184052955.png)

```js
window.onload = function(){
    setTimeout(function(){
        let t = performance.timing
        console.log('DNS查询耗时 ：' + (t.domainLookupEnd - t.domainLookupStart).toFixed(0))
        console.log('TCP链接耗时 ：' + (t.connectEnd - t.connectStart).toFixed(0))
        console.log('request请求耗时 ：' + (t.responseEnd - t.responseStart).toFixed(0))
        console.log('解析dom树耗时 ：' + (t.domComplete - t.domInteractive).toFixed(0))
        console.log('白屏时间 ：' + (t.responseStart - t.navigationStart).toFixed(0))
        console.log('domready时间 ：' + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0))
        console.log('onload时间 ：' + (t.loadEventEnd - t.navigationStart).toFixed(0))

        if(t = performance.memory){
            console.log('js内存使用占比 ：' + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + '%')
        }
    })
}
```

**DNS预解析优化**

> dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化

`DNS Prefetch` 应该尽量的放在网页的前面，推荐放在 后面。具体使用方法如下：

```html
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//www.zhix.net">
<link rel="dns-prefetch" href="//api.share.zhix.net">
<link rel="dns-prefetch" href="//bdimg.share.zhix.net">
```

**request请求耗时**

- 不请求，用cache（最好的方式就是尽量引用公共资源，同时设置缓存，不去重新请求资源，也可以运用PWA的离线缓存技术，可以帮助wep实现离线使用）
- 前端打包时压缩
- 服务器上的zip压缩
- 图片压缩（比如tiny），使用webp等高压缩比格式
- 把过大的包，拆分成多个较少的包，防止单个资源耗时过大
- 同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。如果资源来自于多个域下，可以增大并行请求和下载速度
- 延迟、异步、预加载、懒加载
- 对于非首屏的资源，可以使用 defer 或 async 的方式引入
- 也可以按需加载，在逻辑中，只有执行到时才做请求
- 对于多屏页面，滚动时才动态载入图片

**解析dom树耗时**

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_9-vue性能优化)9 Vue性能优化

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_9-1-vue首屏加载优化有哪些方案么)9.1 vue首屏加载优化有哪些方案么

- `Vue-Router`路由懒加载（利用`Webpack`的代码切割）
- 使用`CDN`加速，将通用的库从`vendor`进行抽离
- `Nginx`的`gzip`压缩
- `Vue`异步组件
- 服务端渲染`SSR`
- 如果使用了一些`UI`库，采用按需加载
- `Webpack`开启`gzip`压缩
- `Service Worker`缓存文件处理
- 使用`link`标签的`rel`属性设置 `prefetch`（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，`prefetch`通常用于加速下一次导航）、`preload`（`preload`将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_9-2-编码阶段)9.2 编码阶段

- 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher；
- 如果需要使用v-for给每项元素绑定事件时使用事件代理；
- SPA 页面采用keep-alive缓存组件；
- 在更多的情况下，使用v-if替代v-show；
- key保证唯一；
- 使用路由懒加载、异步组件；
- 防抖、节流；
- 第三方模块按需导入；
- 长列表滚动到可视区域动态加载；
- 图片懒加载；

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_9-3-用户体验)9.3 用户体验：

- 骨架屏；
- PWA；
- 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启`gzip`压缩等。

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_9-4-seo优化)9.4 SEO优化

- 预渲染；
- 服务端渲染SSR；

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_9-5-打包优化)9.5 打包优化

- 压缩代码；

- ```
  Tree Shaking/Scope Hoisting
  ```

  ；

  - `scope hoisting` 是 `webpack3` 的新功能，直译过来就是「作用域提升」。熟悉 JavaScript 都应该知道「函数提升」和「变量提升」，JavaScript 会把函数和变量声明提升到当前作用域的顶部。「作用域提升」也类似于此，webpack 会把引入的 js 文件“提升到”它的引入者顶部

- 使用cdn加载第三方模块；

- 多线程打包`happypack`；

- `splitChunks`抽离公共文件；

- `sourceMap`优化；

## [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_10-vue1-x-vue2-x-vue3-框架分析性能)10 vue1.X，vue2.X，vue3 框架分析性能

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_10-1-vue1-x-特点-响应式)10.1 Vue1.x （特点：响应式）

> 没有vdom，完全的响应式，每个数据变化，都通过响应式通知机制来新建Watcher干活，项目规模变大后，过多的Watcher，会导致性能的瓶颈。

![image-20210307183730134](http://img-repo.poetries.top/images/image-20210307183730134.png)

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_10-2-vue2-x-特点-组件级响应式-组件内部vdom-diff)10.2 Vue2.x （特点：组件级响应式，组件内部vdom diff）

> 引入`vdom`，控制了颗粒度，组件层面走`watcher`通知， 组件内部走`vdom`做`diff`，既不会有太多watcher，也不会让vdom的规模过大，diff超过16ms，真是优秀。

![image-20210307183810844](http://img-repo.poetries.top/images/image-20210307183810844.png)

### [#](http://interview.poetries.top/excellent-docs/13-性能优化模块.html#_10-3-vue3-特点-proxy做响应式-静态标记、按需更新)10.3 Vue3 （特点：proxy做响应式：静态标记、按需更新）

> 先说结论，静态标记，upadte性能提升1.3~2倍，ssr提升2~3倍。

Vue3通过`Proxy响应式+组件内部vdom+静态标记`，把任务颗粒度控制的足够细致，所以也不太需要`time-slice`了。

![image-20210307183845241](http://img-repo.poetries.top/images/image-20210307183845241.png)



# 14 HTTP模块

## 1 HTTP 报文的组成部分

**请求报文**

- 请求行 ( http 方法 + 页面地址 + http 协议 + 版本)
- 请求头( key + value 值)
- 空行(服务端通过空行来判断下一部分不再是请求头，而当做请求体来解析)
- 请求体(数据部分)

**响应报文**

- 状态行 + 响应头 + 空行 + 响应体

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_2-常见状态码)2 常见状态码

- `1xx`: 接受，继续处理
- `200`: 成功，并返回数据
- `201`: 已创建
- `202`: 已接受
- `203`: 成为，但未授权
- `204`: 成功，无内容
- `205`: 成功，重置内容
- `206`: 成功，部分内容
- `301`: 永久移动，重定向
- `302`: 临时移动，可使用原有URI
- `304`: 资源未修改，可使用缓存
- `305`: 需代理访问
- `400`: 请求语法错误
- `401`: 要求身份认证
- `403`: 拒绝请求
- `404`: 资源不存在
- `500`: 服务器错误

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_3-从输入url到呈现页面过程)3 从输入URL到呈现页面过程

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_3-1-简洁)3.1 简洁

- 浏览器的地址栏输入URL并按下回车；
- DNS 解析：将域名解析成 IP 地址；
- TCP 连接：TCP 三次握手；（三次握手的目的：为了防止已经失效的连接请求报文段突然又传送到了服务器端，从而产生错误）
- 发送 HTTP 请求；
- 服务器处理请求并返回 HTTP 报文；
- 浏览器解析渲染页面；
- 断开连接：TCP 四次挥手

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_3-2-详细)3.2 详细

**HTTP请求示意图**

![img](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)

> 浏览器中的HTTP请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备IP和端口、等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接

- 用户输入url并回车

- 浏览器进程检查url，组装协议，构成完整的url

- 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程

- 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程

- 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下

  ：

  - 进行DNS解析，获取服务器`ip`地址，端口
  - 利用`ip`地址和服务器建立`tcp`连接
  - 构建请求头信息
  - 发送请求头信息服务器响应后，网络进程接收响应头和响应信息，并解析响应内容

- 网络进程解析响应流程

  :

  - 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步，如果是200，则继续处理请求
  - 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行染

- 准备渲染进程

  - 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程

- 传输数据、更新状态

  - 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
  - 渲染进程接收完数据后，向浏览器发送“确认提交”
  - 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_4-tcp、udp相关)4 TCP、UDP相关

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_4-1-udp-和-tcp有什么区别)4.1 UDP 和 TCP有什么区别

> UDP协议是面向无连接的，不需要在正式传递数据之前先连接起双方，具有不可靠性：不保证有序且不丢失的将数据传递到对端，并且没有任何控制流量的算法。优点是：相比TCP更轻便高效

TCP建立连接和断开连接都需要进行握手，并在数据传输过程中，通过算法来保证数据的可靠性

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_4-2-tcp为什么要三次握手)4.2 TCP为什么要三次握手

> 客户端和服务端都需要直到各自可收发，因此需要三次握手

![img](https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png)

> TCP有6种标示:SYN(建立联机) ACK(确认) PSH(传送) FIN(结束) RST(重置) URG(紧急)

**举例：已失效的连接请求报文段**

- `client`发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达`server`
- 本来这已经是一个失效的报文，但是`server`端接收到这个请求报文后，还是会想`client`发出确认的报文，表示同意连接。
- 假如不采用三次握手，那么只要`server`发出确认，新的建立就连接了，但其实这个请求是失效的请求，`client`是不会理睬`server`的确认信息，也不会向服务端发送确认的请求
- 但是`server`认为新的连接已经建立起来了，并一直等待`client`发来数据，这样，server的很多资源就没白白浪费掉了
- 采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道`client`并没有建立连接。这就是三次握手的作用

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_4-3-三次握手过程中可以携带数据吗)4.3 三次握手过程中可以携带数据吗

- 第一次、第二次握手不可以携带数据，因为一握二握时还没有建立连接，会让服务器容易受到攻击
- 而第三次握手，此时客户端已经处于 `ESTABLISHED (已建立连接状态)` ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_4-4-tcp的四次挥手)4.4 TCP的四次挥手

> 为了确保数据能够完成传输

- 关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了
- 所以你未必会马上关闭`SOCKET`,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的`ACK`报文和FIN报文多数情况下都是分开发送的。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_4-5-tcp-和-udp-的区别)4.5 TCP 和 UDP 的区别

- TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接
- TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换
- TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低(因 此会出现丢包，对实时的应用比如 IP 电话和视频会议等)
- TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多
- TCP 的首部较大为 20 字节，而 UDP 只有 8 字节
- TCP 是面向连接的可靠性传输，而 UDP 是不可靠的

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_4-6-http和tcp的不同)4.6 HTTP和TCP的不同

- HTTP的责任是去定义数据，在两台计算机相互传递信息时，HTTP规定了每段数据以什么形式表达才是能够被另外一台计算机理解。
- 而TCP所要规定的是数据应该怎么传输才能稳定且高效的传递与计算机之间。

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_5-http2相关)5 HTTP2相关

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_5-1-说一下-http2-0)5.1 说一下 http2.0

> 首先补充一下，http 和 https 的区别，相比于 http,https 是基于 ssl 加密的 http 协议

简要概括:http2.0 是基于 1999 年发布的 http1.0 之后的首次更新

- **提升访问速度**(可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0)
- **允许多路复用**:多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改 善了:在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限 制(连接数量)，超过限制会被阻塞
- **二进制分帧**:HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二 进制编码
- **首部压缩**
- **服务器端推送**

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_5-2-http2和http1有什么区别)5.2 HTTP2和HTTP1有什么区别

**相对于HTTP1.0，HTTP1.1的优化**

- 缓存处理：多了`Entity tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match`等缓存信息（`HTTTP1.0 If-Modified-Since`,`Expires`）
- 带宽优化及网络连接的使用
- 错误通知的管理
- `Host`头处理
- 长连接： `HTTP1.1`中默认开启`Connection`： `keep-alive`，一定程度上弥补了`HTTP1.0`每次请求都要创建连接的缺点

**相对于HTTP1.1，HTTP2的优化**

- `HTTP2`支持二进制传送（实现方便且健壮），`HTTP1.x`是字符串传送
- `HTTP2`支持多路复用
- `HTTP2`采用`HPACK`压缩算法压缩头部，减小了传输的体积
- `HTTP2`支持服务端推送

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_5-3-http-2为什么要做头部压缩-实现原理是什么)5.3 http/2为什么要做头部压缩，实现原理是什么？

> http请求都是由状态行、请求/响应头部、消息主体三部分组成，一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩后的二进制文件（例如图片、音频），但是状态行和头部却没有经过任何压缩，直接以文本传输。对于一个请求而言，其headers所占的字节数也不少，尤其cookie，有些时候headers甚至超过了主体的大小。

头部压缩使用了HPACK算法。会在支持http/2的浏览器和服务端之间：

- 维护一份相同的静态字典，包含常见的头部名称以及特别常见的头部名称和值的组合。这样对完全匹配的头部键值对，例如：method：GET，就可以使用一个字符表示。对于头部名称可以匹配的，例如cookie： xxx，可以将名称使用一个字符表示
- 维护一份相同的动态字典，可以动态的添加内容
- 支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_5-4-http-2的server-push有什么优点)5.4 http/2的Server Push有什么优点

- 支持服务端推送，意味着服务端可以在发送页面`HTML`时主动推送其它资源，而不用等到浏览器解析到相应位置再发起请求
- 另外，服务端可以主动推送，客户端也有权选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送`RST_STREAM`帧来拒收

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_5-5-谈谈你对多路复用的理解)5.5 谈谈你对多路复用的理解

> - `HTTP2`采用二进制格式传输，取代了`HTTP1.x`的文本格式，二进制格式解析更高效。
> - 多路复用代替了`HTTP1.x`的序列和阻塞机制，所有的相同域名请求都通过同一个`TCP`连接并发完成。在`HTTP1.x`中，并发多个请求需要多个`TCP`连接，浏览器为了控制资源会有`6-8`个`TCP`连接都限制。

**HTTP2中**

- 同域名下所有通信都在单个连接上完成，消除了因多个 `TCP` 连接而带来的延时和内存消耗。
- 单个连接上可以并行交错的请求和响应，之间互不干扰

> - `http/1` 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。而`http/2`将请求和响应数据分隔成为更小的帧，并对他们采用二进制编码
> - `http/2` 中，同域名下的所有请求都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，消息由一个或多个帧组成。多个帧之间可以乱序发送，然后根据帧首部的流标识可以重新组装

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-https相关)6 https相关

想要真正的了解https，需要了解很多相关知识，比如SSL，对称加密，非对称加密，CA证书等知识。

> https协议本身并不是一种新的协议，在HTTP跟TCP中间加多了一层加密层TLS/SSL。通常HTTP直接和TCP通信，而HTTPS要先将数据给到TLS/SSL，数据经加密后，再给到 TCP 进行传输。

> HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种是确认网站的真实性

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-1-https加的一层ssl在七层中哪个位置)6.1 HTTPS加的一层SSL在七层中哪个位置

> 从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密，你可以参考下图

![img](http://blog.poetries.top/img-repo/2019/11/113.png)

- 从图中我们可以看出 HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。
- 总的来说，安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作
- 我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-2-https-协议的优点)6.2 https 协议的优点

- 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
- HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性
- HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻 击的成本

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-3-https-协议的缺点)6.3 https 协议的缺点

- `https`握手阶段比较费时，会使页面加载时间延长 `50%`，增加 `10%~20%` 的耗电
- `https` 缓存不如 `http` 高效，会增加数据开销
- `SSL` 证书也需要钱，功能越强大的证书费用越高
- `SSL` 证书需要绑定 `IP`，不能再同一个 ip 上绑定多个域名，`ipv4` 资源支持不了这种消耗

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-4-http与https区别)6.4 http与https区别

> 在回答这个问题之前，我们先看下http请求存在哪些不足：

- 通信使用明文（不加密），内容可能会被窃听
- 不会验证通信方的身份，因此可能会遭遇伪装
- 无法保证报文的完整性，请求或响应的内容被篡改也无法知道

> https就是对上面三点不足的解决，可以认为

**https == http + 加密 + 身份验证 + 数据完整性保护**

**他们的区别就明显了**

- http使用明文传输，https则是具有安全性的ssl加密传输协议
- http不会验证通信放的身份，https会通过数字证书来验证身份
- https可以保证数据的完整性，防止传输内容被中间人冒充或篡改
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所共12 个包。
- 除以上外，http和https使用的端口也不同，前者使用80端口，后者使用443端口

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-5-https传输的具体过程)6.5 https传输的具体过程

> HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种是确认网站的真实性

> TLS 的完整过程需要三个算法（协议），密钥交互算法，对称加密算法，和消息认证算法

**TLS 中的加密**

- 对称加密 —— 两边拥有相同的秘钥，两边都知道如何将密文加密解密。
- 非对称加密 —— 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-6-https的整体过程分为证书验证和数据传输阶段)6.6 HTTPS的整体过程分为证书验证和数据传输阶段

**1. 证书验证阶段：**

- 浏览器发起 HTTPS 请求。（ TLS 握手请求）
- 服务端返回 证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息。
- 客户端验证证书是否合法，如果不合法则提示告警。

**2. 数据传输阶段：**

- 当证书验证合法后，在本地生成随机数。
- 通过公钥加密随机数，并把加密后的随机数传输到服务端。
- 服务端通过私钥对随机数进行解密。 服务端通过客户端传入的随机数构造对称加密算法，之后的数据交互通过对称加密算法进行加解密。（对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法）
- 服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。

> 服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-7-介绍一下https的握手过程)6.7 介绍一下https的握手过程

- 第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法
- 第二步，服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数
- 第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端
- 第四步，服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。
- 第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程

**总结**

- 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于构造对称加密算法的随机数
- 通过证书中的公钥对随机数进行加密传输到服务端（随机对称密钥），服务端接收后通过私钥解密得到随机对称密钥，之后的数据交互通过对称加密算法进行加解密。（既有对称加密，也有非对称加密）

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-8-为什么https数据传输使用对称加密)6.8 为什么https数据传输使用对称加密

- 对称加密： 对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥。
- 非对称加密: 加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。

> 通过上面的握手过程可知，https在证书验证阶段，使用非对称加密来传输共享秘钥，之后的传输中都使用对称加密方式。原因是，非对称加密的加解密效率是非常低的，而http场景中通常端与端之间的交互量很大，对非对称加密的效率是无法忍受的。另外， HTTPS场景中只有服务端保存了私钥，一对公私钥只能实现单向加解密过程。因此 HTTPS 中的内容传输采用对称加密

**对称密钥加密和非对称密钥加密它们有什么区别**

- 对称密钥加密是最简单的一种加密方式，它的加解密用的都是相同的密钥，这样带来的好处就是加解密效率很快，但是并不安全，如果有人拿到了这把密钥那谁都可以进行解密了。
- 而非对称密钥会有两把密钥，一把是私钥，只有自己才有；一把是公钥，可以发布给任何人。并且加密的内容只有相匹配的密钥才能解。这样带来的一个好处就是能保证传输的内容是安全的，因为例如如果是公钥加密的数据，就算是第三方截取了这个数据但是没有对应的私钥也破解不了。不过它也有缺点，一是公钥因为是公开的，谁都可以过去，如果内容是通过私钥加密的话，那拥有对应公钥的黑客就可以用这个公钥来进行解密得到里面的信息；二来公钥里并没有包含服务器的信息，也就是并不能确保服务器身份的合法性；并且非对称加密的时候要消耗一定的时间，减低了数据的传输效率。

**混合加密机制的好处是什么**

- 对称密钥加密和非对称密钥加密都有它们各种的优缺点，而混合加密机制就是将两者结合利用它们各自的优点来进行加密传输。
- 比如既然对称密钥的优点是加解密效率快，那么在客户端与服务端确定了连接之后就可以用它来进行加密传输。不过前提是得解决双方都能安全的拿到这把对称密钥。这时候就可以里用非对称密钥加密来传输这把对称密钥，因为我们知道非对称密钥加密的优点就是能保证传输的内容是安全的。
- 所以它的好处是即保证了对称密钥能在双方之间安全的传输，又能使用对称加密方式进行通信，这比单纯的使用非对称加密通信快了很多。以此来解决了HTTP中内容可能被窃听的问题。

**混合加密的缺点**

> 混合加密主要是为了解决`HTTP`中内容可能被窃听的问题。但是它并不能保证数据的完整性，也就是说在传输的时候数据是有可能被第三方篡改的，比如完全替换掉，所以说它并不能校验数据的完整性。如果需要做到这一点就需要使用到数字签名。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-9-介绍下https中间人攻击的过程)6.9 介绍下https中间人攻击的过程

这个问题也可以问成 为什么需要CA认证机构颁发证书？ 我们假设如果不存在认证机构，则人人都可以制造证书，这就带来了"中间人攻击"问题。

**中间人攻击的过程如下**

- 客户端请求被劫持，将所有的请求发送到中间人的服务器
- 中间人服务器返回自己的证书
- 客户端创建随机数，使用中间人证书中的公钥进行加密发送给中间人服务器，中间人使用私钥对随机数解密并构造对称加密，对之后传输的内容进行加密传输
- 中间人通过客户端的随机数对客户端的数据进行解密
- 中间人与服务端建立合法的https连接（https握手过程），与服务端之间使用对称加密进行数据传输，拿到服务端的响应数据，并通过与服务端建立的对称加密的秘钥进行解密
- 中间人再通过与客户端建立的对称加密对响应数据进行加密后传输给客户端
- 客户端通过与中间人建立的对称加密的秘钥对数据进行解密

> 简单来说，中间人攻击中，中间人首先伪装成服务端和客户端通信，然后又伪装成客户端和服务端进行通信（如图）。 整个过程中，由于缺少了证书的验证过程，虽然使用了https，但是传输的数据已经被监听，客户端却无法得知

![img](http://blog.poetries.top/img-repo/2020/03/1.png)

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-10-https-握手过程中-客户端如何验证证书的合法性)6.10 HTTPS 握手过程中，客户端如何验证证书的合法性

> CA证书中会包含颁发机构信息、公钥、公司信息、域名、有效期等信息，浏览器验证证书：

- 首先就是要验证域名、有效期等信息是否正确
- 然后判断证书来源的合法性。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证
- 判断证书是否被篡改。需要与 CA 服务器进行校验
- 判断证书是否已吊销

> 以上任意一步都满足的情况下浏览器才认为证书是合法的

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-11-问题)6.11 问题

**1. 为什么数据传输是用对称加密**

> HTTP的应用场景中通常端与端之间存在大量的交互，非对称加密的加解密效率非常低。另外，在 HTTPS的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密

**2. 为什么需要证书?**

> 防止“中间人”攻击，同时可以为网站提供身份证明。

**3. 使用 HTTPS 会被抓包吗?**

> 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-12-数字签名-它是什么)6.12 数字签名？它是什么

> 数字签名的产生主要就是为了解决HTTP中内容可能被篡改的问题，即校验数据的完整性。它能确定消息是发送方发送过来的，因为这里会有一个验证数字签名的过程，别人是假冒不了发送方的签名的。

数字签名它是什么呢？它的产生过程其实就是两步，第一步将原文用Hash函数生成一个叫消息摘要的东西，第二步就是用发送方的私钥对这个消息摘要进行进行加密。这个产生的东西就叫做数字签名，它一般会与原文一起发送给接收者。

**而验证它的过程其实也并不复杂。**

- 首先发送方会将原文与数字签名(也就是加密后的摘要)一起发送给接收方
- 接收方会接收到这两样东西，即原文和数字签名
- 接收方用Hash函数处理原文会得到一份消息摘要
- 同时用发送方的公钥解密数字签名也会得到一份消息摘要
- 只要比较这两份消息摘要是否相等就可以验证出数据有没有被篡改了

当然这里关键的一步就是要保证发送方传递过来的公钥是可信赖的，这时候就得用到数字证书了。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-13-谈谈对数字证书的理解)6.13 谈谈对数字证书的理解

数字证书也叫公钥证书，或者简称证书。它主要是为了解决通信方身份遭伪装的问题，也就是验证通信方的身份。

因为我们知道在HTTPS中虽然有了混合加密机制保证数据不被监听，有了数字签名校验数据的完整性，但是数字签名校验的前提是能拿到发送方的公钥，并且保证这个公钥是可信赖的，所以就需要数字证书。

它简单来说其实是由一些权威的数字认证机构颁发给服务器的一个文件。数字认证机构简称CA，它是客户端和服务端都信任的第三方机构，我知道比较有名的一个就是威瑞信(VeriSign)。至于颁发证书的流程，主要是为：

- 服务器的运营人员会向认证机构提交自己的公钥、组织信息、个人信息等并申请认证
- 而认证机构在拿到这些信息后会通过线上、线下各种途径验证申请者提交信息的真实性
- 在确认其真实性后，认证机构给这些信息(申请者的公钥，组织信息，个人信息以及认证机构自己的信息等)，我们简称为明文信息，进行数字签名，过程也就是签名提到的数字签名的步骤：1.通过Hash函数处理明文信息生成一个信息摘要；2.再用认证机构自己的私钥对信息摘要进行加密处理。通过这两个步骤生成的文件就叫数字签名。
- 之后会将明文信息和数字签名组合而成的证书颁发给申请者，也就是服务器。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-14-为什么说数字证书就能对通信方的身份进行验证呢)6.14 为什么说数字证书就能对通信方的身份进行验证呢

> 那是因为在客户端第一次给服务端发送HTTPS请求的时候，服务端会将它自己的证书随着其它的信息(例如`server_random、 server_params`、需要使用的加密套件等东西)一起返给客户端。

客户端在收到之后首先会验证这个证书，只有验证通过之后才会有后续操作。而验证的过程其实也就是数字签名的验证过程(题5)：

- 前面说过了，证书其实是由明文信息(申请者的公钥，组织信息，个人信息以及认证机构自己的信息等)和这个明文信息的数字签名组成的。(对应着题5也就是原文和数字签名)
- 客户端会用Hash函数处理明文信息生成一个信息摘要
- 然后再用内置在浏览器上的**CA的公钥**来解密证书里的数字签名，得到一个信息摘要。因为我们知道证书实际是由CA颁发给服务器的，并且里面的数字签名也是用的CA的私钥加密的，所以只有CA的公钥才能解。
- 最后再将两个信息摘要进行对比，若是一样则能保证通信方的身份是正确的。

其实验证证书的过程不仅仅是数字签名的验证，客户端还会验证证书相关的域名信息，有效时间，是不是在CRL吊销列表里，以及它的上一级是否有效等等。

（一般答到这里就可以了，如果面试官继续问你上一级是否有效这样验证，你就回答：这是一个递归的过程，直到验证到根证书也就是操作系统内置的Root证书或者浏览器内置的Root证书为止）

> 就像前面说的，只有能用**CA的公钥**解密的数字签名并且通过了认证的证书才是有效的，因为证书是CA颁布的。这也就保证了客户端收到的服务器发来的公钥是真实可用的(因为公钥在证书的明文信息里)。

（想想其实很好理解，因为浏览器它自己没有辨别证书是否合法的能力，它就把这事交给CA去做，CA是信任的过的机构，它只要把自己的公钥内嵌到浏览器里，浏览器再用这个CA公钥来解证书里的签名就可以了。而证书的签名也是经过CA的私钥加密生成的，只有CA的公钥能解，但它的公钥又不是随便人能拿到的，只有各大浏览器厂商才有，所以这就是数字证书的验证过程）

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-15-请详细的说一下https它的加密传输过程-涉及到哪些算法呢)6.15 请详细的说一下HTTPS它的加密传输过程，涉及到哪些算法呢？

难度：🌟🌟🌟🌟

> 在HTTPS加密传输中，实际上涉及到 SSL/TLS 协议，这里是有一个TSL握手的过程。对于传统的TLS握手也就是RSA握手我就不描述了，主要是说一下现在主流的TLS1.2版本的握手，也就是ECDHE握手。

它的过程大致来说是这样的：

1. 客户端在第一次发送HTTPS请求的时候，会把 `client_random`、TSL版本号、加密套件列表发送给服务器
2. 服务器在接收到之后确认TSL的版本号，同时发送 `server_random、server_params`、需要使用的加密套件、以及自己的证书给客户端
3. 客户端在收到这些信息之后，首先是会对服务器的证书进行验证(也就是题目7)，若是验证成功则会传递一个 `client_params` 给服务器
4. 与此同时客户端会通过**ECDHE算法**计算出一个`pre_random`，其中是传入了两个参数，一个是 `client_params`，还一个是 server_params。(也就是说：`ECDHE(client_params, server_params) = per_random`)
5. 这时候客户端就同时拥有了 `client_random、server_random、pre_random`，它会将这三个参数通过一个**伪随机函数**计算得出最终的`secret`，这个`secret`就是它们后续通信所要用的对称密钥。
6. 而在客户端生成完`secret`之后，会给服务器发送一个收尾消息，告诉服务器之后都要用对称加密，且对称加密的算法是用第一次约定好的。
7. 服务器它在接收到刚刚传递过来的`client_params`之后，也会使用和客户端一样的方式生成`secret`，并且也会发送一个收尾消息给客户端。
8. 当双方都收到收尾消息并验证成功之后，握手就结束了。后面开始用这个secret对称密钥加密报文进行传输。

（ECDHE基于**椭圆曲线离散对数**，传入的两个参数也被叫做**椭圆曲线的公钥**）

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-16-描述一下rsa握手)6.16 描述一下RSA握手

难度：🌟🌟🌟

1. 客户端首先向服务端发送一个HTTPS请求
2. 服务端会把事先配置好的公钥证书随着其它的信息返回给客户端
3. 客户端在收到服务端发来的证书之后进行验证，验证的过程参考数字证书验证，会得到服务端的信息以及它的公钥
4. 验证成功之后会用**伪随机函数**计算出一个加密所需要的对称密钥(secret)，并且用服务端的公钥加密这个对称密钥发送给服务端
5. 服务端再用自己的私钥解密刚刚的消息，得到里面的对称密钥。此时服务端和客户端都有了对称密钥。
6. 后面的传输都会用这个 secret 进行对称密钥加解密传输

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-17-ecdhe握手和rsa握手又有什么区别呢)6.17 ECDHE握手和RSA握手又有什么区别呢

难度：🌟🌟🌟

它们的区别主要是：

1. 生成secret(对称密钥)的过程不同。RSA中是使用RSA算法生成一个pre_random并用服务器的公钥加pre_random发送给服务器，然后各自用伪随机函数生成相同的secret对称密钥；而在ECDHE握手中，它没有用到RSA算法，而是用ECDHE算法生成的pre_random，且这个过程中比RSA多了client_params和server_params两个参数。
2. 在生成完secret之后，ECDHE握手在客户端发送完收尾消息后可以提前`抢跑`，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫`TLS False Start`。
3. 最主要的：RSA不具备向前安全性，ECDHE有

（向前安全性：一次破解并不影响历史信息的性质就是向前安全性）

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-18-你知道tsl1-3版本吗-它较tsl1-2做了哪些改进呢)6.18 你知道TSL1.3版本吗？它较TSL1.2做了哪些改进呢？

> `TSL1.3`版本是2018年推出的。它较TSL1.2主要是做了以下改进：

1. 强化安全

> 废除了很多的加密算法，只保留了5个加密套件。其中最主要的是废弃了RSA，因为在2015年发现了PRAEK攻击，即已经有人发现了RSA的漏洞能进行破解；而且RSA不具备向前安全性。

1. 提高性能

同时利用会话复用节省了重新生成密钥的时间，利用 PSK 做到了`0-RTT`连接。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-19-介绍下-https-中间人攻击)6.19 介绍下 HTTPS 中间人攻击

**中间人攻击过程如下：**

- 服务器向客户端发送公钥。
- 攻击者截获公钥，保留在自己手上。
- 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
- 客户端收到伪造的公钥后，生成加密hash值发给服务器。
- 攻击者获得加密hash值，用自己的私钥解密获得真秘钥。
- 同时生成假的加密hash值，发给服务器。
- 服务器用私钥解密获得假秘钥。
- 服务器用加秘钥加密传输信息

**防范方法：**

> 服务端在发送浏览器的公钥中加入`CA证书`，浏览器可以验证`CA证书`的有效性

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_6-20-http-https-协议总结)6.20 http/https 协议总结

**1.0 协议缺陷:**

- 无法复用链接，完成即断开，重新慢启动和 `TCP 3`次握手
- `head of line blocking`: 线头阻塞，导致请求之间互相影响

**1.1 改进:**

- 长连接(默认 `keep-alive`)，复用

- `host` 字段指定对应的虚拟站点

- 新增功能:

  - 断点续传

  - 身份认证

  - 状态管理

  - ```
    cache
    ```

     

    缓存

    - `Cache-Control`
    - `Expires`
    - `Last-Modified`
    - `Etag`

**2.0:**

- 多路复用
- 二进制分帧层: 应用层和传输层之间
- 首部压缩
- 服务端推送

**https: 较为安全的网络传输协议**

- 证书(公钥)
- `SSL` 加密
- 端口 `443`

**TCP:**

- 三次握手
- 四次挥手
- 滑动窗口: 流量控制
- 拥塞处理
  - 慢开始
  - 拥塞避免
  - 快速重传
  - 快速恢复

**缓存策略: 可分为 强缓存 和 协商缓存**

- `Cache-Control/Expires`: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，`Cache-Control`的 `max-age` 优先级高于 `Expires`

- 当缓存已经过期时，使用协商缓存

  - 唯一标识方案: `Etag`(`response` 携带) & `If-None-Match`(`request`携带，上一次返回的 `Etag`): 服务器判断资源是否被修改

  - 最后一次修改时间:

     

    ```
    Last-Modified(response) & If-Modified-Since
    ```

    (

    ```
    request
    ```

    ，上一次返回的

    ```
    Last-Modified
    ```

    )

    - 如果一致，则直接返回 304 通知浏览器使用缓存
    - 如不一致，则服务端返回新的资源

- ```
  Last-Modified
  ```

   

  缺点：

  - 周期性修改，但内容未变时，会导致缓存失效
  - 最小粒度只到 `s`， `s` 以内的改动无法检测到

- `Etag` 的优先级高于`Last-Modified`

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_7-websocket的实现和应用)7 WebSocket的实现和应用

> ```
> Websocket` 是一个 持久化的协议， 基于 `http` ， 服务端可以 主动 `push
> ```

**兼容：**

> - `FLASH Socket`
> - 长轮询： 定时发送 `ajax`
> - `long poll`： 发送 --> 有消息时再 `response`

- `new WebSocket(url)`
- `ws.onerror = fn`
- `ws.onclose = fn`
- `ws.onopen = fn`
- `ws.onmessage = fn`
- `ws.send()`

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_7-1-什么是-websocket)7.1 什么是 WebSocket

> WebSocket 是 HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个 http 请求合并为 1个

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_7-2-websocket-是什么样的协议-具体有什么优点)7.2 WebSocket 是什么样的协议，具体有什么优点

- HTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在 Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1 中进行了改进，是的有一个 connection: Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request，接收多个 Response。 但是必须记住，在 Http 中一个 Request 只能对应有一个 Response，而且这个 Response 是被动的，不能主动发起。
- WebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段 与 Http 是相同的。我们来看一个 websocket 握手协议的实现，基本是 2 个属性，upgrade， connection。

基本请求如下:

```text
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13
Origin: http://example.com
```

多了下面 2 个属性:

```text
Upgrade:webSocket 
Connection:Upgrade
```

告诉服务器发送的是 `websocket`

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_7-3-理解websocket协议的底层原理、与http的区别)7.3 理解WebSocket协议的底层原理、与HTTP的区别

> WebSocket 是一个持久化的网络通信协议，可以在单个 TCP 连接上进行 **全双工通讯** ，没有了 **Request** 和 **Response** 的概念，两者地位完全平等，连接一旦建立，客户端和服务端之间可以实时进行双向数据传输。

1. HTTP 是非持久协议，客户端想知道服务端的处理进度只能通过长轮询或者是 long poll 的方式，但是前者对服务器压力大，后者则会因为一直等待响应造成阻塞。

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2308134eee1949129438e15b945792b9~tplv-k3u1fbpfcp-zoom-1.image?imageslim)

1. 虽然 http1.1 默认开启了 keep-alive 长连接保持了这个 TCP 通道使得在一个 HTTP 连接中可以发送多个请求，接受多个响应，但是一个请求只能有一个响应，而且这个响应也是被动的，不能主动发起
2. WebSocket 虽然是独立于 HTTP 的一种协议，但是 WebSocket 必须依赖 HTTP 协议进行一次握手（在握手阶段是一样的），我手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了，可以用一张图理解两者有交集，但并不是全部。

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93f1390c965f4bb28f97eeced69652d0~tplv-k3u1fbpfcp-zoom-1.image?imageslim)

**socket**

1. socket 也被称为套接字，与 HTTP 和 WebSocket 不一样，socket 不是协议，它是在程序层面上对传输层协议（可以主要理解为 TCP / IP）的接口封装。可以理解为一个能够提供端对端的通信的调用接口（API）。
2. 对于程序员而言，其需要在 A 端创建一个 socket 实例，并为这个实例提供其所要连接的 B 端的 IP 地址和端口号，而在 B 端创建另一个 socket 实例，并且绑定本地端口号来进行监听。当 A 和 B 建立连接后，双方就建立了一个端对端的 TCP

**应用场景**

> WebSocket 可以做弹幕、消息订阅、多玩家游戏、协同编辑、股票基金实时报价、视频会议、在线教育、聊天室等应用实时监听服务端变化。

**WebCocket 握手**

- WebSocket 握手请求报文

```http
  GET /chat HTTP/1.1
  Host: server.example.com
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
  Sec-WebSocket-Protocol: chat, superchat
  Sec-WebSocket-Version: 13
  Origin: http://example.com
```

> 下面是与传统 HTTP 报文不同的地方：

```http
  Upgrade: websocket
  Connection: Upgrade
```

表示发起的是 WebSocket 协议

```http
  Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
  Sec-WebSocket-Protocol: chat, superchat
  Sec-WebSocket-Version: 13
```

- `Sec-WebSocket-Key` 是由浏览器随机生成的，验证是否可以进行 WebSocket 通信，防止恶意或者无意的连接；
- `Sec-WebSocket-Protocol` 是用户自定义的字符串，用来标识服务所以需要的协议；
- `Sec-WebSocket-Version` 表示支持的 WebSocket 版本。

- 服务端响应

```http
  HTTP/1.1 101 
  Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
  Sec-WebSocket-Protocol: chat
```

- 101 响应码 表示要转换协议。
- `Connection: Upgrade` 表示升级新协议请求。
- Upgrade: websocket` 表示升级为 WebSocket 协议。
- `Sec-WebSocket-Accept` 是经过服务器确认，并加密过后的 `Sec-WebSocket-Key` ，用来证明客户端和服务端之间能够进行通信了。
- `Sec-WebSocket-Protocol` 表示最终使用的协议。

> 至此，客户端和服务器握手成功建立了 WebSocket 连接，HTTP 已经完成了他所有工作，接下来就是完全按照 WebSocket 协议进行通信。

**WebSocket 心跳**

可能会有某些未知情况导致 socket 断开，而客户端和服务端却不知道，需要客户端定时发送一个 **心跳 ping** 让服务端知道自己在线，服务端也需要回复一个 **心跳 pong** 告诉客户端自己可用，否则视为断开。

**WebSocket 状态**

> WebSocket 对象中的 readyState 属性有四种状态：

- 0：表示正在连接
- 1：表示连接成功，可以通信了
- 2：表示连接正在关闭
- 3：表示连接已经关闭，或者打开连接失败

**websocket和HTTP有什么不一样小结**

- 双向通信
- 数据格式比较轻量，性能开销小，通信高效
  - 协议控制的数据包头部较小，而`HTTP`协议每次通信都需要携带完整的头部
- 更好的二进制支持
- 没有同源限制，客户端可以与任意服务器通信
- 与 `HTTP` 协议有着良好的兼容性。默认端口也是`80`和`443`，并且握手阶段采用 `HTTP` 协议，因此握手时不容易屏蔽，能通过各种 `HTTP` 代理服务器

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_8-token、cookie、session区别)8 Token、cookie、Session区别

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_8-1-cookie-和-session-的区别)8.1 Cookie 和 session 的区别

> HTTP 是一个无状态协议，因此 Cookie 的最大的作用就是存储 sessionId 用来唯一标识用 户。

- `cookie` 数据存放在客户的浏览器上，session 数据放在服务器上
- `cookie` 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗 考虑到安全应当使用 session
- `session` 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 `COOKIE`
- 单个 `cookie` 保存的数据不能超过 `4K`，很多浏览器都限制一个站点最多保存 20 个 `cookie`

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_8-2-cookie-和-token-都存放在-header-中-为什么不会劫持-token)8.2 cookie 和 token 都存放在 header 中，为什么不会劫持 token？

- 攻击者通过 xss 拿到用户的 cookie 然后就可以伪造 cookie 了
- 或者通过 csrf 在同个浏览器下面通过浏览器会自动带上 cookie 的特性在通过 用户网站-攻击者网站-攻击者请求用户网站的方式 浏览器会自动带上cookie
- 但是 token。不会被浏览器带上 问题 2 解决
- token 是放在 jwt 里面下发给客户端的 而且不一定存储在哪里 不能通过document.cookie 直接拿到，通过 jwt+ip 的方式 可以防止 被劫持 即使被劫持也是无效的 jwt

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_8-3-介绍下如何实现-token-加密)8.3 介绍下如何实现 token 加密

- jwt 举例：
  - 1. 需要一个 secret（随机数）
  - 1. 后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码) 生成一个字符串(token)，返回前端
  - 1. 前端每次 request 在 header 中带上 token
  - 1. 后端用同样的算法解密

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_9-一个图片-url-访问后直接下载怎样实现)9 一个图片 url 访问后直接下载怎样实现

> 请求的返回头里面，用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 http 头，决定用户下载行为的参数

下载的情况下:

1. `x-oss-object-type: Normal`
2. `x-oss-request-id: 598D5ED34F29D01FE2925F41`
3. `x-oss-storage-class: Standard`

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_10-fetch-发送-2-次请求的原因)10 fetch 发送 2 次请求的原因

> `fetch` 发送 `post` 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功? 原因很简单，因为你用 fetch 的 post 请求的时候，导致 `fetch` 第一次发送了一个 `Options` 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的 请求。

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_11-get-和-post-的区别)11 GET 和 POST 的区别

- GET在浏览器回退时是无害的，而POST会再次提交请求
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置
- GET请求参数会被完整保留在浏览器的历史记录里，而POST中的参数不会被保留
- GET请求在URL中传送的参数是有长度限制的，而POST没有限制
- GET参数通过URL传递，POST放在Request body中
- GET请求只能进行 url 编码，而POST支持多种编码方式
- GET产生的URL地址可以被收藏，而POST不可以
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息

**总结**

- ```
  get
  ```

  : 缓存、请求长度受限、会被历史保存记录

  - 无副作用(不修改资源)，幂等(请求次数与资源无关)的场景

- `post`: 安全、大数据、更多编码类型

![img](https://poetries1.gitee.io/img-repo/2020/09/114.png)

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_12-301-和-302-的区别)12 301 和 302 的区别

- `301 Moved Permanently` 被请求的资源已永久移动到新位置，并且将来任何对此资源的引 用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应 当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也 是可缓存的
- `302 Found` 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的， 客户端应当继续向原有地址发送以后的请求。只有在 `Cache-Control` 或 `Expires` 中进行了 指定的情况下，这个响应才是可缓存的
- 字面上的区别就是 301 是永久重定向，而 302 是临时重定向
- `301` 比较常用的场景是使用域名跳转。`302` 用来做临时跳转 比如未登陆的用户访问用户 中心重定向到登录页面

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_13-dns的作用、dns解析的详细过程-dns优化原理)13 DNS的作用、DNS解析的详细过程，DNS优化原理

**DNS查询过程：**

- 检查浏览器中是否缓存过该域名对应的 IP 地址
- 如果浏览器缓存中没有命中，将继续查找本级（操作系统）是否缓存过该 IP
- 向本地域名解析服务系统发起域名解析的请求（一般是本地运营商的机房）
- 向根域名解析服务器发起域名解析服务请求
- 根域名服务器返回 gTLD 域名解析服务器地址
- 向 gTLD 服务器发起解析请求
- gTLD 服务器接收请求并返回 Name Server 服务器（通常情况下就是你注册的域名服务器）
- Name Server 服务器返回 IP 地址给本地服务器
- 本地服务器缓存解析结果
- 返回解析结果给用户

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_14-简单请求和复杂请求)14 简单请求和复杂请求

1. **简单请求**

只要同时满足以下两大条件，就属于简单请求：

使用下列方法之一：

- GET
- HEAD
- POST

Content-Type 的值仅限于以下三者之一：

- text / plain
- multipart / form-data
- application / x-www-form-urlencoded

请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；

`XMLHttpRequestUpload` 对象可以使用 XMLHttpRequest.upload 属性访问。

1. **复杂请求**

> 不符合以上条件的就是复杂请求。复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 *预检请求* ，该请求的方法是 Option，通过该请求来查询服务端是否允许跨域请求。

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_15-http请求中的keep-alive有了解吗)15 Http请求中的keep-alive有了解吗

- 在`http`早期，每个`http`请求都要求打开一个`tpc socket`连接，并且使用一次之后就断开这个tcp连接- 使用`keep-alive`可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用`keep-alive`机制，可以减少tcp连接建立次数，也意味着可以减少`TIME_WAIT`状态连接，以此提高性能和提高`httpd`服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,`socket`的`accept()`和`close()`调用)。
- 但是，`keep-alive`并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的`keep-alive`，有时比重复利用连接带来的损失还更大。所以，正确地设置`keep-alive timeout`时间非常重要

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_16-管道机制的作用是什么)16 管道机制的作用是什么

- 如果浏览器要向一个域名发送多个请求，需要在本地维护一个FIFO队列，完成了一个再发送下一个，这样就存在一个问题，服务端从完成一个请求开始回传，到收到下一个请求的这段时间内是处于空闲状态的。
- 于是提出了管道机制，试图将浏览器的请求一股脑的打包发给服务器，服务器就可以在出开完一个请求后，马上处理下一个，不会在之前说的空闲时间。

**管道机制存在哪些问题？**

- 服务端收到多个管道请求后，需要按照接收顺序逐个响应。如果第一个请求处理特别慢，后续的响应的都会被阻塞着，这种情况称为「队首阻塞」。
- 服务端为了保证按顺序回传，通常需要缓存多个响应，从而占用更多的服务端资源，也更容易被攻击
- 浏览器连续发送多个请求后，等待响应的这段时间，如果遇到网络异常导致连接断开，无法得知服务器处理情况，如果全部重试，可能会在服务端重复处理。
- 服务端和浏览器中间的代理设备不一定支持http管道，这给管道技术的普及带来了更多复杂性

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_17-什么情况下会触发option请求)17 什么情况下会触发option请求

> options 通常用于，在跨域请求前发起预检请求，以检测请求是否被服务器接受。

> 跨域请求中分为简单请求和预检请求两种，符合以下条件可视为简单请求

- 使用的 `HTTP method` 是 `GET` `POST` `HEAD`
- `content-type` 是 `text/plain mutipart/form-data application/x-www-form-urlencode` 三种之一
- 请求头只能包含这些

```text
- Accept
- Accept-Language
- Content-Language
- Content-Type （需要注意额外的限制）
- DPR
- Downlink
- Save-Data
- Viewport-Width
- Width
```

除去简单请求外，其他请求就会先触发预检请求。

常见的，比如使用

- `content-Type` 为 `application/xml` 或 `text/xml` 的 `POST` 请求
- 设置自定义头，比如 `X-JSON`、`X-MENGXIANHUI` 等

**预检请求返回的头部报文中有**

- `Access-Control-Allow-Origin`： 服务器可接受的请求来源
- `Access-Control-Request-Method`： 服务器实际请求所使用的 HTTP 方法
- `Access-Control-Request-Headers`： 服务器实际请求所携带的自定义首部字段

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_18-get可以上传图片吗)18 GET可以上传图片吗

> GET 请求是可以传图片的。图片的base64编码想必大家都见过：base64 的本质是字符串，而 GET 请求的参数在 url 里面，所以直接把图的 base64 数据放到 url 里面，就可以实现 GET 请求传图片

![img](http://img-repo.poetries.top/images/20210319105457.png)

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_19-cdn的作用和原理)19 CDN的作用和原理

> CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或者网络中，在用户访问网站的时候，将其指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。

**主要特点：**

1. 本地Cache加速：提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性。
2. 镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。
3. 远程加速：[远程访问 (opens new window)](https://baike.baidu.com/item/远程访问)用户根据DNS[负载均衡 (opens new window)](https://baike.baidu.com/item/负载均衡)技术智能自动选择Cache[服务器 (opens new window)](https://baike.baidu.com/item/服务器)，选择最快的Cache服务器，加快远程访问的速度。
4. 带宽优化：自动生成[服务器 (opens new window)](https://baike.baidu.com/item/服务器)的远程Mirror（[镜像 (opens new window)](https://baike.baidu.com/item/镜像)）cache服务器，[远程用户 (opens new window)](https://baike.baidu.com/item/远程用户)访问时从cache服务器上读取数据，减少[远程访问 (opens new window)](https://baike.baidu.com/item/远程访问)的带宽、分担网络流量、减轻原站点[WEB服务器 (opens new window)](https://baike.baidu.com/item/WEB服务器)负载等功能。
5. 集群抗攻击：广泛分布的CDN节点加上节点之间的智能[冗余 (opens new window)](https://baike.baidu.com/item/冗余)机制，可以有效地预防[黑客 (opens new window)](https://baike.baidu.com/item/黑客)入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。

**CDN作用**

> 使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率

**CDN原理**

最简单的`CDN`网络由一个DNS服务器和几台缓存服务器组成。而工作的核心就是缓存服务器，它记录了用户所需内容，而且离用户较近，负载较小，因此提高了服务器响应速度。

> 实际上`CDN`的工作过程要更复杂，为了便于理解，上面只是简述。我们从用户访问一个`URL`地址说起：`访问URL` => `CNAME指向的CDN专用DNS服务器对URL解析` => `负载均衡设备根据解析的ip地址和内容选择一台缓存服务器` => `返回缓存服务器ip地址给用户`

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#如何捕获cdn上的js运行时导致的详细错误信息)如何捕获CDN上的js运行时导致的详细错误信息？

> 当 CDN 设置了 `Access-Control-Allow-Origin` 响应头允许跨域时，我们可以给script标签添加crossOrigin属性，从而可以使用 window.onerror 捕获 CDN 上的 js 运行时导致的详细错误信息，包括堆栈等。

- 如果不设置`crossOrigin`属性，则可能只会捕获到script error，无法获取额外的堆栈信息。
- `crossOrigin`属性的值默认为`anonymous`，即不携带 cookie，如果设置为use-credentials，则会携带 cookie 和客户端证书等票据。

例如：

```javascript
<script src="https://qq.com/a.js" crossOrigin="anonymous"></script>
```

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_20-强缓存命中发生了什么)20 强缓存命中发生了什么？

当浏览器要向服务器获取某个资源的时候，是会先构建一个请求行，然后进行强缓存的查找。如果强缓存命中了此次实际上是没有发送请求的，浏览器直接使用了强缓存，在浏览器控制台中虽然会看到一个请求，但是这个请求的`Request Headers`中有`Provisional headers are shown`表示实际未发送请求，且状态码为`200 OK (from memory cache)`或者`from disk cache`等等。

如下图：

![img](https://poetries1.gitee.io/img-repo/2020/09/1.png)

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#默认的强制缓存时间是多少)默认的强制缓存时间是多少？

首先要明确两个响应头代表的含义：

1. `Date`: 指源服务器响应报文生成的时间，差不多与发请求的时间等价
2. `Last-Modified`: 指静态资源上次修改的时间，取决于 `mtime`

`LM factor` 算法认为当请求服务器时，如果没有设置 `Cache-Control`，如果距离上次的 `Last-Modified` 越远，则生成的强制缓存时间越长。

用公式表示如下，其中 `factor` 介于 0 与 1 之间：

```javascript
MaxAge = (Date - LastModified) * factor
```

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_21-cors跨域的原理)21 CORS跨域的原理

> 跨域资源共享(`CORS`)是一种机制，是W3C标准。它允许浏览器向跨源服务器，发出`XMLHttpRequest`或`Fetch`请求。并且整个`CORS`通信过程都是浏览器自动完成的，不需要用户参与。

而使用这种`跨域资源共享`的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种`"跨域"`请求。因此实现`CORS`的关键是服务器需要服务器。通常是有以下几个配置：

- **Access-Control-Allow-Origin**
- **Access-Control-Allow-Methods**
- **Access-Control-Allow-Headers**
- **Access-Control-Allow-Credentials**
- **Access-Control-Max-Age**

具体可看：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests

过程分析：

**简单回答**：

- 当我们发起跨域请求时，**如果是非简单请求**，浏览器会帮我们自动触发预检请求，也就是 OPTIONS 请求，用于确认目标资源是否支持跨域。**如果是简单请求，则不会触发预检，直接发出正常请求。**
- 浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。

**详细回答**：

- 浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。
- 服务器收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含 `Access-Control-Allow-origin` 字段，若配置过域名，则返回 `Access-Control-Allow-origin + 对应配置规则里的域名的方式`。
- 浏览器根据接受到的 响应头里的 `Access-Control-Allow-origin` 字段做匹配，若无该字段，说明不允许跨域，从而抛出一个错误；若有该字段，则对字段内容和当前域名做比对，如果同源，则说明可以跨域，浏览器接受该响应；若不同源，则说明该域名不可跨域，浏览器不接受该响应，并抛出一个错误。

在`CORS`中有`简单请求`和`非简单请求`，简单请求是不会触发`CORS`的预检请求的，而非简单请求会。

`“需预检的请求”`要求必须首先使用 [`OPTIONS` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#cors的哪些是简单请求)CORS的哪些是简单请求？

> 简单请求不会触发`CORS`的预检请求，若请求满足所有下述条件，则该请求可视为“简单请求”：

**简单回答**：

- 只能使用`GET`、`HEAD`、`POST`方法。使用`POST`方法向服务器发送数据时，`Content-Type`只能使用`application/x-www-form-urlencoded`、`multipart/form-data`或`text/plain`编码格式。
- 请求时不能使用自定义的`HTTP Headers`

**详细回答**：

- (一) 使用下列方法之一
  - `GET`
  - `HEAD`
  - `POST`
- (二) 只能设置以下集合中的请求头
  - `Accept`
  - `Accept-Language`
  - `Content-Language`
  - `Content-Type`(但是有限制)
  - `DPR`
  - `Downlink`
  - `Save-Data`
  - `Viewport-Width`
  - `Width`
- (三) `Content-Type`的值仅限于下面的三者之一
  - `text/plain`
  - `multipart/form-data`
  - `application/x-www-form-urlencoded`
- 请求中的任意[`XMLHttpRequestUpload` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload)对象均没有注册任何事件监听器；[`XMLHttpRequestUpload` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload)对象可以使用 [`XMLHttpRequest.upload` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload)属性访问。
- 请求中没有使用 [`ReadableStream` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)对象。

除了上面这些请求外，都是非简单请求。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#cors的预检请求具体是怎样的)CORS的预检请求具体是怎样的？

若是跨域的非简单请求的话，浏览器会首先向服务器发送一个预检请求，以获知服务器是否允许该实际请求。

整个过程大概是：

- 浏览器给服务器发送一个

  ```
  OPTIONS
  ```

  方法的请求，该请求会携带下面两个首部字段：

  - `Access-Control-Request-Method`: 实际请求要用到的方法
  - `Access-Control-Request-Headers`: 实际请求会携带哪些首部字段

- 若是服务器接受后续请求，则这次预请求的响应体中会携带下面的一些字段：

  - `Access-Control-Allow-Methods`: 服务器允许使用的方法
  - `Access-Control-Allow-Origin`: 服务器允许访问的域名
  - `Access-Control-Allow-Headers`: 服务器允许的首部字段
  - `Access-Control-Max-Age`: 该响应的有效时间(s),在有效时间内浏览器无需再为同一个请求发送预检请求

- 预检请求完毕之后，再发送实际请求

这里有两点要注意：

- `Access-Control-Request-Method`没有`s`
- `Access-Control-Allow-Methods`有`s`
- 关于`Access-Control-Max-Age`，浏览器自身也有维护一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效，而是以最大有效时间为主。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#为什么简单请求不需要预检)为什么简单请求不需要预检？

因为简单请求虽然是一种定义，不过它定义是有一定理由的，浏览器可能觉得这类请求预检的安全性没有那么大必要，不预检带来性能方面收益更大。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#复杂请求预检检查什么东西)复杂请求预检检查什么东西？

> 预检请求的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。例如，我某个请求只支持 `headers ,cc`，你发送了一个 `dd 的headers`， 那么 `options` 可以有效拦截，不会发出实体的请求，避免了一些安全问题。

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#如果cors附带身份凭证要怎样做)如果CORS附带身份凭证要怎样做？

对于跨域 [`XMLHttpRequest` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)或 [Fetch (opens new window)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)请求，浏览器**不会**发送身份凭证信息。如果要发送凭证信息，需要设置 `XMLHttpRequest`的某个特殊标志位。

例如我们想要在跨域请求中带上`cookie`，需要满足3个条件：

- web（浏览器）请求设置`withCredentials`为`true`
- 服务器设置首部字段`Access-Control-Allow-Credentials`为`true`
- 服务器的`Access-Control-Allow-Origin`不能为`*`

### [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#如何减少cors预请求的次数)如何减少CORS预请求的次数？

> 服务端设置`Access-Control-Max-Age`字段，在有效时间内浏览器无需再为同一个请求发送预检请求。但是它有局限性：只能为同一个请求缓存，无法针对整个域或者模糊匹配 URL 做缓存。

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_22-在深圳的网页上输入百度-是怎么把这个请求发到北京的)22 在深圳的网页上输入百度，是怎么把这个请求发到北京的

> 中间会经过很多的站点，比如会经过湖南，或者其它城市，由各个城市的这些站点一层一层分发下去。通过CDN层层分发

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_23-为什么使用多域名部署)23 为什么使用多域名部署？

主要是因为`http1`和浏览器的原因，同一时间同一个域名最多进行6个`tcp`连接。

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_24-页面10张img-http1是怎样的加载表现-怎样解决的)24 页面10张img，http1是怎样的加载表现？怎样解决的？

- `http1`下，浏览器对一个域名的最大`tcp`连接数为6，所以10张图片表现为`6 + 4`。
- 可以使用多域名部署解决。比如`5个a域名`和`5个b域名`，或者`6个a域名`和`4个b域名`，就可以实现一瞬间全部出来了。

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_25-说一说sso单点登录)25 说一说SSO单点登录

**概念：**

当用户在身份认证服务器上登录过一次之后，即可获取访问单点登录系统中的其它关联系统和应用软件的权限。

**实现机制**：

> 当用户第一次访问应用系统1的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket；用户再访问别的应用的时候就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。

需要注意两点：

- 系统共享，统一的认证系统
- 信息识别，让应用系统能够识别已经登录过的用户(其实要把ticket发送到认证系统进行校验)

**优点：**

- 单点登录：用户只需登录一次，即可通过单点登录系统（eTrueSSO）访问后台的多个 应用系统，二次登陆时无需重新输入用户名和密码
- 基于角色访问控制：根据用户的角色和URL实现访问控制功能
- 集群：通过集群功能，实现多台服务器之间的动态负载均衡
- 传输加密：支持多种对称和非对称加密算法，保证用户信息在传输过程中不被窃取和篡改

**缺点：**

- 不利于重构， 因为涉及到的系统很多，要重构必须要兼容所有的系统，可能很耗时
- 无人看守桌面，因为只需要登录一次，所有的授权的应用系统都可以访问，可能导致一些很重要的信息泄露

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_26-说一说oauth)26 说一说OAuth

> OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写。

**产生背景：**

典型案例：如果一个用户需要两项服务：一项服务是图片在线存储服务A，另一个是图片在线打印服务B。

由于服务A与服务B是由两家不同的服务提供商提供的，所以用户在这两家服务提供商的网站上各自注册了两个用户，假设这两个用户名各不相同，密码也各不相同。当用户

要使用服务B打印存储在服务A上的图片时，用户该如何处理？法一：用户可能先将待打印的图片从服务A上下载下来并上传到服务B上打印，这种方式安全但处理比较繁琐，效率低下；法二：用户将在服务A上注册的用户名与密码提供给服务B，服务B使用用户的[帐号 (opens new window)](https://baike.baidu.com/item/帐号)再去服务A处下载待打印的图片，这种方式效率是提高了，但是安全性大大降低了，服务B可以使用用户的用户名与密码去服务A上查看甚至篡改用户的资源。

**授权流程**

简单的来说，

OAUTH认证授权就三个步骤，三句话可以概括：

1. 获取未授权的Request Token
2. 获取用户授权的Request Token
3. 用授权的Request Token换取Access Token

当应用拿到Access Token后，就可以有权访问用户授权的资源了。大家可能看出来了，这三个步骤不就是对应OAUTH的三个URL服务地址嘛。一点没错，上面的三个步骤中，每个步骤分别请求一个URL，并且收到相关信息，并且拿到上步的相关信息去请求接下来的URL直到拿到Access Token。

## [#](http://interview.poetries.top/excellent-docs/14-HTTP模块.html#_27-http-中的-301、302、303、307、308-响应状态码)27 HTTP 中的 301、302、303、307、308 响应状态码

- ```
  301
  ```

   

  Moved Permanently

  - 301 状态码表明目标资源被永久的移动到了一个新的 URI，任何未来对这个资源的引用都应该使用新的 URI

- ```
  302
  ```

   

  Found

  - 302 状态码表示目标资源临时移动到了另一个 URI 上。由于重定向是临时发生的，所以客户端在之后的请求中还应该使用原本的 URI。
  - 服务器会在响应 Header 的 Location 字段中放上这个不同的 URI。浏览器可以使用 Location 中的 URI 进行自动重定向。
  - **注意**：由于历史原因，用户代理可能会在重定向后的请求中把 `POST 方法改为 GET 方法`。如果`不想这样，应该使用 307`（Temporary Redirect） 状态码

- ```
  303
  ```

   

  See Other

  - 303 状态码表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。
  - 303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。
  - 不管原请求是什么方法，重定向请求的方法都是 GET（或 HEAD，不常用）。
  - 303 和 302 的作用很类似，除去语义差别，似乎是 302 包含了 303 的情况。确实，这是由历史原因导致的

- ```
  307
  ```

   

  Temporary Redirect

  - 307 的定义实际上`和 302 是一致的`，唯一的区别在于，`307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上`。

- ```
  308
  ```

   

  Permanent Redirect

  - `308` 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上

**302 与 303、307 的关系**

- `302` 允许各种各样的重定向，一般情况下都会实现为到 `GET` 的重定向，但是不能确保 `POST` 会重定向为 `POST`
- `303` 只允许任意请求到 `GET` 的重定向
- `307` 和 `302` 一样，除了不允许 `POST` 到 `GET` 的重定向

**简要历史原因**

> 那为什么有了 307 和 303 还需要 302呢？把总结放在最前面。302 在最初的定义中，内容和现在的 307 是一样的，不允许重定向方法的改写（从 POST 到 GET，由于 GET 不应该有 body，实际上 body 也被改了）。但是早期浏览器在实现的时候有的实现成 303 的效果，有的实现成 307 的效果。于是在之后的标准，302 在某些浏览器中错误的实现被写进规范，成为 303，而 302 原本的效果被复制了到了 307。在最近的一次标准修订中，302 标准被修改成不再强制需要维持原请求的方法。所以就产生了现在的 302、303 和 307

**301 与 308 的历史**

> 和 302 一样，301 在浏览器中的实现和标准是不同的，这个时间一直延续到 2014 年的 RFC 7231，301 定义中的 Note 还是提到了这个问题。直到 2015 年 4 月，RFC 7538 提出了 308 的标准，类似 307 Temporary Redirect 之于 302 Found 的存在，308 成为了 301 的补充。



# 15 常用设计模式

## 1 创建型-工厂模式

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_1-1-简单工厂模式)1.1 简单工厂模式

> 其实就是**将创建对象的过程单独封装**，同时它的应用场景也非常容易识别：有构造函数的地方，我们就应该想到简单工厂；在写了大量构造函数、调用了大量的 new、自觉非常不爽的情况下，我们就应该思考是不是可以掏出工厂模式重构我们的代码了

```js
// 给不同工种分配职责说明
function User(name, age, career, work) {
    this.name = name;
    this.age = age;
    this.career = career;
    this.work = work;
}

function Factory(name, age, career) {
    let work;
    switch (career) {
        case 'coder': {
            work = ['写代码', '写系分', '修bug']
            break;
        }
        case 'product-manager': {
            work = ['订会议室', '写PRD', '催更']
            break;
        }
        case 'boss': {
            work = ['喝茶', '看报', '见客户']
            break;
        }
    }
    return new User(name, age, career, work)
}

const wang = new Factory('wang', 50, 'boss');
const sun = new Factory('sun', 25, 'coder');
const li = new Factory('li', 30, 'product-manager');

console.log(wang)
console.log(sun)
console.log(li)
```

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_1-2-抽象工厂模式)1.2 抽象工厂模式

```js
// 定义操作系统这类产品的抽象产品类
class OS {
    constructor() {
        if (new.target === OS) {
            throw new Error('不能实例化抽象类');
        }
    }
}

// 定义具体操作系统的具体产品类
class AndroidOS extends OS {
    constructor() {
        super();
    }

    controlHardware() {
        console.log('我会用安卓的方式去操作硬件');
    }
}

class AppleOS extends OS {
    constructor() {
        super();
    }

    controlHardware() {
        console.log('我会用苹果的方式去操作硬件');
    }
}

// 定义手机硬件这类产品的抽象产品类
class Hardware {
    constructor() {
        if (new.target === Hardware) {
            throw new Error('不能实例化抽象类');
        }
    }

    // 手机硬件的共性方法，这里提取了“根据命令运转”这个共性
    operateByOrder() {
        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');
    }
}

// 定义具体硬件的具体产品类
class QualcommHardware extends Hardware {
    constructor() {
        super();
    }

    operateByOrder() {
        console.log('我会用高通的方式去运转')
    }
}

class MiWare extends Hardware {
    constructor() {
        super();
    }

    operateByOrder() {
        console.log('我会用小米的方式去运转')
    }
}

class MobilePhoneFactory {
    // 提供操作系统的接口
    createOS() {
        throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！");
    }

    // 提供硬件的接口
    createHardware() {
        throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！");
    }
}

// 具体工厂继承自抽象工厂
class FakeStarFactory extends MobilePhoneFactory {
    constructor() {
        super()
    }

    createOS() {
        // 提供安卓系统实例
        return new AndroidOS()
    }

    createHardware() {
        // 提供高通硬件实例
        return new QualcommHardware()
    }
}

// 这是我的手机
const myPhone = new FakeStarFactory()
// 让它拥有操作系统
const myOS = myPhone.createOS()
// 让它拥有硬件
const myHardWare = myPhone.createHardware()
// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)
myOS.controlHardware()
// 唤醒硬件(输出‘我会用高通的方式去运转’)
myHardWare.operateByOrder()
```

**抽象工厂和简单工厂的思路，思考一下：它们之间有哪些异同？**

- 它们的共同点，在于都**尝试去分离一个系统中变与不变的部分**。
- 它们的不同在于**场景的复杂度**。

> 在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对**共性**作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_2-创建型-单例模式)2 创建型-单例模式

> **保证一个类仅有一个实例，并提供一个访问它的全局访问点**，这样的模式就叫做单例模式。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_2-1-单例模式的实现思路)2.1 单例模式的实现思路

- 单例模式想要做到的是，**不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例**。
- 要做到这一点，就需要构造函数**具备判断自己是否已经创建过一个实例**的能力。我们现在把这段判断逻辑写成一个静态方法(其实也可以直接写入构造函数的函数体里）：

```js
// 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
class Singleton {
    constructor(name) {
        this.name = name;
        this.instance = null;
    }

    getName(){
        console.log(this.name);
    }

    getInstance(name){
        if(!this.instance){
            this.instance = new Singleton(name);
        }

        return this.instance;
    }
}

const singleton = new Singleton();

const a = singleton.getInstance('a');
const b = singleton.getInstance('b');

console.log(a);
console.log(b);
console.log(a === b);
class SingleDog {
    show() {
        console.log('我是一个单例对象')
    }
    static getInstance() {
        // 判断是否已经new过1个实例
        if (!SingleDog.instance) {
            // 若这个唯一的实例不存在，那么先创建它
            SingleDog.instance = new SingleDog()
        }
        // 如果这个唯一的实例已经存在，则直接返回
        return SingleDog.instance
    }
}

const s1 = SingleDog.getInstance()
const s2 = SingleDog.getInstance()

// true
s1 === s2
```

除了楼上这种实现方式之外，`getInstance`的逻辑还可以用**闭包**来实现：

```js
SingleDog.getInstance = (function() {
    // 定义自由变量instance，模拟私有变量
    let instance = null
    return function() {
        // 判断自由变量是否为null
        if(!instance) {
            // 如果为null则new出唯一实例
            instance = new SingleDog()
        }
        return instance
    }
})()
```

> 可以看出，在`getInstance`方法的判断和拦截下，我们不管调用多少次，`SingleDog`都只会给我们返回一个实例，`s1`和`s2`现在都指向这个唯一的实例

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_2-2-生产实践-vuex中的单例模式)2.2 生产实践：Vuex中的单例模式

> `Redux` 和 `Vuex`，它们都实现了一个全局的 `Store` 用于存储应用的所有状态。这个 `Store` 的实现，正是单例模式的典型应用

**1. 理解 Vuex 中的 Store**

> `Vuex` 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 ——Vuex官方文档

当组件非常多、组件间关系复杂、且嵌套层级很深的时候，这种原始的通信方式会使我们的逻辑变得复杂难以维护。这时最好的做法是将共享的数据抽出来、放在全局，供组件们按照一定的的规则去存取数据，保证状态以一种可预测的方式发生变化。于是便有了 Vuex，这个用来存放共享数据的唯一数据源，就是 Store。

**2. Vuex如何确保Store的唯一性**

我们先来看看如何在项目中引入 `Vuex`：

```js
// 安装vuex插件
Vue.use(Vuex)

// 将store注入到Vue实例中
new Vue({
    el: '#app',
    store
})
```

> 通过调用`Vue.use()`方法，我们安装了 `Vuex` 插件。`Vuex` 插件是一个对象，它在内部实现了一个 `install` 方法，这个方法会在插件安装时被调用，从而把 `Store` 注入到`Vue`实例里去。也就是说每 `install` 一次，都会尝试给 `Vue` 实例注入一个 `Store`

在`install`方法里，有一段逻辑和我们楼上的 `getInstance` 非常相似的逻辑：

```js
let Vue // 这个Vue的作用和楼上的instance作用一样
...

export function install (_Vue) {
  // 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 若没有，则为这个Vue实例对象install一个唯一的Vuex
  Vue = _Vue
  // 将Vuex的初始化逻辑写进Vue的钩子函数里
  applyMixin(Vue)
}
```

> 楼上便是 `Vuex` 源码中单例模式的实现办法了，套路可以说和我们的`getInstance`如出一辙。通过这种方式，可以保证一个 `Vue` 实例（即一个 Vue 应用）只会被 `install` 一次 `Vuex` 插件，所以每个 Vue 实例只会拥有一个全局的 `Store`

**3. 思考时间**

> 思考一下：如果我在 `install` 里没有实现单例模式，会带来什么样的麻烦？

我们通过上面的源码解析可以看出，每次 `install` 都会为Vue实例初始化一个 `Store`。假如 `install` 里没有单例模式的逻辑，那我们如果在一个应用里不小心多次安装了插件：

```js
// 在主文件里安装Vuex
Vue.use(Vuex)

...(中间添加/修改了一些store的数据)

// 在后续的逻辑里不小心又安装了一次
Vue.use(Vuex)
```

失去了单例判断能力的 `install` 方法，会为当前的Vue实例重新注入一个新的 `Store`，也就是说你中间的那些数据操作全都没了，一切归 0。因此，单例模式在此处是非常必要的。

除了说在 `Vuex` 中大展身手，我们在 `Redux`、`jQuery` 等许多优秀的前端库里也都能看到单例模式的身影

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_2-3-单例模式-面试真题)2.3 单例模式——面试真题

> 实现一个 `Storage`

**1. 描述**

> 实现`Storage`，使得该对象为单例，基于 `localStorage` 进行封装。实现方法 `setItem(key,value)` 和 `getItem(key)`

**2. 思路**

> 具体实现上，把判断逻辑写入静态方法或者构造函数里都没关系，最好能把闭包的版本也写出来

**3. 实现：静态方法版**

```js
// 定义Storage
class Storage {
    static getInstance() {
        // 判断是否已经new过1个实例
        if (!Storage.instance) {
            // 若这个唯一的实例不存在，那么先创建它
            Storage.instance = new Storage()
        }
        // 如果这个唯一的实例已经存在，则直接返回
        return Storage.instance
    }
    getItem (key) {
        return localStorage.getItem(key)
    }
    setItem (key, value) {
        return localStorage.setItem(key, value)
    }
}

const storage1 = Storage.getInstance()
const storage2 = Storage.getInstance()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```

**4. 实现： 闭包版**

```js
// 先实现一个基础的StorageBase类，把getItem和setItem方法放在它的原型链上
function StorageBase () {}
StorageBase.prototype.getItem = function (key){
    return localStorage.getItem(key)
}
StorageBase.prototype.setItem = function (key, value) {
    return localStorage.setItem(key, value)
}

// 以闭包的形式创建一个引用自由变量的构造函数
const Storage = (function(){
    let instance = null
    return function(){
        // 判断自由变量是否为null
        if(!instance) {
            // 如果为null则new出唯一实例
            instance = new StorageBase()
        }
        return instance
    }
})()

// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果 
const storage1 = new Storage()
const storage2 = new Storage()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_2-4-实现一个全局的模态框)2.4 实现一个全局的模态框

> 实现一个全局唯一的Modal弹框

**思路**

这道题比较经典，基本上所有讲单例模式的文章都会以此为例，同时它也是早期单例模式在前端领域的最集中体现。

> 万变不离其踪，记住`getInstance`方法、记住`instance`变量、记住闭包和静态方法，这个题除了要多写点 HTML 和 `CSS` 之外，对大家来说完全不成问题。

**实现**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>单例模式弹框</title>
</head>
<style>
    #modal {
        height: 200px;
        width: 200px;
        line-height: 200px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 1px solid black;
        text-align: center;
    }
</style>
<body>
	<button id='open'>打开弹框</button>
	<button id='close'>关闭弹框</button>
</body>
<script>
    // 核心逻辑，这里采用了闭包思路来实现单例模式
    const Modal = (function() {
    	let modal = null
    	return function() {
            if(!modal) {
            	modal = document.createElement('div')
            	modal.innerHTML = '我是一个全局唯一的Modal'
            	modal.id = 'modal'
            	modal.style.display = 'none'
            	document.body.appendChild(modal)
            }
            return modal
    	}
    })()
    
    // 点击打开按钮展示模态框
    document.getElementById('open').addEventListener('click', function() {
        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理
    	const modal = new Modal()
    	modal.style.display = 'block'
    })
    
    // 点击关闭按钮隐藏模态框
    document.getElementById('close').addEventListener('click', function() {
    	const modal = new Modal()
    	if(modal) {
    	    modal.style.display = 'none'
    	}
    })
</script>
</html>
```

是不是发现又是熟悉的套路？又可以默写了？（ES6 版本的实现大家自己尝试默写一下，相信对现在的你来说已经非常简单了）。

这就是单例模式面试题的特点，准确地说，是所有设计模式相关面试题的特点——牢记核心思路，就能举一反三。所以说设计模式的学习是典型的一分耕耘一分收获，性价比极高。

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_3-结构型-装饰器模式)3 结构型-装饰器模式

> 装饰器模式，又名装饰者模式。它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_3-1-装饰器模式初相见)3.1 装饰器模式初相见

> 为了不被已有的业务逻辑干扰，当务之急就是将旧逻辑与新逻辑分离，**把旧逻辑抽出去**：

```js
// 将展示Modal的逻辑单独封装
function openModal() {
    const modal = new Modal()
    modal.style.display = 'block'
}
```

编写新逻辑：

```js
// 按钮文案修改逻辑
function changeButtonText() {
    const btn = document.getElementById('open')
    btn.innerText = '快去登录'
}

// 按钮置灰逻辑
function disableButton() {
    const btn =  document.getElementById('open')
    btn.setAttribute("disabled", true)
}

// 新版本功能逻辑整合
function changeButtonStatus() {
    changeButtonText()
    disableButton()
}
```

然后把三个操作逐个添加open按钮的监听函数里：

```js
document.getElementById('open').addEventListener('click', function() {
    openModal()
    changeButtonStatus()
})
```

如此一来，我们就实现了“只添加，不修改”的装饰器模式，使用changeButtonStatus的逻辑装饰了旧的按钮点击逻辑。以上是ES5中的实现，ES6中，我们可以以一种更加面向对象化的方式去写：

```js
// 定义打开按钮
class OpenButton {
    // 点击后展示弹框（旧逻辑）
    onClick() {
        const modal = new Modal()
    	modal.style.display = 'block'
    }
}

// 定义按钮对应的装饰器
class Decorator {
    // 将按钮实例传入
    constructor(open_button) {
        this.open_button = open_button
    }
    
    onClick() {
        this.open_button.onClick()
        // “包装”了一层新逻辑
        this.changeButtonStatus()
    }
    
    changeButtonStatus() {
        this.changeButtonText()
        this.disableButton()
    }
    
    disableButton() {
        const btn =  document.getElementById('open')
        btn.setAttribute("disabled", true)
    }
    
    changeButtonText() {
        const btn = document.getElementById('open')
        btn.innerText = '快去登录'
    }
}

const openButton = new OpenButton()
const decorator = new Decorator(openButton)

document.getElementById('open').addEventListener('click', function() {
    // openButton.onClick()
    // 此处可以分别尝试两个实例的onClick方法，验证装饰器是否生效
    decorator.onClick()
})
```

> 大家这里需要特别关注一下 ES6 这个版本的实现，这里我们把按钮实例传给了 Decorator，以便于后续 Decorator 可以对它为所欲为进行逻辑的拓展。在 ES7 中，`Decorator` 作为一种语法被直接支持了，它的书写会变得更加简单，但背后的原理其实与此大同小异

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_3-2-深入装饰器原理)3.2 深入装饰器原理

在 ES7 中，我们可以像写 python 一样通过一个`@`语法糖轻松地给一个类装上装饰器：

```js
// 装饰器函数，它的第一个参数是目标类
function classDecorator(target) {
    target.hasDecorator = true
  	return target
}

// 将装饰器“安装”到Button类上
@classDecorator
class Button {
    // Button类的相关逻辑
}

// 验证装饰器是否生效
console.log('Button 是否被装饰了：', Button.hasDecorator)
```

也可以用同样的语法糖去装饰类里面的方法：

```js
// 具体的参数意义，在下个小节，这里大家先感知一下操作
function funcDecorator(target, name, descriptor) {
  let originalMethod = descriptor.value
  descriptor.value = function() {
    console.log('我是Func的装饰器逻辑')
    return originalMethod.apply(this, arguments)
  }
  return descriptor
}

class Button {
    @funcDecorator
    onClick() { 
        console.log('我是Func的原有逻辑')
    }
}

// 验证装饰器是否生效
const button = new Button()
button.onClick()
```

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_3-3-装饰器语法糖背后的故事)3.3 装饰器语法糖背后的故事

> 所谓语法糖，往往意味着“美好的表象”。正如 `class` 语法糖背后是大家早已十分熟悉的 ES5 构造函数一样，装饰器语法糖背后也是我们的老朋友，不信我们一起来看看`@decorator`都帮我们做了些什么：

> 上一节我们使用 `ES6` 实现装饰器模式时曾经将按钮实例传给了 `Decorator`，以便于后续 `Decorator` 可以对它进行逻辑的拓展。这也正是装饰器的最最基本操作——定义装饰器函数，将被装饰者“交给”装饰器。这也正是装饰器语法糖首先帮我们做掉的工作 —— 函数传参&调用。

**1. 类装饰器的参数**

当我们给一个类添加装饰器时：

```js
function classDecorator(target) {
    target.hasDecorator = true
  	return target
}

// 将装饰器“安装”到Button类上
@classDecorator
class Button {
    // Button类的相关逻辑
}
```

此处的 `target` 就是被装饰的类本身。

**2. 方法装饰器的参数**

而当我们给一个方法添加装饰器时：

```js
function funcDecorator(target, name, descriptor) {
    let originalMethod = descriptor.value
    descriptor.value = function() {
    console.log('我是Func的装饰器逻辑')
    return originalMethod.apply(this, arguments)
  }
  return descriptor
}

class Button {
    @funcDecorator
    onClick() { 
        console.log('我是Func的原有逻辑')
    }
}   
```

此处的 `target` 变成了`Button.prototype`，即类的原型对象。这是因为 `onClick` 方法总是要依附其实例存在的，修饰 `onClik` 其实是修饰它的实例。但我们的装饰器函数执行的时候，`Button` 实例还**并不存在**。为了确保实例生成后可以顺利调用被装饰好的方法，装饰器只能去修饰 `Button` 类的原型对象。

**3. 装饰器函数调用的时机**

> 装饰器函数执行的时候，`Button` 实例还并不存在。这是因为实例是在我们的代码**运行时**动态生成的，而装饰器函数则是在**编译阶段**就执行了。所以说装饰器函数真正能触及到的，就只有类这个层面上的对象

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_3-4-将-属性描述对象-交到你手里)3.4 将“属性描述对象”交到你手里

> 在编写类装饰器时，我们一般获取一个`target`参数就足够了。但在编写方法装饰器时，我们往往需要至少三个参数：

```js
function funcDecorator(target, name, descriptor) {
  let originalMethod = descriptor.value
  descriptor.value = function() {
    console.log('我是Func的装饰器逻辑')
    return originalMethod.apply(this, arguments)
  }
  return descriptor
}
```

> 第一个参数的意义，前文已经解释过。第二个参 数name，是我们修饰的目标属性属性名，也没啥好讲的。关键就在这个 d`escriptor` 身上，它也是我们使用频率最高的一个参数，它的真面目就是“属性描述对象”（`attributes object`）。这个名字大家可能不熟悉，但`Object.defineProperty`方法我想大家多少都用过，它的调用方式是这样的：

```js
Object.defineProperty(obj, prop, descriptor)
```

> 此处的`descriptor`和装饰器函数里的 `descriptor` 是一个东西，它是 `JavaScript` 提供的一个内部数据结构、一个对象，专门用来描述对象的属性。它由各种各样的属性描述符组成，这些描述符又分为数据描述符和存取描述符：

- 数据描述符：
  - 包括 `value`（存放属性值，默认为默认为 `undefined`）
  - `writable`（表示属性值是否可改变，默认为true）
  - `enumerable`（表示属性是否可枚举，默认为 `true`）
  - `configurable`（属性是否可配置，默认为`true`）。
- 存取描述符：
  - 包括 `get` 方法（访问属性时调用的方法，默认为 `undefined`）
  - `set`（设置属性时调用的方法，默认为 `undefined` ）

> 很明显，拿到了 `descriptor`，就相当于拿到了目标方法的控制权。通过修改 `descriptor`，我们就可以对目标方法为所欲为的逻辑进行拓展了~

> 在上文的示例中，我们通过 `descriptor` 获取到了原函数的函数体（`originalMethod`），把原函数推迟到了新逻辑（console）的后面去执行。这种做法和我们上一节在ES5中实现装饰器模式时做的事情一模一样，所以说装饰器就是这么回事儿，换汤不换药~

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_3-5-react中的装饰器-hoc)3.5 React中的装饰器：HOC

> 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。

HOC (Higher Order Component) 即高阶组件。它是装饰器模式在 React 中的实践，同时也是 React 应用中非常重要的一部分。通过编写高阶组件，我们可以充分复用现有逻辑，提高编码效率和代码的健壮性。

我们现在编写一个高阶组件，它的作用是把传入的组件**丢进一个有红色边框的容器里**（拓展其样式）。

```js
import React, { Component } from 'react'

const BorderHoc = WrappedComponent => class extends Component {
  render() {
    return <div style={{ border: 'solid 1px red' }}>
      <WrappedComponent />
    </div>
  }
}
export default borderHoc
```

用它来装饰目标组件

```js
import React, { Component } from 'react'
import BorderHoc from './BorderHoc'

// 用BorderHoc装饰目标组件
@BorderHoc 
class TargetComponent extends React.Component {
  render() {
    // 目标组件具体的业务逻辑
  }
}

// export出去的其实是一个被包裹后的组件
export default TargetComponent
```

> 可以看出，高阶组件从实现层面来看其实就是上文我们提到的类装饰器。在高阶组件的辅助下，我们不必因为一个小小的拓展而大费周折地编写新组件或者把一个新逻辑重写 `N` 多次，只需要轻轻 `@` 一下装饰器即可。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_3-6-使用装饰器改写-redux-connect)3.6 使用装饰器改写 Redux connect

> Redux 是热门的状态管理工具。在 React 中，当我们想要引入 Redux 时，通常需要调用 connect 方法来把状态和组件绑在一起：

```js
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { bindActionCreators } from 'redux'
import action from './action.js'

class App extends Component {
  render() {
    // App的业务逻辑
  }
}

function mapStateToProps(state) {
  // 假设App的状态对应状态树上的app节点
  return state.app
}

function mapDispatchToProps(dispatch) {
  // 这段看不懂也没关系，下面会有解释。重点理解connect的调用即可
  return bindActionCreators(action, dispatch)
}

// 把App组件与Redux绑在一起
export default connect(mapStateToProps, mapDispatchToProps)(App)
```

这里给没用过 redux 的同学解释一下 connect 的两个入参：`mapStateToProps` 是一个函数，它可以建立组件和状态之间的映射关系；`mapDispatchToProps`也是一个函数，它用于建立组件和`store.dispatch`的关系，使组件具备通过 dispatch 来派发状态的能力。

> 总而言之，我们调用 connect 可以返回一个**具有装饰作用的函数**，这个函数可以接收一 个React 组件作为参数，使这个目标组件和 Redux 结合、具备 Redux 提供的数据和能力。既然有装饰作用，既然是**能力的拓展**，那么就一定能用装饰器来改写：

把 `connect` 抽出来：

```js
import { connect } from 'react-redux'
import { bindActionCreators } from 'redux'
import action from './action.js'

function mapStateToProps(state) {
  return state.app
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators(action, dispatch)
}

// 将connect调用后的结果作为一个装饰器导出
export default connect(mapStateToProps, mapDispatchToProps)
```

在组件文件里引入`connect`：

```js
import React, { Component } from 'react'
import connect from './connect.js'   

@connect
export default class App extends Component {
  render() {
    // App的业务逻辑
  }
}
```

这样一来，我们的代码结构是不是清晰了很多

> 推荐一个非常赞的装饰模式库 —— [core-decorators (opens new window)](https://github.com/jayphelps/core-decorators)。core-decorators 帮我们实现好了一些使用频率较高的装饰器，比如`@readonly`(使目标属性只读)、`@deprecate`(在控制台输出警告，提示用户某个指定的方法已被废除)等

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_4-结构型-适配器模式)4 结构型-适配器模式

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_4-1-兼容接口)4.1 兼容接口

> 大家知道我们现在有一个非常好用异步方案叫`fetch`，它的写法比`ajax`优雅很多。因此在不考虑兼容性的情况下，我们更愿意使用`fetch`、而不是使用ajax来发起异步请求。李雷是拜`fetch`教的忠实信徒，为了能更好地使用`fetch`，他封装了一个基于`fetch`的`http`方法库：

```js
export default class HttpUtils {
  // get方法
  static get(url) {
    return new Promise((resolve, reject) => {
      // 调用fetch
      fetch(url)
        .then(response => response.json())
        .then(result => {
          resolve(result)
        })
        .catch(error => {
          reject(error)
        })
    })
  }
  
  // post方法，data以object形式传入
  static post(url, data) {
    return new Promise((resolve, reject) => {
      // 调用fetch
      fetch(url, {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        // 将object类型的数据格式化为合法的body参数
        body: this.changeData(data)
      })
        .then(response => response.json())
        .then(result => {
          resolve(result)
        })
        .catch(error => {
          reject(error)
        })
    })
  }
  
  // body请求体的格式化方法
  static changeData(obj) {
    var prop,
      str = ''
    var i = 0
    for (prop in obj) {
      if (!prop) {
        return
      }
      if (i == 0) {
        str += prop + '=' + obj[prop]
      } else {
        str += '&' + prop + '=' + obj[prop]
      }
      i++
    }
    return str
  }
}
```

当我想使用 `fetch` 发起请求时，只需要这样轻松地调用，而不必再操心繁琐的数据配置和数据格式化：

```js
// 定义目标url地址
const URL = "xxxxx"
// 定义post入参
const params = {
    ...
}

// 发起post请求
 const postResponse = await HttpUtils.post(URL,params) || {}
 
 // 发起get请求
 const getResponse = await HttpUtils.get(URL)
```

> 真是个好用的方法库！老板看了李雷的 `HttpUtils` 库，喜上眉梢——原来老板也是个拜 fetch 教。老板说李雷，咱们公司以后要做潮流公司了，写代码不再考虑兼容性，我希望你能**把公司所有的业务的网络请求都迁移到你这个 HttpUtils 上来**，这样以后你只用维护这一个库了，也方便。李雷一听，悲从中来——他是该公司的第 99 代员工，对远古时期的业务一无所知。而该公司第1代员工封装的网络请求库，是基于 `XMLHttpRequest` 的，差不多长这样：

```js
function Ajax(type, url, data, success, failed){
    // 创建ajax对象
    var xhr = null;
    if(window.XMLHttpRequest){
        xhr = new XMLHttpRequest();
    } else {
        xhr = new ActiveXObject('Microsoft.XMLHTTP')
    }
 
   ...(此处省略一系列的业务逻辑细节)
   
   var type = type.toUpperCase();
    
    // 识别请求类型
    if(type == 'GET'){
        if(data){
          xhr.open('GET', url + '?' + data, true); //如果有数据就拼接
        } 
        // 发送get请求
        xhr.send();
 
    } else if(type == 'POST'){
        xhr.open('POST', url, true);
        // 如果需要像 html 表单那样 POST 数据，使用 setRequestHeader() 来添加 http 头。
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        // 发送post请求
        xhr.send(data);
    }
 
    // 处理返回数据
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4){
            if(xhr.status == 200){
                success(xhr.responseText);
            } else {
                if(failed){
                    failed(xhr.status);
                }
            }
        }
    }
}
```

实现逻辑我们简单描述了一下，这个不是重点，重点是它是这样调用的：

```js
// 发送get请求
Ajax('get', url地址, post入参, function(data){
    // 成功的回调逻辑
}, function(error){
    // 失败的回调逻辑
})
```

李雷佛了 —— 不仅接口名不同，入参方式也不一样，这手动改要改到何年何日呢？

> 还好李雷学过设计模式，他立刻联想到了专门为我们**抹平差异**的适配器模式。要把老代码迁移到新接口，不一定要挨个儿去修改每一次的接口调用——正如我们想用 iPhoneX + 旧耳机听歌，不必挨个儿去改造耳机一样，我们只需要在引入接口时进行**一次适配**，便可轻松地 cover 掉业务里可能会有的**多次调用**（具体的解析在注释里）：

```js
// Ajax适配器函数，入参与旧接口保持一致
async function AjaxAdapter(type, url, data, success, failed) {
    const type = type.toUpperCase()
    let result
    try {
         // 实际的请求全部由新接口发起
         if(type === 'GET') {
            result = await HttpUtils.get(url) || {}
        } else if(type === 'POST') {
            result = await HttpUtils.post(url, data) || {}
        }
        // 假设请求成功对应的状态码是1
        result.statusCode === 1 && success ? success(result) : failed(result.statusCode)
    } catch(error) {
        // 捕捉网络错误
        if(failed){
            failed(error.statusCode);
        }
    }
}

// 用适配器适配旧的Ajax方法
async function Ajax(type, url, data, success, failed) {
    await AjaxAdapter(type, url, data, success, failed)
}
```

> 如此一来，我们只需要编写一个适配器函数`AjaxAdapter`，并用适配器去承接旧接口的参数，就可以实现新旧接口的无缝衔接了~

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_4-2-生产实践-axios中的适配器)4.2 生产实践：axios中的适配器

> 数月之后，李雷的老板发现了网络请求神库axios，于是团队的方案又整个迁移到了`axios`——对于心中有适配器的李雷来说，这现在已经根本不是个事儿。不过本小节我们要聊的可不再是“如何使现有接口兼容axios”了。此处引出axios，一是因为大家对它足够熟悉（不熟悉的同学，点[这里 (opens new window)](https://github.com/axios/axios)可以快速熟悉一下~），二是因为axios本身就用到了我们的**适配器模式**，它的兼容方案值得我们学习和借鉴。

在使用`axios`时，作为用户我们只需要掌握以下面三个最常用的接口为代表的一套`api`：

```js
// Make a request for a user with a given ID
axios.get('/user?ID=12345')
  .then(function (response) {
    // handle success
    console.log(response);
  })
  .catch(function (error) {
    // handle error
    console.log(error);
  })
  .then(function () {
    // always executed
  })   
     
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });   

axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
})
```

- 便可轻松地发起各种姿势的网络请求，而不用去关心底层的实现细节。
- 除了简明优雅的api之外，axios 强大的地方还在于，它不仅仅是一个局限于浏览器端的库。在Node环境下，我们尝试调用上面的 api，会发现它照样好使 —— axios 完美地**抹平了两种环境下api的调用差异**，靠的正是对适配器模式的灵活运用。

> 在 [axios 的核心逻辑 (opens new window)](https://github.com/axios/axios/blob/master/lib/core/Axios.js)中，我们可以注意到实际上派发请求的是 [dispatchRequest 方法 (opens new window)](https://github.com/axios/axios/blob/master/lib/core/dispatchRequest.js)。该方法内部其实主要做了两件事：

1. 数据转换，转换请求体/响应体，可以理解为数据层面的适配；
2. 调用适配器。

> 调用适配器的逻辑如下：

```js
// 若用户未手动配置适配器，则使用默认的适配器
var adapter = config.adapter || defaults.adapter;
  
  // dispatchRequest方法的末尾调用的是适配器方法
  return adapter(config).then(function onAdapterResolution(response) {
    // 请求成功的回调
    throwIfCancellationRequested(config);

    // 转换响应体
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    // 请求失败的回调
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // 转换响应体
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
```

大家注意注释的第一行，“若用户未手动配置适配器，则使用默认的适配器”。手动配置适配器允许我们自定义处理请求，主要目的是为了使测试更轻松。

> 实际开发中，我们使用默认适配器的频率更高。默认适配器在[`axios/lib/default.js` (opens new window)](https://github.com/axios/axios/blob/master/lib/defaults.js)里是通过`getDefaultAdapter`方法来获取的：

```js
function getDefaultAdapter() {
  var adapter;
  // 判断当前是否是node环境
  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // 如果是node环境，调用node专属的http适配器
    adapter = require('./adapters/http');
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // 如果是浏览器环境，调用基于xhr的适配器
    adapter = require('./adapters/xhr');
  }
  return adapter;
}
```

我们再来看看 `Node` 的 `http` 适配器和 `xhr` 适配器大概长啥样：

> `http` 适配器：

```js
module.exports = function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    // 具体逻辑
  }
}
```

> xhr 适配器：

```js
module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    // 具体逻辑
  }
}
```

> 具体逻辑啥样，咱们目前先不关心，有兴趣的同学，可以狠狠地点[这里 (opens new window)](https://github.com/axios/axios/tree/master/lib/adapters)阅读源码。咱们现在就注意两个事儿：

- 两个适配器的入参都是 `config`；
- 两个适配器的出参都是一个 `Promise`。

> Tips：要是仔细读了源码，会发现两个适配器中的 P`romise` 的内部结构也是如出一辙。

这么一来，通过 `axios` 发起跨平台的网络请求，不仅调用的接口名是同一个，连入参、出参的格式都只需要掌握同一套。这导致它的学习成本非常低，开发者看了文档就能上手；同时因为足够简单，在使用的过程中也不容易出错，带来了极佳的用户体验，`axios` 也因此越来越流行。

这正是一个好的适配器的自我修养——把变化留给自己，把统一留给用户。在此处，所有关于 `http` 模块、关于 `xhr` 的实现细节，全部被 `Adapter` 封装进了自己复杂的底层逻辑里，暴露给用户的都是十分简单的统一的东西——统一的接口，统一的入参，统一的出参，统一的规则。用起来就是一个字 —— 爽！

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_5-结构型-代理模式)5 结构型-代理模式

> 代理模式，式如其名——在某些情况下，出于种种考虑/限制，一个对象**不能直接访问**另一个对象，需要一个**第三者**（代理）牵线搭桥从而间接达到访问目的，这样的模式就是代理模式。

代理模式非常好理解，因为你可能天天都在用，只是没有刻意挖掘过它背后的玄机——比如大家耳熟能详的**科学上网**，就是代理模式的典型案例。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_5-1-es6中的proxy)5.1 ES6中的Proxy

在 ES6 中，提供了专门以代理角色出现的代理器 —— `Proxy`。它的基本用法如下：

```js
const proxy = new Proxy(obj, handler)
```

第一个参数是我们的目标对象，也就是上文中的“未知妹子”。`handler` 也是一个对象，用来定义**代理的行为**，相当于上文中的“婚介所”。当我们通过 `proxy` 去访问目标对象的时候，`handler`会对我们的行为作一层拦截，我们的每次访问都需要经过 `handler` 这个第三方。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_5-2-婚介所-的实现)5.2 “婚介所”的实现

未知妹子的个人信息，刚问了下我们已经注册了 VIP 的同事哥，大致如下：

```js
// 未知妹子
const girl = {
  // 姓名
  name: '小美',
  // 自我介绍
  aboutMe: '...'（大家自行脑补吧）
  // 年龄
  age: 24,
  // 职业
  career: 'teacher',
  // 假头像
  fakeAvatar: 'xxxx'(新垣结衣的图片地址）
  // 真实头像
  avatar: 'xxxx'(自己的照片地址),
  // 手机号
  phone: 123456,
}
```

婚介所收到了小美的信息，开始营业。大家想，这个姓名、自我介绍、假头像，这些信息大差不差，曝光一下没问题。但是人家妹子的年龄、职业、真实头像、手机号码，是不是属于非常私密的信息了？要想 get 这些信息，平台要考验一下你的诚意了 —— 首先，你是不是已经通过了实名审核？如果通过实名审核，那么你可以查看一些相对私密的信息（年龄、职业）。然后，你是不是 VIP ？只有 VIP 可以查看真实照片和联系方式。满足了这两个判定条件，你才可以顺利访问到别人的全部私人信息，不然，就劝退你提醒你去完成认证和VIP购买再来。

```js
// 普通私密信息
const baseInfo = ['age', 'career']
// 最私密信息
const privateInfo = ['avatar', 'phone']

// 用户（同事A）对象实例
const user = {
  ...(一些必要的个人信息)
  isValidated: true,
  isVIP: false,
}

// 婚介所登场了
const lovers = new Proxy(girl, {
  get: function(girl, key) {
      if(baseInfo.indexOf(key)!==-1 && !user.isValidated) {
          alert('您还没有完成验证哦')
          return
      }
      
      //...(此处省略其它有的没的各种校验逻辑)
    
      // 此处我们认为只有验证过的用户才可以购买VIP
      if(user.isValidated && privateInfo.indexOf(key) && !user.isVIP) {
          alert('只有VIP才可以查看该信息哦')
          return
      }
  }
})
```

> 以上主要是 `getter` 层面的拦截。假设我们还允许会员间互送礼物，每个会员可以告知婚介所自己愿意接受的礼物的价格下限，我们还可以作 `setter` 层面的拦截。：

```js
// 规定礼物的数据结构由type和value组成
const present = {
    type: '巧克力',
    value: 60,
}

// 为用户增开presents字段存储礼物
const girl = {
  // 姓名
  name: '小美',
  // 自我介绍
  aboutMe: '...'（大家自行脑补吧）
  // 年龄
  age: 24,
  // 职业
  career: 'teacher',
  // 假头像
  fakeAvatar: 'xxxx'(新垣结衣的图片地址）
  // 真实头像
  avatar: 'xxxx'(自己的照片地址),
  // 手机号
  phone: 123456,
  // 礼物数组
  presents: [],
  // 拒收50块以下的礼物
  bottomValue: 50,
  // 记录最近一次收到的礼物
  lastPresent: present,
}

// 婚介所推出了小礼物功能
const lovers = new Proxy(girl, {
  get: function(girl, key) {
    if(baseInfo.indexOf(key)!==-1 && !user.isValidated) {
        alert('您还没有完成验证哦')
        return
    }
    
    //...(此处省略其它有的没的各种校验逻辑)
  
    // 此处我们认为只有验证过的用户才可以购买VIP
    if(user.isValidated && privateInfo.indexOf(key) && !user.isVIP) {
        alert('只有VIP才可以查看该信息哦')
        return
    }
  }
  
  set: function(girl, key, val) {
    // 最近一次送来的礼物会尝试赋值给lastPresent字段
    if(key === 'lastPresent') {
      if(val.value < girl.bottomValue) {
          alert('sorry，您的礼物被拒收了')
          return
      }
    
      // 如果没有拒收，则赋值成功，同时并入presents数组
      girl[lastPresent] = val
      girl[presents] = [...presents, val]
    }
  }
 
})
```

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_5-3-事件代理)5.3 事件代理

> 事件代理，可能是代理模式最常见的一种应用方式，也是一道实打实的高频面试题。它的场景是一个父元素下有多个子元素，像这样：

事件代理，可能是代理模式最常见的一种应用方式，也是一道实打实的高频面试题。它的场景是一个父元素下有多个子元素，像这样：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>事件代理</title>
</head>
<body>
  <div id="father">
    <a href="#">链接1号</a>
    <a href="#">链接2号</a>
    <a href="#">链接3号</a>
    <a href="#">链接4号</a>
    <a href="#">链接5号</a>
    <a href="#">链接6号</a>
  </div>
</body>
</html>
```

我们现在的需求是，希望鼠标点击每个 a 标签，都可以弹出“我是xxx”这样的提示。比如点击第一个 a 标签，弹出“我是链接1号”这样的提示。这意味着我们至少要安装 `6` 个监听函数给 `6` 个不同的的元素(一般我们会用循环，代码如下所示），如果我们的 `a` 标签进一步增多，那么性能的开销会更大。

```js
// 假如不用代理模式，我们将循环安装监听函数
const aNodes = document.getElementById('father').getElementsByTagName('a')
  
const aLength = aNodes.length

for(let i=0;i<aLength;i++) {
    aNodes[i].addEventListener('click', function(e) {
        e.preventDefault()
        alert(`我是${aNodes[i].innerText}`)                  
    })
}
```

> 考虑到事件本身具有“冒泡”的特性，当我们点击 a 元素时，点击事件会“冒泡”到父元素 div 上，从而被监听到。如此一来，点击事件的监听函数只需要在 div 元素上被绑定一次即可，而不需要在子元素上被绑定 N 次——这种做法就是事件代理，它可以很大程度上提高我们代码的性能。

**事件代理的实现**

用代理模式实现多个子元素的事件监听，代码会简单很多：

```js
// 获取父元素
const father = document.getElementById('father')

// 给父元素安装一次监听函数
father.addEventListener('click', function(e) {
    // 识别是否是目标子元素
    if(e.target.tagName === 'A') {
        // 以下是监听函数的函数体
        e.preventDefault()
        alert(`我是${e.target.innerText}`)
    }
} )
```

在这种做法下，我们的点击操作并不会直接触及目标子元素，而是由父元素对事件进行处理和分发、间接地将其作用于子元素，因此这种操作从模式上划分属于代理模式。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_5-4-虚拟代理)5.4 虚拟代理

简单地给大家描述一下懒加载是个什么东西：它是针对图片加载时机的优化：在一些图片量比较大的网站，比如电商网站首页，或者团购网站、小游戏首页等。如果我们尝试在用户打开页面的时候，就把所有的图片资源加载完毕，那么很可能会造成白屏、卡顿等现象。

此时我们会采取“先占位、后加载”的方式来展示图片 —— 在元素露出之前，我们给它一个 div 作占位，当它滚动到可视区域内时，再即时地去加载真实的图片资源，这样做既减轻了性能压力、又保住了用户体验。

除了图片懒加载，还有一种操作叫**图片预加载**。预加载主要是为了避免网络不好、或者图片太大时，页面长时间给用户留白的尴尬。常见的操作是先让这个 img 标签展示一个占位图，然后创建一个 Image 实例，让这个 Image 实例的 src 指向真实的目标图片地址、观察该 Image 实例的加载情况 —— 当其对应的真实图片加载完毕后，即已经有了该图片的缓存内容，再将 DOM 上的 img 元素的 src 指向真实的目标图片地址。此时我们直接去取了目标图片的缓存，所以展示速度会非常快，从占位图到目标图片的时间差会非常小、小到用户注意不到，这样体验就会非常好了。

上面的思路，我们可以不假思索地实现如下

```js
class PreLoadImage {
    // 占位图的url地址
    static LOADING_URL = 'xxxxxx'
    
    constructor(imgNode) {
        // 获取该实例对应的DOM节点
        this.imgNode = imgNode
    }
    
    // 该方法用于设置真实的图片地址
    setSrc(targetUrl) {
        // img节点初始化时展示的是一个占位图
        this.imgNode.src = PreLoadImage.LOADING_URL
        // 创建一个帮我们加载图片的Image实例
        const image = new Image()
        // 监听目标图片加载的情况，完成时再将DOM上的img节点的src属性设置为目标图片的url
        image.onload = () => {
            this.imgNode.src = targetUrl
        }
        // 设置src属性，Image实例开始加载图片
        image.src = srcUrl
    }
}
```

这个 `PreLoadImage` 乍一看没问题，但其实违反了我们设计原则中的**单一职责原则**。`PreLoadImage` 不仅要负责图片的加载，还要负责 `DOM` 层面的操作（img 节点的初始化和后续的改变）。这样一来，就**出现了两个可能导致这个类发生变化的原因**。

> 好的做法是将两个逻辑分离，让 `PreLoadImage` 专心去做 DOM 层面的事情（真实 DOM 节点的获取、img 节点的链接设置），再找一个对象来专门来帮我们搞加载——这两个对象之间缺个媒婆，这媒婆非代理器不可：

```js
class PreLoadImage {
    constructor(imgNode) {
        // 获取真实的DOM节点
        this.imgNode = imgNode
    }
     
    // 操作img节点的src属性
    setSrc(imgUrl) {
        this.imgNode.src = imgUrl
    }
}

class ProxyImage {
    // 占位图的url地址
    static LOADING_URL = 'xxxxxx'

    constructor(targetImage) {
        // 目标Image，即PreLoadImage实例
        this.targetImage = targetImage
    }
    
    // 该方法主要操作虚拟Image，完成加载
    setSrc(targetUrl) {
       // 真实img节点初始化时展示的是一个占位图
        this.targetImage.setSrc(ProxyImage.LOADING_URL)
        // 创建一个帮我们加载图片的虚拟Image实例
        const virtualImage = new Image()
        // 监听目标图片加载的情况，完成时再将DOM上的真实img节点的src属性设置为目标图片的url
        virtualImage.onload = () => {
            this.targetImage.setSrc(targetUrl)
        }
        // 设置src属性，虚拟Image实例开始加载图片
        virtualImage.src = targetUrl
    }
}
```

> `ProxyImage` 帮我们调度了预加载相关的工作，我们可以通过 `ProxyImage` 这个代理，实现对真实 img 节点的间接访问，并得到我们想要的效果。

在这个实例中，`virtualImage` 这个对象是一个“幕后英雄”，它始终存在于 JavaScript 世界中、代替真实 DOM 发起了图片加载请求、完成了图片加载工作，却从未在渲染层面抛头露面。因此这种模式被称为“虚拟代理”模式。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_5-5-缓存代理)5.5 缓存代理

> 缓存代理比较好理解，它应用于一些计算量较大的场景里。在这种场景下，我们需要“用空间换时间”——当我们需要用到某个已经计算过的值的时候，不想再耗时进行二次计算，而是希望能从内存里去取出现成的计算结果。这种场景下，就需要一个代理来帮我们在进行计算的同时，进行计算结果的缓存了。

一个比较典型的例子，是对传入的参数进行求和：

```js
// addAll方法会对你传入的所有参数做求和操作
const addAll = function() {
    console.log('进行了一次新计算')
    let result = 0
    const len = arguments.length
    for(let i = 0; i < len; i++) {
        result += arguments[i]
    }
    return result
}

// 为求和方法创建代理
const proxyAddAll = (function(){
    // 求和结果的缓存池
    const resultCache = {}
    return function() {
        // 将入参转化为一个唯一的入参字符串
        const args = Array.prototype.join.call(arguments, ',')
        
        // 检查本次入参是否有对应的计算结果
        if(args in resultCache) {
            // 如果有，则返回缓存池里现成的结果
            return resultCache[args]
        }
        return resultCache[args] = addAll(...arguments)
    }
})()
```

我们把这个方法丢进控制台，尝试同一套入参两次，结果喜人：

![img](http://img-repo.poetries.top/images/20210327190950.png)

> 我们发现 `proxyAddAll` 针对重复的入参只会计算一次，这将大大节省计算过程中的时间开销。现在我们有 6 个入参，可能还看不出来，当我们针对大量入参、做反复计算时，缓存代理的优势将得到更充分的凸显。

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_6-行为型-策略模式)6 行为型-策略模式

> 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

**例子**

> 定义：根据不同参数可以命中不同的策略

- 优点：

- 能减少大量的if语句
- 复用性好

- 优化使用：
  - 封装代码，暴露方法

```js
export default {
    xxx
}

import xxx from 'x.js'
const strategy = {
    'A': (salary) => {
        return salary * 2;
    },

    'B': (salary) => {
        return salary * 3;
    },

    'C': (salary) => {
        return salary * 4;
    }
}

const calculateBonus = (level, salary) => {
    return strategy[level](salary)
}

const A = calculateBonus('A', 10000);
console.log(A); // 20000

// 暴露方法
export default {
    calculateBonus
}
```

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_6-1-先来看一个真实场景)6.1 先来看一个真实场景

有一天，产品经理韩梅梅找到李雷，给李雷提了这么个需求：

马上大促要来了，我们本次大促要做差异化询价。啥是差异化询价？就是说同一个商品，我通过在后台给它设置不同的价格类型，可以让它展示不同的价格。具体的逻辑如下：

- 当价格类型为“预售价”时，满 100 - 20，不满 100 打 9 折
- 当价格类型为“大促价”时，满 100 - 30，不满 100 打 8 折
- 当价格类型为“返场价”时，满 200 - 50，不叠加
- 当价格类型为“尝鲜价”时，直接打 5 折

李雷扫了一眼 prd，立刻来了主意。他首先将四种价格做了标签化：

```text
预售价 - pre
大促价 - onSale
返场价 - back
尝鲜价 - fresh
```

接下来李雷仔细研读了 prd 的内容，作为资深 if-else 侠，他三下五除二就写出一套功能完备的代码：

```js
// 询价方法，接受价格标签和原价为入参
function askPrice(tag, originPrice) {

  // 处理预热价
  if(tag === 'pre') {
    if(originPrice >= 100) {
      return originPrice - 20
    } 
    return originPrice * 0.9
  }
  
  // 处理大促价
  if(tag === 'onSale') {
    if(originPrice >= 100) {
      return originPrice - 30
    } 
    return originPrice * 0.8
  }
  
  // 处理返场价
  if(tag === 'back') {
    if(originPrice >= 200) {
      return originPrice - 50
    }
    return originPrice
  }
  
  // 处理尝鲜价
  if(tag === 'fresh') {
     return originPrice * 0.5
  }
}
```

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_6-2-if-else-侠-人人喊打)6.2 if-else 侠，人人喊打

随便跑一下，上述代码运行起来确实没啥毛病。但也只是“运行起来”没毛病而已。作为人人喊打的 if-else 侠，李雷必须为他的行为付出代价。我们一起来看看这么写代码会带来什么后果：

- 首先，它违背了“单一功能”原则。一个 function 里面，它竟然处理了四坨逻辑——这个函数的逻辑太胖了！这样会带来什么样的糟糕后果，笔者在前面的小节中已经 BB 过很多次了：比如说万一其中一行代码出了 Bug，那么整个询价逻辑都会崩坏；与此同时出了 Bug 你很难定位到底是哪个代码块坏了事；再比如说单个能力很难被抽离复用等等等等。相信跟着我一路学下来的各位，也已经在重重实战中对胖逻辑的恶劣影响有了切身的体会。总之，见到胖逻辑，我们的第一反应，就是一个字——拆！
- 不仅如此，它还违背了“开放封闭”原则。假如有一天韩梅梅再次找到李雷，要他加一个满 100 - 50 的“新人价”怎么办？他只能继续 if-else：

```js
function askPrice(tag, originPrice) {

  // 处理预热价
  if(tag === 'pre') {
    if(originPrice >= 100) {
      return originPrice - 20
    } 
    return originPrice * 0.9
  }
  // 处理大促价
  if(tag === 'onSale') {
    if(originPrice >= 100) {
      return originPrice - 30
    } 
    return originPrice * 0.8
  }

  // 处理返场价
  if(tag === 'back') {
    if(originPrice >= 200) {
      return originPrice - 50
    }
    return originPrice
  }

  // 处理尝鲜价
  if(tag === 'fresh') {
      return originPrice * 0.5
  }
  
  // 处理新人价
  if(tag === 'newUser') {
    if(originPrice >= 100) {
      return originPrice - 50
    }
    return originPrice
  }
}
```

> 没错，李雷灰溜溜地跑去改了 `askPrice` 函数！随后他恬不知耻地徐徐转头，对背后的测试同学说：哥，我改了询价函数，麻烦你帮我把**整个询价逻辑**回归一下。测试同学莞尔一笑， 心中早已有无数头羊驼在狂奔。他强忍着周末加班的悲痛，做完了这漫长而不必要的回归测试，随后默默点击了同事系统里的举报按钮对李雷说：哥，求你学学设计模式吧！！

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_6-3-重构询价逻辑)6.3 重构询价逻辑

现在我们基于我们已经学过的设计模式思想，一点一点改造掉这个臃肿的 askPrice。

**1. 单一功能改造**

首先，我们赶紧把四种询价逻辑提出来，让它们各自为政：

```js
// 处理预热价
function prePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 20
  } 
  return originPrice * 0.9
}

// 处理大促价
function onSalePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 30
  } 
  return originPrice * 0.8
}

// 处理返场价
function backPrice(originPrice) {
  if(originPrice >= 200) {
    return originPrice - 50
  }
  return originPrice
}

// 处理尝鲜价
function freshPrice(originPrice) {
  return originPrice * 0.5
}

function askPrice(tag, originPrice) {
  // 处理预热价
  if(tag === 'pre') {
    return prePrice(originPrice)
  }
  // 处理大促价
  if(tag === 'onSale') {
    return onSalePrice(originPrice)
  }

  // 处理返场价
  if(tag === 'back') {
    return backPrice(originPrice)
  }

  // 处理尝鲜价
  if(tag === 'fresh') {
     return freshPrice(originPrice)
  }
}
```

OK，我们现在至少做到了一个函数只做一件事。现在每个函数都有了自己明确的、单一的分工：

```text
prePrice - 处理预热价
onSalePrice - 处理大促价
backPrice - 处理返场价
freshPrice - 处理尝鲜价
askPrice - 分发询价逻辑
```

如此一来，我们在遇到 Bug 时，就可以做到“头痛医头，脚痛医脚”，而不必在庞大的逻辑海洋里费力去定位到底是哪块不对。

同时，如果我在另一个函数里也想使用某个询价能力，比如说我想询预热价，那我直接把 prePrice 这个函数拿去调用就是了，而不必在 askPrice 肥胖的身躯里苦苦寻觅、然后掏出这块逻辑、最后再复制粘贴到另一个函数去——更何况万一哪天 askPrice 里的预热价逻辑改了，你还得再复制粘贴一次，扎心啊老铁！

到这里，在单一功能原则的指引下，我们已经解决了一半的问题。

我们现在来捋一下，其实这个询价逻辑整体上来看只有两个关键动作：

```text
询价逻辑的分发 ——> 询价逻辑的执行
```

在改造的第一步，我们已经把“询价逻辑的执行”给摘了出去，并且实现了不同询价逻辑之间的解耦。接下来，我们就要拿“分发”这个动作开刀。

**2. 开放封闭改造**

剩下一半的问题是啥呢？就是咱们上面说的那个新人价的问题——这会儿我要想给 askPrice 增加新人询价逻辑，我该咋整？我只能这么来：

```js
// 处理预热价
function prePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 20
  } 
  return originPrice * 0.9
}

// 处理大促价
function onSalePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 30
  } 
  return originPrice * 0.8
}

// 处理返场价
function backPrice(originPrice) {
  if(originPrice >= 200) {
    return originPrice - 50
  }
  return originPrice
}

// 处理尝鲜价
function freshPrice(originPrice) {
  return originPrice * 0.5
}

// 处理新人价
function newUserPrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 50
  }
  return originPrice
}

function askPrice(tag, originPrice) {
  // 处理预热价
  if(tag === 'pre') {
    return prePrice(originPrice)
  }
  // 处理大促价
  if(tag === 'onSale') {
    return onSalePrice(originPrice)
  }

  // 处理返场价
  if(tag === 'back') {
    return backPrice(originPrice)
  }

  // 处理尝鲜价
  if(tag === 'fresh') {
     return freshPrice(originPrice)
  }
  
  // 处理新人价
  if(tag === 'newUser') {
     return newUserPrice(originPrice)
  }
}
```

在外层，我们编写一个 newUser 函数用于处理新人价逻辑；在 askPrice 里面，我们新增了一个 if-else 判断。可以看出，这样其实还是在修改 askPrice 的函数体，没有实现“对扩展开放，对修改封闭”的效果。

> 那么我们应该怎么做？我们仔细想想，楼上用了这么多 if-else，我们的目的到底是什么？是不是就是为了把 询价标签-询价函数 这个映射关系给明确下来？那么在 JS 中，有没有什么既能够既帮我们明确映射关系，同时不破坏代码的灵活性的方法呢？答案就是**对象映射**！

咱们完全可以把询价算法全都收敛到一个对象里去嘛：

```js
// 定义一个询价处理器对象
const priceProcessor = {
  pre(originPrice) {
    if (originPrice >= 100) {
      return originPrice - 20;
    }
    return originPrice * 0.9;
  },
  onSale(originPrice) {
    if (originPrice >= 100) {
      return originPrice - 30;
    }
    return originPrice * 0.8;
  },
  back(originPrice) {
    if (originPrice >= 200) {
      return originPrice - 50;
    }
    return originPrice;
  },
  fresh(originPrice) {
    return originPrice * 0.5;
  },
};
```

当我们想使用其中某个询价算法的时候：通过标签名去定位就好了：

```js
// 询价函数
function askPrice(tag, originPrice) {
  return priceProcessor[tag](originPrice)
}
```

> 如此一来，askPrice 函数里的 if-else 大军彻底被咱们消灭了。这时候如果你需要一个新人价，只需要给 priceProcessor 新增一个映射关系：

```js
priceProcessor.newUser = function (originPrice) {
  if (originPrice >= 100) {
    return originPrice - 50;
  }
  return originPrice;
}
```

这样一来，询价逻辑的分发也变成了一个清清爽爽的过程。当李雷以这种方式新增一个新人价的询价逻辑的时候，就可以底气十足地对测试同学说：老哥，我改了询价逻辑，但是改动范围仅仅涉及到新人价，是一个单纯的功能增加。所以你只测这个新功能点就 OK，老逻辑不用管！

从此，李雷就从人人喊打的 if-else 侠，摇身一变成为了测试之友、中国好开发。业务代码里的询价逻辑，也因为李雷坚守设计原则100年不动摇，而变得易读、易维护。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_6-4-总结)6.4 总结

说起来你可能不相信，咱们上面的整个重构的过程，就是对策略模式的应用。

现在大家来品品策略模式的定义：

> 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

回头看看，咱们忙活到现在，是不是就干了这事儿？

但你要直接读这句话，可能确实会懵圈——啥是算法？如何封装？可替换又是咋做到的？

如今你你已经自己动手实现了算法提取、算法封装、分发优化的整个一条龙的操作流，相信面对这条定义，你可以会心一笑——算法，就是我们这个场景中的询价逻辑，它也可以是你任何一个功能函数的逻辑；“封装”就是把某一功能点对应的逻辑给提出来；“可替换”建立在封装的基础上，只是说这个“替换”的判断过程，咱们不能直接怼 if-else，而要考虑更优的映射方案。

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_7-行为型-状态模式)7 行为型-状态模式

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_7-1-一台咖啡机的诞生)7.1 一台咖啡机的诞生

作为一个具备强大抽象思维能力的程序员，李雷没有辜负自己这么多年来学过的现代前端框架。他敏锐地感知到，韩梅梅所说的这些不同的”选择“间的切换，本质就是状态的切换。在这个能做四种咖啡的咖啡机体内，蕴含着四种状态：

```text
- 美式咖啡态（american)：只吐黑咖啡
- 普通拿铁态(latte)：黑咖啡加点奶
- 香草拿铁态（vanillaLatte）：黑咖啡加点奶再加香草糖浆
- 摩卡咖啡态(mocha)：黑咖啡加点奶再加点巧克力
```

嘿嘿，这么一梳理，李雷的思路一下子清晰了起来。作为死性不改的 if-else 侠，他再次三下五除二写出了一套功能完备的代码：

```js
class CoffeeMaker {
  constructor() {
    /**
     *这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
    **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
  }
  // 关注咖啡机状态切换函数
  changeState(state) {
    // 记录当前状态
    this.state = state;
    if(state === 'american') {
      // 这里用 console 代指咖啡制作流程的业务逻辑
      console.log('我只吐黑咖啡');
    } else if(state === 'latte') {
      console.log(`给黑咖啡加点奶`);
    } else if(state === 'vanillaLatte') {
      console.log('黑咖啡加点奶再加香草糖浆');
    } else if(state === 'mocha') {
      console.log('黑咖啡加点奶再加点巧克力');
    }
  }
}
```

测试一下，完美无缺：

```js
const mk = new CoffeeMaker();
mk.changeState('latte'); // 输出 '给黑咖啡加点奶'
```

> 鉴于 if-else 使不得，李雷赶紧翻出了他在策略模式中学到的“单一职责”和“开放封闭”原则，比猫画虎地改造起了自己的咖啡机：

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_7-2-改造咖啡机的状态切换机制)7.2 改造咖啡机的状态切换机制

**1. 职责分离**

首先，映入李雷眼帘最大的问题，就是咖啡制作过程不可复用：

```js
changeState(state) {
    // 记录当前状态
    this.state = state;
    if(state === 'american') {
      // 这里用 console 代指咖啡制作流程的业务逻辑
      console.log('我只吐黑咖啡');
    } else if(state === 'latte') {
      console.log(`给黑咖啡加点奶`);
    } else if(state === 'vanillaLatte') {
      console.log('黑咖啡加点奶再加香草糖浆');
    } else if(state === 'mocha') {
      console.log('黑咖啡加点奶再加点巧克力');
    }
}
```

李雷发现，这个 changeState 函数，它好好管好自己的事（状态切换）不行吗？怎么连做咖啡的过程也写在这里面？这不合理。

```js
class CoffeeMaker {
  constructor() {
    /**
    这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
  **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
  }
  changeState(state) {
    // 记录当前状态
    this.state = state;
    if(state === 'american') {
      // 这里用 console 代指咖啡制作流程的业务逻辑
      this.americanProcess();
    } else if(state === 'latte') {
      this.latteProcress();
    } else if(state === 'vanillaLatte') {
      this.vanillaLatteProcress();
    } else if(state === 'mocha') {
      this.mochaProcress();
    }
  }
  
  americanProcess() {
    console.log('我只吐黑咖啡');    
  }
  
  latteProcress() {
    this.americanProcess();
    console.log('加点奶');  
  }
  
  vanillaLatteProcress() {
    this.latteProcress();
    console.log('再加香草糖浆');
  }
  
  mochaProcress() {
    this.latteProcress();
    console.log('再加巧克力');
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte');
```

输出结果符合预期：

```text
我只吐黑咖啡
加点奶
```

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_7-3-开放封闭)7.3 开放封闭

复用的问题解决了，if-else 却仍然活得好好的。

现在咱们假如要增加”气泡美式“这个咖啡品种，就不得不去修改 changeState 的函数逻辑，这违反了开放封闭的原则。

同时，一个函数里收敛这么多判断，也着实不够体面。咱们现在要像策略模式一样，想办法把咖啡机状态和咖啡制作工序之间的映射关系（也就是咱们上节谈到的分发过程）用一个更优雅地方式做掉。如果你策略模式掌握得足够好，你会第一时间反映出对象映射的方案：

```js
const stateToProcessor = {
  american() {
    console.log('我只吐黑咖啡');    
  },
  latte() {
    this.american();
    console.log('加点奶');  
  },
  vanillaLatte() {
    this.latte();
    console.log('再加香草糖浆');
  },
  mocha() {
    this.latte();
    console.log('再加巧克力');
  }
}

class CoffeeMaker {
  constructor() {
    /**
    这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
  **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
  }
  
  // 关注咖啡机状态切换函数
  changeState(state) {
    // 记录当前状态
    this.state = state;
    // 若状态不存在，则返回
    if(!stateToProcessor[state]) {
      return ;
    }
    stateToProcessor[state]();
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte');
```

输出结果符合预期：

```text
我只吐黑咖啡
加点奶
```

当我们这么做时，其实已经实现了一个 js 版本的状态模式。

但这里有一点大家需要引起注意：这种方法仅仅是看上去完美无缺，其中却暗含一个非常重要的隐患——stateToProcessor 里的工序函数，感知不到咖啡机的内部状况。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_7-4-进一步改造)7.4 进一步改造

按照我们这一通描述，当务之急是要把咖啡机和它的状态处理函数建立关联。

如果你读过一些早期的设计模式教学资料，有一种思路是将每一个状态所对应的的一些行为抽象成类，然后通过传递 this 的方式来关联状态和状态主体。

这种思路也可以，不过它一般还需要你实现抽象工厂，比较麻烦。实际业务中这种做法极为少见。我这里要给大家介绍的是一种更方便也更常用的解决方案——非常简单，把状态-行为映射对象作为主体类对应实例的一个属性添加进去就行了：

```js
class CoffeeMaker {
  constructor() {
    /**
     *这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
    **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
    // 初始化牛奶的存储量
    this.leftMilk = '500ml';
  }
  stateToProcessor = {
    that: this,
    american() {
      // 尝试在行为函数里拿到咖啡机实例的信息并输出
      console.log('咖啡机现在的牛奶存储量是:', this.that.leftMilk)
      console.log('我只吐黑咖啡');
    },
    latte() {
      this.american()
      console.log('加点奶');
    },
    vanillaLatte() {
      this.latte();
      console.log('再加香草糖浆');
    },
    mocha() {
      this.latte();
      console.log('再加巧克力');
    }
  }

  // 关注咖啡机状态切换函数
  changeState(state) {
    this.state = state;
    if (!this.stateToProcessor[state]) {
      return;
    }
    this.stateToProcessor[state]();
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte');
```

输出结果为：

```text
咖啡机现在的牛奶存储量是: 500ml
我只吐黑咖啡
加点奶
```

如此一来，我们就可以在 stateToProcessor 轻松拿到咖啡机的实例对象，进而感知咖啡机这个主体了。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_7-5-状态模式复盘)7.5 状态模式复盘

和策略模式一样，咱们仍然是敲完代码之后，一起来复盘一下状态模式的定义：

> 状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

这个定义比较粗糙，可能你读完仍然 get 不到它想让你干啥。这时候，我们就应该把目光转移到它解决的问题上来：

> 状态模式**主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中**，可以把复杂的判断逻辑简化。

仔细回忆一下我们这节做的事情，也确实就是这么回事儿。

> 唯一的区别在于，定义里强调了”类“的概念。但我们的示例中，包括大家今后的实践中，一个对象的状态如果复杂到了你不得不给它的每 N 种状态划分为一类、一口气划分很多类这种程度，我更倾向于你去反思一个这个对象是不是做太多事情了。事实上，在大多数场景下，我们的行为划分，都是可以像本节一样，控制在”函数“这个粒度的。

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_8-行为型-观察者模式)8 行为型-观察者模式

> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns

观察者模式，是所有 JavaScript 设计模式中**使用频率**最高，**面试频率也最高**的设计模式，所以说它**十分重要**——如果我是面试官，考虑到面试时间有限、设计模式这块不能多问，我可能在考查你设计模式的时候只会问观察者模式这一个模式。该模式的权重极高

重点不一定是难点。观察者模式十分重要，但它并不抽象，理解难度不大。这种模式不仅在业务开发中遍地开花，在日常生活中也是非常常见的。为了帮助大家形成初步的理解，在进入代码世界之前，我们照例来看一段日常：

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_8-1-生活中的观察者模式)8.1 生活中的观察者模式

周一刚上班，前端开发李雷就被产品经理韩梅梅拉进了一个钉钉群——“员工管理系统需求第99次变更群”。这个群里不仅有李雷，还有后端开发 A，测试同学 B。三位技术同学看到这简单直白的群名便立刻做好了接受变更的准备、打算撸起袖子开始干了。此时韩梅梅却说：“别急，这个需求有问题，我需要和业务方再确认一下，大家先各忙各的吧”。这种情况下三位技术同学不必立刻投入工作，但他们都已经做好了**本周需要做一个新需求**的准备，时刻等待着产品经理的号召。

一天过去了，两天过去了。周三下午，韩梅梅终于和业务方确认了所有的需求细节，于是在“员工管理系统需求第99次变更群”里大吼一声：“需求文档来了！”，随后甩出了"需求文档.zip"文件，同时@所有人。三位技术同学听到熟悉的“有人@我”提示音，立刻点开群进行群消息和群文件查收，随后根据群消息和群文件提供的需求信息，投入到了各自的开发里。上述这个过程，就是一个典型的**观察者模式**。

**重点角色对号入座**

观察者模式有一个“别名”，叫`发布 - 订阅模式`（之所以别名加了引号，是因为两者之间存在着细微的差异，下个小节里我们会讲到这点）。这个别名非常形象地诠释了观察者模式里两个核心的角色要素——**“发布者”\**与\**“订阅者”**。

在上述的过程中，需求文档（目标对象）的发布者只有一个——产品经理韩梅梅。而需求信息的接受者却有多个——前端、后端、测试同学，这些同学的共性就是他们需要根据需求信息开展自己后续的工作、因此都非常关心这个需求信息，于是不得不时刻关注着这个群的群消息提醒，他们是实打实的**订阅者**，即观察者对象。

现在我们再回过头来看一遍开头我们提到的略显抽象的定义：

> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

在我们上文这个钉钉群里，一个需求信息对象对应了多个观察者（技术同学），当需求信息对象的状态发生**变化**（从无到有）时，产品经理通知了群里的所有同学，以便这些同学接收信息进而开展工作：角色划分 --> 状态变化 --> 发布者通知到订阅者，这就是观察者模式的“套路”。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_8-2-在实践中理解定义)8.2 在实践中理解定义

> 结合我们上面的分析，现在大家知道，在观察者模式里，至少应该有两个关键角色是一定要出现的——**发布者和订阅者**。用面向对象的方式表达的话，那就是要有**两个类**。

首先我们来看这个代表发布者的类，我们给它起名叫`Publisher`。这个类应该具备哪些“基本技能”呢？大家回忆一下上文中的韩梅梅，韩梅梅的基本操作是什么？首先是拉群（增加订阅者），然后是`@`所有人（通知订阅者），这俩是最明显的了。此外作为群主&产品经理，韩梅梅还具有踢走项目组成员（移除订阅者）的能力。OK，产品经理发布者类的三个基本能力齐了，下面我们开始写代码：

```js
// 定义发布者类
class Publisher {
  constructor() {
    this.observers = []
    console.log('Publisher created')
  }
  // 增加订阅者
  add(observer) {
    console.log('Publisher.add invoked')
    this.observers.push(observer)
  }
  // 移除订阅者
  remove(observer) {
    console.log('Publisher.remove invoked')
    this.observers.forEach((item, i) => {
      if (item === observer) {
        this.observers.splice(i, 1)
      }
    })
  }
  // 通知所有订阅者
  notify() {
    console.log('Publisher.notify invoked')
    this.observers.forEach((observer) => {
      observer.update(this)
    })
  }
}
```

ok，搞定了发布者，我们一起来想想订阅者能干啥——其实订阅者的能力非常简单，作为被动的一方，它的行为只有两个——被通知、去执行（本质上是接受发布者的调用，这步我们在`Publisher`中已经做掉了）。既然我们在Publisher中做的是方法调用，那么我们在订阅者类里要做的就是**方法的定义**：

```js
// 定义订阅者类
class Observer {
    constructor() {
        console.log('Observer created')
    }
    update() {
        console.log('Observer.update invoked')
    }
}
```

以上，我们就完成了最基本的发布者和订阅者类的设计和编写。在实际的业务开发中，我们所有的定制化的发布者/订阅者逻辑都可以基于这两个基本类来改写。比如我们可以通过拓展发布者类，来使所有的订阅者来**监听某个特定状态的变化**。

仍然以开篇的例子为例，我们让开发者们来监听需求文档（prd）的变化：

```js
// 定义一个具体的需求文档（prd）发布类
class PrdPublisher extends Publisher {
    constructor() {
        super()
        // 初始化需求文档
        this.prdState = null
        // 韩梅梅还没有拉群，开发群目前为空
        this.observers = []
        console.log('PrdPublisher created')
    }
    
    // 该方法用于获取当前的prdState
    getState() {
        console.log('PrdPublisher.getState invoked')
        return this.prdState
    }
    
    // 该方法用于改变prdState的值
    setState(state) {
        console.log('PrdPublisher.setState invoked')
        // prd的值发生改变
        this.prdState = state
        // 需求文档变更，立刻通知所有开发者
        this.notify()
    }
}
```

作为订阅方，开发者的任务也变得具体起来：接收需求文档、并开始干活：

```js
class DeveloperObserver extends Observer {
    constructor() {
        super()
        // 需求文档一开始还不存在，prd初始为空对象
        this.prdState = {}
        console.log('DeveloperObserver created')
    }
    
    // 重写一个具体的update方法
    update(publisher) {
        console.log('DeveloperObserver.update invoked')
        // 更新需求文档
        this.prdState = publisher.getState()
        // 调用工作函数
        this.work()
    }
    
    // work方法，一个专门搬砖的方法
    work() {
        // 获取需求文档
        const prd = this.prdState
        // 开始基于需求文档提供的信息搬砖。。。
        ...
        console.log('996 begins...')
    }
}
```

下面，我们可以 `new` 一个 `PrdPublisher` 对象（产品经理），她可以通过调用 `setState` 方法来更新需求文档。需求文档每次更新，都会紧接着调用 `notify` 方法来通知所有开发者：

> 目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

OK，下面我们来看看韩梅梅和她的小伙伴们是如何搞事情的吧：

```js
// 创建订阅者：前端开发李雷
const liLei = new DeveloperObserver()
// 创建订阅者：服务端开发小A（sorry。。。起名字真的太难了）
const A = new DeveloperObserver()
// 创建订阅者：测试同学小B
const B = new DeveloperObserver()
// 韩梅梅出现了
const hanMeiMei = new PrdPublisher()
// 需求文档出现了
const prd = {
    // 具体的需求内容
    ...
}
// 韩梅梅开始拉群
hanMeiMei.add(liLei)
hanMeiMei.add(A)
hanMeiMei.add(B)
// 韩梅梅发送了需求文档，并@了所有人
hanMeiMei.setState(prd)
```

以上，就是观察者模式在代码世界里的完整实现流程了。

相信走到这一步，大家对观察者模式的核心思想、基本实现模式都有了不错的掌握。下面我们趁热打铁，一起来看看如何凭借观察者模式，在面试中表演真正的技术~

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_8-3-vue数据双向绑定-响应式系统-的实现原理)8.3 Vue数据双向绑定（响应式系统）的实现原理

**1. 解析**

Vue 框架是热门的渐进式 JavaScript框架。在 Vue 中，当我们修改状态时，视图会随之更新，这就是Vue的数据双向绑定（又称响应式原理）。数据双向绑定是Vue 最独特的特性之一。如果读者没有接触过 Vue，强烈建议阅读[Vue官方对响应式原理的介绍 (opens new window)](https://cn.vuejs.org/v2/guide/reactivity.html)。此处我们用官方的一张流程图来简要地说明一下Vue响应式系统的整个流程：

![img](http://img-repo.poetries.top/images/20210327204351.png)

在 `Vue` 中，每个组件实例都有相应的 `watcher` 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 `setter` 被调用时，会通知 `watcher` 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式。这道面试题考察了受试者对Vue底层原理的理解、对观察者模式的实现能力以及一系列重要的JS知识点，具有较强的综合性和代表性。

值得注意的是，在面试过程中，面试官多数情况下不会要求大家写出完整的响应式原理实现代码，而是要求你“说说自己的理解”。在本节，我们不会带大家一行一行写代码（具体深入Vue框架的相关知识，建议大家阅读[Vue源码 (opens new window)](https://github.com/vuejs/vue)及这本[专门写Vue的小册 (opens new window)](https://juejin.im/book/5a36661851882538e2259c0f)。），而是针对Vue响应式系统中与观察者模式紧密关联的这部分知识作讲解，帮助大家捋清楚整套流程里的来龙去脉、加深对观察者模式的理解。

**在Vue数据双向绑定的实现逻辑里，有这样三个关键角色：**

- `observer`（监听器）：注意，此 `observer` 非彼 `observer`。在我们上面的解析中，`observer` 作为设计模式中的一个角色，代表“订阅者”。但在`Vue`数据双向绑定的角色结构里，所谓的 `observer` 不仅是一个数据监听器，它还需要对监听到的数据进行**转发**——也就是说它**同时还是一个发布者**。
- `watcher`（订阅者）：`observer` 把数据转发给了**真正的订阅者**——`watcher`对象。`watcher` 接收到新的数据后，会去更新视图。
- `compile`（编译器）：`MVVM` 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管~

这三者的配合过程如图所示：

![img](http://img-repo.poetries.top/images/20210327204920.png)

OK，实现方案搞清楚了，下面我们给整个流程中**涉及到发布-订阅这一模式的代码**来个特写：

**2. 核心代码**

**实现observer**

> 首先我们需要实现一个方法，这个方法会对需要监听的数据对象进行遍历、给它的属性加上定制的 `getter` 和 `setter` 函数。这样但凡这个对象的某个属性发生了改变，就会触发 `setter` 函数，进而通知到订阅者。这个 `setter` 函数，就是我们的监听器：

```js
// observe方法遍历并包装对象属性
function observe(target) {
    // 若target是一个对象，则遍历它
    if(target && typeof target === 'object') {
        Object.keys(target).forEach((key)=> {
            // defineReactive方法会给目标属性装上“监听器”
            defineReactive(target, key, target[key])
        })
    }
}

// 定义defineReactive方法
function defineReactive(target, key, val) {
    // 属性值也可能是object类型，这种情况下需要调用observe进行递归遍历
    observe(val)
    // 为当前属性安装监听器
    Object.defineProperty(target, key, {
         // 可枚举
        enumerable: true,
        // 不可配置
        configurable: false, 
        get: function () {
            return val;
        },
        // 监听器函数
        set: function (value) {
            console.log(`${target}属性的${key}属性从${val}值变成了了${value}`)
            val = value
        }
    });
}
```

> 下面实现订阅者 `Dep`：

```js
// 定义订阅者类Dep
class Dep {
    constructor() {
        // 初始化订阅队列
        this.subs = []
    }
    
    // 增加订阅者
    addSub(sub) {
        this.subs.push(sub)
    }
    
    // 通知订阅者（是不是所有的代码都似曾相识？）
    notify() {
        this.subs.forEach((sub)=>{
            sub.update()
        })
    }
}
```

> 现在我们可以改写 `defineReactive` 中的 `setter` 方法，在监听器里去通知订阅者了：

```js
function defineReactive(target, key, val) {
    const dep = new Dep()
    // 监听当前属性
    observe(val)
    Object.defineProperty(target, key, {
        set: (value) => {
            // 通知所有订阅者
            dep.notify()
        }
    })
}
```

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_8-4-实现一个event-bus-event-emitter)8.4 实现一个Event Bus / Event Emitter

> `Event Bus`（Vue、Flutter 等前端框架中有出镜）和 `Event Emitter`（Node中有出镜）出场的“剧组”不同，但是它们都对应一个共同的角色——**全局事件总线**。

全局事件总线，严格来说不能说是观察者模式，而是发布-订阅模式。它在我们日常的业务开发中应用非常广。

> 如果只能选一道题，那这道题一定是 `Event Bus/Event Emitter` 的代码实现——我都说这么清楚了，这个知识点到底要不要掌握、需要掌握到什么程度，就看各位自己的了。

**在Vue中使用Event Bus来实现组件间的通讯**

> `Event Bus/Event Emitter` 作为全局事件总线，它起到的是一个**沟通桥梁**的作用。我们可以把它理解为一个事件中心，我们所有事件的订阅/发布都不能由订阅方和发布方“私下沟通”，必须要委托这个事件中心帮我们实现。

在Vue中，有时候 A 组件和 B 组件中间隔了很远，看似没什么关系，但我们希望它们之间能够通信。这种情况下除了求助于 `Vuex` 之外，我们还可以通过 `Event Bus` 来实现我们的需求。

创建一个 `Event Bus`（本质上也是 Vue 实例）并导出：

```js
const EventBus = new Vue()
export default EventBus
```

在主文件里引入`EventBus`，并挂载到全局：

```js
import bus from 'EventBus的文件路径'
Vue.prototype.bus = bus
```

订阅事件：

```js
// 这里func指someEvent这个事件的监听函数
this.bus.$on('someEvent', func)
```

发布（触发）事件：

```js
// 这里params指someEvent这个事件被触发时回调函数接收的入参
this.bus.$emit('someEvent', params)
```

> 大家会发现，整个调用过程中，没有出现具体的发布者和订阅者（比如上面的`PrdPublisher`和`DeveloperObserver`），全程只有`bus`这个东西一个人在疯狂刷存在感。这就是全局事件总线的特点——所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！

下面，我们就一起来实现一个`Event Bus`（注意看注释里的解析）：

```js
class EventEmitter {
  constructor() {
    // handlers是一个map，用于存储事件与回调之间的对应关系
    this.handlers = {}
  }

  // on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数
  on(eventName, cb) {
    // 先检查一下目标事件名有没有对应的监听函数队列
    if (!this.handlers[eventName]) {
      // 如果没有，那么首先初始化一个监听函数队列
      this.handlers[eventName] = []
    }

    // 把回调函数推入目标事件的监听函数队列里去
    this.handlers[eventName].push(cb)
  }

  // emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数
  emit(eventName, ...args) {
    // 检查目标事件是否有监听函数队列
    if (this.handlers[eventName]) {
      // 如果有，则逐个调用队列里的回调函数
      this.handlers[eventName].forEach((callback) => {
        callback(...args)
      })
    }
  }

  // 移除某个事件回调队列里的指定回调函数
  off(eventName, cb) {
    const callbacks = this.handlers[eventName]
    const index = callbacks.indexOf(cb)
    if (index !== -1) {
      callbacks.splice(index, 1)
    }
  }

  // 为事件注册单次监听器
  once(eventName, cb) {
    // 对回调函数进行包装，使其执行完毕自动被移除
    const wrapper = (...args) => {
      cb.apply(...args)
      this.off(eventName, wrapper)
    }
    this.on(eventName, wrapper)
  }
}
```

> 在日常的开发中，大家用到`EventBus/EventEmitter`往往提供比这五个方法多的多的多的方法。但在面试过程中，如果大家能够完整地实现出这五个方法，已经非常可以说明问题了，因此楼上这个`EventBus`希望大家可以熟练掌握。学有余力的同学，推荐阅读[FaceBook推出的通用EventEmiiter库的源码 (opens new window)](https://github.com/facebook/emitter)，相信你会有更多收获。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_8-5-观察者模式与发布-订阅模式的区别是什么)8.5 观察者模式与发布-订阅模式的区别是什么？

> 在面试过程中，一些对细节比较在意的面试官可能会追问观察者模式与发布-订阅模式的区别。这个问题可能会引发一些同学的不适，因为在大量参考资料以及已出版的纸质书籍中，都会告诉大家“发布-订阅模式和观察者模式是同一个东西的两个名字”。本书在前文的叙述中，也没有突出强调两者的区别。其实这两个模式，要较起真来，确实不能给它们划严格的等号。

为什么大家都喜欢给它们强行划等号呢？这是因为就算划了等号，也不影响我们正常使用，毕竟两者在核心思想、运作机制上没有本质的差别。但考虑到这个问题确实可以成为面试题的一个方向，此处我们还是单独拿出来讲一下。

回到我们上文的例子里。韩梅梅把所有的开发者拉了一个群，直接把需求文档丢给每一位群成员，这种**发布者直接触及到订阅者**的操作，叫观察者模式。但如果韩梅梅没有拉群，而是把需求文档上传到了公司统一的需求平台上，需求平台感知到文件的变化、自动通知了每一位订阅了该文件的开发者，这种**发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式**。

相信大家也已经看出来了，观察者模式和发布-订阅模式之间的区别，在于是否存在第三方、发布者能否直接感知订阅者（如图所示）。

![img](http://img-repo.poetries.top/images/20210327211020.png)

**观察者模式**

![img](http://img-repo.poetries.top/images/20210327211122.png)

**发布-订阅模式**

> 在我们见过的这些例子里，韩梅梅拉钉钉群的操作，就是典型的`观察者模式`；而通过`EventBus`去实现事件`监听/发布`，则属于`发布-订阅模式`。

既生瑜，何生亮？既然有了观察者模式，为什么还需要发布-订阅模式呢？

> 大家思考一下：为什么要有观察者模式？`观察者模式`，解决的其实是模块间的耦合问题，有它在，即便是两个分离的、毫不相关的模块，也可以实现数据通信。但观察者模式仅仅是减少了耦合，**并没有完全地解决耦合问题**——被观察者必须去维护一套观察者的集合，这些观察者必须实现统一的方法供被观察者调用，两者之间还是有着说不清、道不明的关系。

而`发布-订阅模式`，则是快刀斩乱麻了——`发布者完全不用感知订阅者`，不用关心它怎么实现回调方法，`事件的注册和触发都发生在独立于双方的第三方平台（事件总线）上`。`发布-订阅模式`下，实现了完全地解耦。

> 但这并不意味着，`发布-订阅模式就比观察者模式“高级”`。在实际开发中，我们的模块解耦诉求**并非总是需要它们完全解耦**。如果两个模块之间本身存在关联，且这种关联是稳定的、必要的，那么我们使用观察者模式就足够了。而在模块与模块之间独立性较强、且没有必要单纯为了数据通信而强行为两者制造依赖的情况下，我们往往会倾向于使用`发布-订阅模式`。

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_9-行为型-迭代器模式)9 行为型-迭代器模式

> 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 ——《设计模式：可复用面向对象软件的基础》

迭代器模式是设计模式中少有的**目的性极强的模式**。所谓“目的性极强”就是说它不操心别的，它就解决这一个问题——遍历。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_9-1-公元前-的迭代器模式)9.1 “公元前”的迭代器模式

> 遍历作为一种合理、高频的使用需求，几乎没有语言会要求它的开发者手动去实现。在JS中，本身也内置了一个比较简陋的数组迭代器的实现—— `Array.prototype.forEach`

通过调用`forEach`方法，我们可以轻松地遍历一个数组：

```js
const arr = [1, 2, 3]
arr.forEach((item, index)=>{
    console.log(`索引为${index}的元素是${item}`)
})
```

但`forEach`方法并不是万能的，比如下面这种场景：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>事件代理</title>
</head>
<body>
    <a href="#">链接1号</a>
    <a href="#">链接2号</a>
    <a href="#">链接3号</a>
    <a href="#">链接4号</a>
    <a href="#">链接5号</a>
    <a href="#">链接6号</a>
</body>
</html>
```

我想拿到所有的a标签，我可以这样做：

```js
const aNodes = document.getElementsByTagName('a')
console.log('aNodes are', aNodes)
```

我想取其中一个`a`标签，可以这样做：

```js
const aNode = aNodes[i]
```

在这个操作的映衬下，`aNodes`看上去多么像一个数组啊！但当你尝试用数组的原型方法去遍历它时：

```js
aNodes.forEach((aNode, index){
    console.log(aNode, index)
})
```

你发现报错了：

![img](http://img-repo.poetries.top/images/20210327212411.png)

原来这个`aNodes`是个假数组！准确地说，它是一个**类数组**对象，并没有为你实现好用的`forEach`方法。也就是说，要想实现类数组的遍历，你得另请高明。

现在问题就出现了：普通数组是不是集合？是！`aNodes`是不是集合？是！同样是集合，同样有遍历需求，我们却要针对不同的数据结构执行不同的遍历手段，好累！再回头看看迭代器的定义是什么——遍历集合的同时，我们**不需要关心集合的内部结构**。而`forEach`只能做到允许我们不关心数组这一种集合的内部结构，看来想要一套统一的遍历方案，我们非得请出一个**更强的通用迭代器**不可了。

这个小节的标题定语里有三个字“公元前”，这个“公元前”怎么定义呢？其实它说的就是ES标准内置迭代器之前的那些日子——差不多四五年之前，彼时还没有这么多轮子，`jQuery`风头正盛。当时面试可不问什么`Vue`原理、`React`原理、`Webpack`这些，当时问的最多的是**你读过jQuery源码吗**？答读过，好，那咱们就有的聊了。答没有？fine，看来你只是个调包侠，回见吧——因为前端的技术点在那时还很有限，所以可考察的东西也就这么点，读jQuery源码的程序员和不读jQuery源码的程序员在面试官眼里有着质的区别。但这也从一个侧面反映出来，jQuery这个库其实是非常优秀的，至少jQuery里有太多优秀的设计模式可以拿来考考你。就包括咱们当年想用一个真·迭代器又不想自己搞的时候，也是请jQuery实现的迭代器来帮忙：

首先我们要在页面里引入jQuery：

```text
  <script src="https://cdn.bootcss.com/jquery/3.3.0/jquery.min.js" type="text/javascript"></script>
```

借助`jQuery`的`each`方法，我们可以用同一套遍历规则遍历不同的集合对象：

```js
const arr = [1, 2, 3]
const aNodes = document.getElementsByTagName('a')

$.each(arr, function (index, item) {
    console.log(`数组的第${index}个元素是${item}`)
})

$.each(aNodes, function (index, aNode) {
    console.log(`DOM类数组的第${index}个元素是${aNode.innerText}`)
})
```

输出结果完全没问题：

![img](https://user-gold-cdn.xitu.io/2019/4/5/169ec0943e93c3cd?w=653&h=346&f=png&s=195823)

当然啦，遍历`jQuery`自己的集合对象也不在话下：

```js
const jQNodes = $('a')
$.each(jQNodes, function (index, aNode) {
   console.log(`jQuery集合的第${index}个元素是${aNode.innerText}`)
})
```

输出结果仍然没问题：

![img](http://img-repo.poetries.top/images/20210327212836.png)

> 可以看出，`jQuery`的迭代器为我们统一了不同类型集合的遍历方式，使我们在访问集合内每一个成员时不用去关心集合本身的内部结构以及集合与集合间的差异，这就是迭代器存在的价值~

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_9-2-es6对迭代器的实现)9.2 ES6对迭代器的实现

在“公元前”，JS原生的集合类型数据结构，只有`Array`（数组）和`Object`（对象）；而`ES6`中，又新增了`Map`和`Set`。四种数据结构各自有着自己特别的内部实现，但我们仍期待以同样的一套规则去遍历它们，所以`ES6`在推出新数据结构的同时也推出了一套**统一的接口机制**——迭代器（`Iterator`）。

> `ES6`约定，任何数据结构只要具备`Symbol.iterator`属性（这个属性就是`Iterator`的具体实现，它本质上是当前数据结构默认的迭代器生成函数），就可以被遍历——准确地说，是被`for...of...`循环和迭代器的next方法遍历。 事实上，`for...of...`的背后正是对`next`方法的反复调用。

在ES6中，针对`Array`、`Map`、`Set`、`String`、`TypedArray`、函数的 `arguments` 对象、`NodeList` 对象这些原生的数据结构都可以通过`for...of...`进行遍历。原理都是一样的，此处我们拿最简单的数组进行举例，当我们用`for...of...`遍历数组时：

```js
const arr = [1, 2, 3]
const len = arr.length
for(item of arr) {
   console.log(`当前元素是${item}`)
}
```

> 之所以能够按顺序一次一次地拿到数组里的每一个成员，是因为我们借助数组的`Symbol.iterator`生成了它对应的迭代器对象，通过反复调用迭代器对象的`next`方法访问了数组成员，像这样：

```js
const arr = [1, 2, 3]
// 通过调用iterator，拿到迭代器对象
const iterator = arr[Symbol.iterator]()

// 对迭代器对象执行next，就能逐个访问集合的成员
iterator.next()
iterator.next()
iterator.next()
```

丢进控制台，我们可以看到`next`每次会按顺序帮我们访问一个集合成员：

![img](http://img-repo.poetries.top/images/20210327213037.png)

> 而`for...of...`做的事情，基本等价于下面这通操作：

```js
// 通过调用iterator，拿到迭代器对象
const iterator = arr[Symbol.iterator]()

// 初始化一个迭代结果
let now = { done: false }

// 循环往外迭代成员
while(!now.done) {
    now = iterator.next()
    if(!now.done) {
        console.log(`现在遍历到了${now.value}`)
    }
}
```

> 可以看出，`for...of...`其实就是`iterator`循环调用换了种写法。在ES6中我们之所以能够开心地用`for...of...`遍历各种各种的集合，全靠迭代器模式在背后给力。

ps：此处推荐阅读[迭代协议 (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)，相信大家读过后会对迭代器在ES6中的实现有更深的理解。

### [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_9-3-实现一个迭代器生成函数)9.3 实现一个迭代器生成函数

ok，看过了迭代器从古至今的操作，我们一起来实现一个自定义的迭代器。

楼上我们说**迭代器对象**全凭**迭代器生成函数**帮我们生成。在`ES6`中，实现一个迭代器生成函数并不是什么难事儿，因为ES6早帮我们考虑好了全套的解决方案，内置了贴心的**生成器**（`Generator`）供我们使用：

```js
// 编写一个迭代器生成函数
function *iteratorGenerator() {
    yield '1号选手'
    yield '2号选手'
    yield '3号选手'
}

const iterator = iteratorGenerator()

iterator.next()
iterator.next()
iterator.next()
```

丢进控制台，不负众望：

![img](http://img-repo.poetries.top/images/20210327213223.png)

写一个生成器函数并没有什么难度，但在面试的过程中，面试官往往对生成器这种语法糖背后的实现逻辑更感兴趣。下面我们要做的，不仅仅是写一个迭代器对象，而是用`ES5`去写一个能够生成迭代器对象的迭代器生成函数（解析在注释里）：

```js
// 定义生成器函数，入参是任意集合
function iteratorGenerator(list) {
    // idx记录当前访问的索引
    var idx = 0
    // len记录传入集合的长度
    var len = list.length
    return {
        // 自定义next方法
        next: function() {
            // 如果索引还没有超出集合长度，done为false
            var done = idx >= len
            // 如果done为false，则可以继续取值
            var value = !done ? list[idx++] : undefined
            
            // 将当前值与遍历是否完毕（done）返回
            return {
                done: done,
                value: value
            }
        }
    }
}

var iterator = iteratorGenerator(['1号选手', '2号选手', '3号选手'])
iterator.next()
iterator.next()
iterator.next()
```

此处为了记录每次遍历的位置，我们实现了一个闭包，借助自由变量来做我们的迭代过程中的“游标”。

运行一下我们自定义的迭代器，结果符合预期：

![img](http://img-repo.poetries.top/images/20210327213700.png)

迭代器模式比较特别，它非常重要，重要到语言和框架都争着抢着帮我们实现。但也正因为如此，大家业务开发中需要手动写迭代器的场景几乎没有，所以很少有同学会去刻意留意迭代器模式、思考它背后的实现机制。通过阅读本节，希望大家可以领略迭代器模式的妙处（为什么会有，为什么要用）和迭代器模式的实现思路（方便面试）。

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_10-中介者模式)10 中介者模式

> 定义：对象与对象之间借助第三方中介者通信

```js
class Player {
    constructor(name) {
        this.name = name;

        this.playerMiddle = new PlayerMiddle();
        this.playerMiddle.add(name);
    }

    win() {
        this.playerMiddle.win(this.name);
    }

    lose() {
        this.playerMiddle.lose(this.name);
    }
}

// 中介者
class PlayerMiddle {
    constructor() {
        this.players = [];
        this.winArr = [];
        this.loseArr = [];
    }

    add(name) {
        this.players.push(name)
    }

    win(name) {
        this.winArr.push(name)
        if (this.winArr.length + this.loseArr.length === this.players.length) {
            this.show()
        }
    }

    lose(name) {
        this.loseArr.push(name)
        if (this.winArr.length + this.loseArr.length === this.players.length) {
            this.show()
        }
    }

    show() {
        for (let winner of this.winArr) {
            console.log(winner + '挑战成功;')
        }

        for (let loser of this.loseArr) {
            console.log(loser + '挑战失败;')
        }
    }
}

const a = new Player('A 选手')
const b = new Player('B 选手')
const c = new Player('C 选手')

a.win()
b.win()
c.lose()
```

## [#](http://interview.poetries.top/excellent-docs/15-设计模式.html#_11-享元模式)11 享元模式

> 定义：一种优化程序性能的模式, 本质为减少对象创建的个数。

以下情况可以使用享元模式

1. 有大量相似的对象，占用了大量内存
2. 对象中大部分状态可以抽离为外部状态

```js
// 题目：某商家有 50 种男款内衣和 50 种款女款内衣, 要展示它们！

class Model {
    constructor(gender) {
        this.gender = gender
        // this.underwear = ''
    }
    
    /* 方法一 */
    // takePhoto() {
    //     console.log(`${this.gender}穿着${this.underwear}`)
    // }
    
   /* 方法二 */
    takePhoto(i) {
        console.log(`${this.gender}穿着${i}款衣服`)
    }


}

const maleModel = new Model('male')
const femaleModel = new Model('female')

for (let i = 1; i < 51; i++) {
    // maleModel.underwear = `第${i}款衣服`
    // maleModel.takePhoto()

    maleModel.takePhoto(i)
}

for (let i = 1; i < 51; i++) {
    // femaleModel.underwear = `第${i}款衣服`
    // femaleModel.takePhoto()

    maleModel.takePhoto(i)
}
```



# 16 框架通识

## 1 MVVM

> `MVVM` 由以下三个内容组成

- `View`：界面
- `Model`：数据模型
- `ViewModel`：作为桥梁负责沟通 `View` 和 `Model`

> 在 `JQuery` 时期，如果需要刷新 `UI` 时，需要先取到对应的 `DOM` 再更新 `UI`，这样数据和业务的逻辑就和页面有强耦合。

MVVM

在 `MVVM` 中，`UI` 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 `UI`，`UI` 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。`ViewModel` 只关心数据和业务的处理，不关心 `View` 如何处理数据，在这种情况下，`View` 和 `Model` 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 `ViewModel` 中，让多个 `View`复用这个 `ViewModel`。

- 在 `MVVM` 中，最核心的也就是数据双向绑定，例如 `Angluar` 的脏数据检测，`Vue` 中的数据劫持。

**脏数据检测**

> 当触发了指定事件后会进入脏数据检测，这时会调用 `$digest` 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 `$watch` 函数，然后再次调用 `$digest` 循环直到发现没有变化。循环至少为二次 ，至多为十次。

> 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 `Vue` 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 `UI`，大大减少了操作 `DOM` 的次数。所以低效也是相对的，这就仁者见仁智者见智了。

**数据劫持**

> `Vue` 内部使用了 `Object.defineProperty()` 来实现双向绑定，通过这个函数可以监听到 `set` 和 `get` 的事件。

```js
var data = { name: 'yck' }
observe(data)
let name = data.name // -> get value
data.name = 'yyy' // -> change value

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
  })
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
    }
  })
}
```

> 以上代码简单的实现了如何监听数据的 `set` 和 `get` 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅

```html
<div>
    {{name}}
</div>
```

> 在解析如上模板代码时，遇到 `{name}` 就会给属性 `name` 添加发布订阅。

```js
// 通过 Dep 解耦
class Dep {
  constructor() {
    this.subs = []
  }
  addSub(sub) {
    // sub 是 Watcher 实例
    this.subs.push(sub)
  }
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null

function update(value) {
  document.querySelector('div').innerText = value
}

class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this
    this.cb = cb
    this.obj = obj
    this.key = key
    this.value = obj[key]
    Dep.target = null
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key]
    // 调用 update 方法更新 Dom
    this.cb(this.value)
  }
}
var data = { name: 'yck' }
observe(data)
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update)
// update Dom innerText
data.name = 'yyy'
```

> 接下来,对 `defineReactive` 函数进行改造

```js
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  let dp = new Dep()
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target)
      }
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
      // 执行 watcher 的 update 方法
      dp.notify()
    }
  })
}
```

> 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 `getter` 来实现发布订阅的添加

**Proxy 与 Object.defineProperty 对比**

> `Object.defineProperty` 虽然已经能够实现双向绑定了，但是他还是有缺陷的。

- 只能对属性进行数据劫持，所以需要深度遍历整个对象 对于数组不能监听到数据的变化
- 虽然 `Vue` 中确实能检测到数组数据的变化，但是其实是使用了 `hack`的办法，并且也是有缺陷的。

```js
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
// hack 以下几个函数
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
methodsToPatch.forEach(function (method) {
  // 获得原生函数
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    // 调用原生函数
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // 触发更新
    ob.dep.notify()
    return result
  })
})
```

> 反观 `Proxy`就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 `Vue` 也将在下个大版本中使用 `Proxy` 替换 `Object.defineProperty`

```js
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      setBind(value);
      return Reflect.set(target, property, value);
    }
  };
  return new Proxy(obj, handler);
};

let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
  value = v
}, (target, property) => {
  console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
```

## [#](http://interview.poetries.top/excellent-docs/16-框架通识.html#_2-路由原理)2 路由原理

> 前端路由实现起来其实很简单，本质就是监听 `URL` 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式

- `hash` 模式
- `history` 模式

> `www.test.com/##/` 就是 `Hash URL`，当 `##` 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 `hashchange` 事件来监听到 `URL` 的变化，从而进行跳转页面。

![img](https://poetries1.gitee.io/img-repo/2020/09/99.png)

> `History`模式是 `HTML5` 新推出的功能，比之 `Hash URL` 更加美观

![img](https://poetries1.gitee.io/img-repo/2020/09/100.png)

## [#](http://interview.poetries.top/excellent-docs/16-框架通识.html#_3-virtual-dom)3 Virtual Dom

**为什么需要 Virtual Dom**

> 众所周知，操作 `DOM` 是很耗费性能的一件事情，既然如此，我们可以考虑通过 `JS` 对象来模拟 `DOM` 对象，毕竟操作 `JS` 对象比操作 `DOM` 省时的多

```js
// 假设这里模拟一个 ul，其中包含了 5 个 li
[1, 2, 3, 4, 5]
// 这里替换上面的 li
[1, 2, 5, 4]
```

> 从上述例子中，我们一眼就可以看出先前的 `ul` 中的第三个 `li` 被移除了，四五替换了位置。

- 如果以上操作对应到 `DOM` 中，那么就是以下代码

```js
// 删除第三个 li
ul.childNodes[2].remove()
// 将第四个 li 和第五个交换位置
let fromNode = ul.childNodes[4]
let toNode = node.childNodes[3]
let cloneFromNode = fromNode.cloneNode(true)
let cloenToNode = toNode.cloneNode(true)
ul.replaceChild(cloneFromNode, toNode)
ul.replaceChild(cloenToNode, fromNode)
```

> 当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 `Vue` 和 `React` 中官方推荐列表里的节点使用唯一的 `key` 来保证性能。

- 那么既然 `DOM` 对象可以通过 `JS` 对象来模拟，反之也可以通过 `JS` 对象来渲染出对应的 `DOM`
- 以下是一个 `JS` 对象模拟 `DOM` 对象的简单实现

```js
export default class Element {
  /**
   * @param {String} tag 'div'
   * @param {Object} props { class: 'item' }
   * @param {Array} children [ Element1, 'text']
   * @param {String} key option
   */
  constructor(tag, props, children, key) {
    this.tag = tag
    this.props = props
    if (Array.isArray(children)) {
      this.children = children
    } else if (isString(children)) {
      this.key = children
      this.children = null
    }
    if (key) this.key = key
  }
  // 渲染
  render() {
    let root = this._createElement(
      this.tag,
      this.props,
      this.children,
      this.key
    )
    document.body.appendChild(root)
    return root
  }
  create() {
    return this._createElement(this.tag, this.props, this.children, this.key)
  }
  // 创建节点
  _createElement(tag, props, child, key) {
    // 通过 tag 创建节点
    let el = document.createElement(tag)
    // 设置节点属性
    for (const key in props) {
      if (props.hasOwnProperty(key)) {
        const value = props[key]
        el.setAttribute(key, value)
      }
    }
    if (key) {
      el.setAttribute('key', key)
    }
    // 递归添加子节点
    if (child) {
      child.forEach(element => {
        let child
        if (element instanceof Element) {
          child = this._createElement(
            element.tag,
            element.props,
            element.children,
            element.key
          )
        } else {
          child = document.createTextNode(element)
        }
        el.appendChild(child)
      })
    }
    return el
  }
}
```

**Virtual Dom 算法简述**

- 既然我们已经通过 `JS` 来模拟实现了 `DOM`，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。
- `DOM` 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 `O(n ^ 3)`，这个复杂度肯定是不能接受的。于是 `React`团队优化了算法，实现了 `O(n)` 的复杂度来对比差异。
- 实现`O(n)` 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 `DOM` 元素

> 所以判断差异的算法就分为了两步

- 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异
- 一旦节点有子元素，就去判断子元素是否有不同

**Virtual Dom 算法实现**

**树的递归**

- 首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况
- 新的节点的 `tagName` 或者 `key` 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了
- 新的节点的 `tagName` 和 `key`（可能都没有）和旧的相同，开始遍历子树
- 没有新的节点，那么什么都不用做

```js
import { StateEnums, isString, move } from './util'
import Element from './element'

export default function diff(oldDomTree, newDomTree) {
  // 用于记录差异
  let pathchs = {}
  // 一开始的索引为 0
  dfs(oldDomTree, newDomTree, 0, pathchs)
  return pathchs
}

function dfs(oldNode, newNode, index, patches) {
  // 用于保存子树的更改
  let curPatches = []
  // 需要判断三种情况
  // 1.没有新的节点，那么什么都不用做
  // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换
  // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树
  if (!newNode) {
  } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key) {
    // 判断属性是否变更
    let props = diffProps(oldNode.props, newNode.props)
    if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props })
    // 遍历子树
    diffChildren(oldNode.children, newNode.children, index, patches)
  } else {
    // 节点不同，需要替换
    curPatches.push({ type: StateEnums.Replace, node: newNode })
  }

  if (curPatches.length) {
    if (patches[index]) {
      patches[index] = patches[index].concat(curPatches)
    } else {
      patches[index] = curPatches
    }
  }
}
```

**判断属性的更改**

> 判断属性的更改也分三个步骤

- 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中
- 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化
- 在第二步中同时查看是否有属性不存在与旧的属性列列表中

```js
function diffProps(oldProps, newProps) {
  // 判断 Props 分以下三步骤
  // 先遍历 oldProps 查看是否存在删除的属性
  // 然后遍历 newProps 查看是否有属性值被修改
  // 最后查看是否有属性新增
  let change = []
  for (const key in oldProps) {
    if (oldProps.hasOwnProperty(key) && !newProps[key]) {
      change.push({
        prop: key
      })
    }
  }
  for (const key in newProps) {
    if (newProps.hasOwnProperty(key)) {
      const prop = newProps[key]
      if (oldProps[key] && oldProps[key] !== newProps[key]) {
        change.push({
          prop: key,
          value: newProps[key]
        })
      } else if (!oldProps[key]) {
        change.push({
          prop: key,
          value: newProps[key]
        })
      }
    }
  }
  return change
}
```

**判断列表差异算法实现**

> 这个算法是整个 `Virtual Dom` 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步

- 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中
- 遍历新的节点列表，判断是否有新的节点
- 在第二步中同时判断节点是否有移动

> PS：该算法只对有 `key` 的节点做处理

```js
function listDiff(oldList, newList, index, patches) {
  // 为了遍历方便，先取出两个 list 的所有 keys
  let oldKeys = getKeys(oldList)
  let newKeys = getKeys(newList)
  let changes = []

  // 用于保存变更后的节点数据
  // 使用该数组保存有以下好处
  // 1.可以正确获得被删除节点索引
  // 2.交换节点位置只需要操作一遍 DOM
  // 3.用于 `diffChildren` 函数中的判断，只需要遍历
  // 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要
  // 再去判断一遍
  let list = []
  oldList &&
    oldList.forEach(item => {
      let key = item.key
      if (isString(item)) {
        key = item
      }
      // 寻找新的 children 中是否含有当前节点
      // 没有的话需要删除
      let index = newKeys.indexOf(key)
      if (index === -1) {
        list.push(null)
      } else list.push(key)
    })
  // 遍历变更后的数组
  let length = list.length
  // 因为删除数组元素是会更改索引的
  // 所有从后往前删可以保证索引不变
  for (let i = length - 1; i >= 0; i--) {
    // 判断当前元素是否为空，为空表示需要删除
    if (!list[i]) {
      list.splice(i, 1)
      changes.push({
        type: StateEnums.Remove,
        index: i
      })
    }
  }
  // 遍历新的 list，判断是否有节点新增或移动
  // 同时也对 `list` 做节点新增和移动节点的操作
  newList &&
    newList.forEach((item, i) => {
      let key = item.key
      if (isString(item)) {
        key = item
      }
      // 寻找旧的 children 中是否含有当前节点
      let index = list.indexOf(key)
      // 没找到代表新节点，需要插入
      if (index === -1 || key == null) {
        changes.push({
          type: StateEnums.Insert,
          node: item,
          index: i
        })
        list.splice(i, 0, key)
      } else {
        // 找到了，需要判断是否需要移动
        if (index !== i) {
          changes.push({
            type: StateEnums.Move,
            from: index,
            to: i
          })
          move(list, index, i)
        }
      }
    })
  return { changes, list }
}

function getKeys(list) {
  let keys = []
  let text
  list &&
    list.forEach(item => {
      let key
      if (isString(item)) {
        key = [item]
      } else if (item instanceof Element) {
        key = item.key
      }
      keys.push(key)
    })
  return keys
}
```

**遍历子元素打标识**

> 对于这个函数来说，主要功能就两个

- 判断两个列表差异
  - 给节点打上标记
  - 总体来说，该函数实现的功能很简单

```js
function diffChildren(oldChild, newChild, index, patches) {
  let { changes, list } = listDiff(oldChild, newChild, index, patches)
  if (changes.length) {
    if (patches[index]) {
      patches[index] = patches[index].concat(changes)
    } else {
      patches[index] = changes
    }
  }
  // 记录上一个遍历过的节点
  let last = null
  oldChild &&
    oldChild.forEach((item, i) => {
      let child = item && item.children
      if (child) {
        index =
          last && last.children ? index + last.children.length + 1 : index + 1
        let keyIndex = list.indexOf(item.key)
        let node = newChild[keyIndex]
        // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历
        if (node) {
          dfs(item, node, index, patches)
        }
      } else index += 1
      last = item
    })
}
```

**渲染差异**

> 通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 `DOM` 了，下面就让我们来看看 `Virtual Dom` 算法的最后一步骤

**这个函数主要两个功能**

- 深度遍历树，将需要做变更操作的取出来
- 局部更新 `DOM`

```js
let index = 0
export default function patch(node, patchs) {
  let changes = patchs[index]
  let childNodes = node && node.childNodes
  // 这里的深度遍历和 diff 中是一样的
  if (!childNodes) index += 1
  if (changes && changes.length && patchs[index]) {
    changeDom(node, changes)
  }
  let last = null
  if (childNodes && childNodes.length) {
    childNodes.forEach((item, i) => {
      index =
        last && last.children ? index + last.children.length + 1 : index + 1
      patch(item, patchs)
      last = item
    })
  }
}

function changeDom(node, changes, noChild) {
  changes &&
    changes.forEach(change => {
      let { type } = change
      switch (type) {
        case StateEnums.ChangeProps:
          let { props } = change
          props.forEach(item => {
            if (item.value) {
              node.setAttribute(item.prop, item.value)
            } else {
              node.removeAttribute(item.prop)
            }
          })
          break
        case StateEnums.Remove:
          node.childNodes[change.index].remove()
          break
        case StateEnums.Insert:
          let dom
          if (isString(change.node)) {
            dom = document.createTextNode(change.node)
          } else if (change.node instanceof Element) {
            dom = change.node.create()
          }
          node.insertBefore(dom, node.childNodes[change.index])
          break
        case StateEnums.Replace:
          node.parentNode.replaceChild(change.node.create(), node)
          break
        case StateEnums.Move:
          let fromNode = node.childNodes[change.from]
          let toNode = node.childNodes[change.to]
          let cloneFromNode = fromNode.cloneNode(true)
          let cloenToNode = toNode.cloneNode(true)
          node.replaceChild(cloneFromNode, toNode)
          node.replaceChild(cloenToNode, fromNode)
          break
        default:
          break
      }
    })
}
```

**Virtual Dom 算法的实现也就是以下三步**

- 通过 `JS` 来模拟创建 `DOM` 对象
- 判断两个对象的差异
- 渲染差异

```js
let test4 = new Element('div', { class: 'my-div' }, ['test4'])
let test5 = new Element('ul', { class: 'my-div' }, ['test5'])

let test1 = new Element('div', { class: 'my-div' }, [test4])

let test2 = new Element('div', { id: '11' }, [test5, test4])

let root = test1.render()

let pathchs = diff(test1, test2)
console.log(pathchs)

setTimeout(() => {
  console.log('开始更新')
  patch(root, pathchs)
  console.log('结束更新')
}, 1000)
```

## [#](http://interview.poetries.top/excellent-docs/16-框架通识.html#_4-diff算法)4 Diff算法

### [#](http://interview.poetries.top/excellent-docs/16-框架通识.html#_4-1-react-diff)4.1 React-Diff

React的思路是递增法。通过对比新的列表中的节点，在原本的列表中的位置是否是递增，来判断当前节点是否需要移动。

**1. 实现原理**

来看这样一个例子。

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc8e69cb5b04387b7b259622a91bbe6~tplv-k3u1fbpfcp-watermark.image)

`nextList`为新的列表，`prevList`为旧列表。这个例子我们一眼能看出来，新列表是不需要进行移动的。下面我用`react`的递增思想，解释一下为什么新列表中的节点不需要移动。

我们首先遍历`nextList`，并且找到每一个节点，在`prevList`中的位置。

```js
function foo(prevList, nextList) {
    for (let i = 0; i < nextList.length; i++) {
        let nextItem = nextList[i];
        for (let j = 0; j < prevList.length; j++) {
            let prevItem = prevList[j]
            if (nextItem === prevItem) {

            }
        }
    }
}
```

找到位置以后，与上一个节点的位置进行对比，如果当前的位置大于上一个位置，说明当前节点不需要移动。因此我们要定义一个`lastIndex`来记录上一个节点的位置。

```js
function foo(prevList, nextList) {
    let lastIndex = 0
    for (let i = 0; i < nextList.length; i++) {
        let nextItem = nextList[i];
        for (let j = 0; j < prevList.length; j++) {
            let prevItem = prevList[j]
            if (nextItem === prevItem) {
                if (j < lastIndex) {
                    // 需要移动节点
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
            }
        }
    }
}
```

在上面的例子中，`nextList`每个节点在`prevList`的位置为`0 1 2 3`。每一项都要比前一项要大，所以不需要移动，这就是`react`的`diff`算法的原理。

**2. 找到需要移动的节点**

在上一小节中，我们是通过对比值是否相等，查找的对应位置。但是在vdom中，每一个节点都是一个vNode，我们应该如何进行判断呢？

答案就是`key`，我们通过对每个节点的`key`进行赋值，并且让处于同一`children`数组下的`vnode`的`key`都不相同，以此来确定每个节点的唯一性，并进行新旧列表的对比。

```js
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i];
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 需要移动节点
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
            }
        }
    }
}
```

**3. 移动节点**

首先我们先明确一点，移动节点所指的节点是`DOM`节点。`vnode.el`指向该节点对应的真实`DOM`节点。`patch`方法会将更新过后的`DOM`节点，赋值给**新的**`vnode`的`el`属性。

> 为了画图方便，我们用`key`的值来表示`vnode`节点。为了行文方便，我们把`key`值为`a`的`vnode`简写为`vnode-a`，`vnode-a`对应的真实DOM节点为`DOM-A`

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab3a37a997a84b95af9f39326bf2a24f~tplv-k3u1fbpfcp-watermark.image)

我们来将上图的例子代入`reactDiff`中执行。我们遍历**新列表**，并查找`vnode`在**旧列表**中的位置。当遍历到`vnode-d`时，之前遍历在**旧列表**的位置为`0 < 2 < 3`，说明`A C D`这三个节点都是不需要移动的。此时`lastIndex = 3`, 并进入下一次循环，发现`vnode-b`在**旧列表**的`index`为`1`，`1 < 3`，说明`DOM-B`要移动。

通过观察我们能发现，只需要把`DOM-B`移动到`DOM-D`之后就可以了。也就是**找到需要移动的VNode，我们称该VNode为α，将α对应的真实的DOM节点移动到，α在`新列表`中的前一个VNode对应的真实DOM的后面。**

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e757d546440478b83e938f3824f9364~tplv-k3u1fbpfcp-watermark.image)

在上述的例子中，就是将`vnode-b`对应的真实DOM节点`DOM-B`, 移动到`vnode-b`在新列表中的前一个`VNode`——`vnode-d`对应的真实DOM节点`DOM-D`的后面

```js
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i];
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
            }
        }
    }
}
```

为什么是这样移动的呢？首先我们列表是`从头到尾`遍历的。这就意味着对于当前`VNode`节点来说，该节点之前的所有节点都是排好序的，如果该节点需要移动，那么只需要将DOM节点移动到前一个`vnode`节点之后就可以，因为在**新列表**中`vnode`的顺序就是这样的。

**4. 添加节点**

上一小节我们只讲了如何移动节点，但是忽略了另外一种情况，就是在**新列表**中有全新的`VNode`节点，在**旧列表**中找不到。遇到这种情况，我们需要根据新的`VNode`节点生成`DOM`节点，并插入`DOM`树中。

至此，我们面临两个问题：1.如何发现全新的节点、2. 生成的`DOM`节点插入到哪里

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7f3ae4ecace400a801b35c156e2edfc~tplv-k3u1fbpfcp-watermark.image)

我们先来解决第一个问题，找节点还是比较简单的，我们定义一个`find`变量值为`false`。如果在**旧列表**找到了`key` 相同的`vnode`，就将`find`的值改为`true`。当遍历结束后判断`find`值，如果为`false`，说明当前节点为新节点

```js
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i],
            find = false;
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                find = true
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
                break
            }
        }
        if (!find) {
            // 插入新节点
        }
    }
}
```

找到新节点后，下一步就是插入到哪里了，这里的逻辑其实是和移动节点的逻辑是一样的。我们观察上图可以发现，新的`vnode-c`是紧跟在`vnode-b`后面的，并且`vnode-b`的DOM节点——`DOM-B`是已经排好序的，所以我们只需要将`vnode-c`生成的DOM节点插入到`DOM-B`之后就可以了。

但是这里有一种特殊情况需要注意，就是新的节点位于**新列表**的第一个，这时候我们需要找到**旧列表**第一个节点，将新节点插入到原来第一个节点之前就可以了。

```js
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i],
            find = false;
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                find = true
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
                break
            }
        }
        if (!find) {
            // 插入新节点
            let refNode = i <= 0
                            ? prevChildren[0].el
                            : nextChildren[i - 1].el.nextSibling
            mount(nextChild, parent, refNode);
        }
    }
}
```

**5. 移除节点**

有增就有减，当旧的节点不在**新列表**中时，我们就将其对应的DOM节点移除。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cf836312b6345d98b4ea8c9efe80a9a~tplv-k3u1fbpfcp-watermark.image?imageslim)

```js
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i],
            find = false;
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                find = true
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点，记录当前位置，与之后的节点进行对比
                    lastIndex = j
                }
                break
            }
        }
        if (!find) {
            // 插入新节点
            let refNode = i <= 0
                            ? prevChildren[0].el
                            : nextChildren[i - 1].el.nextSibling
            mount(nextChild, parent, refNode);
        }
    }
    for (let i = 0; i < prevChildren.length; i++) {
        let prevChild = prevChildren[i],
            key = prevChild.key,
            has = nextChildren.find(item => item.key === key);
        if (!has) parent.removeChild(prevChild.el)
    }
}
```

**6. 优化与不足**

以上就是React的diff算法的思路。

目前的`reactDiff`的时间复杂度为`O(m*n)`，我们可以用空间换时间，把`key`与`index`的关系维护成一个`Map`，从而将时间复杂度降低为`O(n)`，具体的代码可以[查看此项目 (opens new window)](https://github.com/sunyanzhe/virtual-dom/blob/master/src/diff/react-diff.js)。

我们接下来看这样一个例子

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aed2a562a9674f5293e4e51a1b8b9005~tplv-k3u1fbpfcp-watermark.image)

根据`reactDiff`的思路，我们需要先将`DOM-A`移动到`DOM-C`之后，然后再将`DOM-B`移动到`DOM-A`之后，完成`Diff`。但是我们通过观察可以发现，只要将`DOM-C`移动到`DOM-A`之前就可以完成`Diff`。

这里是有可优化的空间的，接下来我们介绍`vue2.x`中的`diff`算法——`双端比较`，该算法解决了上述的问题

### [#](http://interview.poetries.top/excellent-docs/16-框架通识.html#_4-2-vue2-x-diff-双端比较)4.2 Vue2.X Diff —— 双端比较

所谓`双端比较`就是**新列表**和**旧列表**两个列表的头与尾互相对比，，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的节点全部遍历过，对比停止。

**1. 实现原理**

我们先用四个指针指向两个列表的头尾

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[nextStartIndex],
    newEndNode = nextChildren[nextEndIndex];
}
```

我们根据四个指针找到四个节点，然后进行对比，那么如何对比呢？我们按照以下四个步骤进行对比

1. 使用**旧列表**的头一个节点`oldStartNode`与**新列表**的头一个节点`newStartNode`对比
2. 使用**旧列表**的最后一个节点`oldEndNode`与**新列表**的最后一个节点`newEndNode`对比
3. 使用**旧列表**的头一个节点`oldStartNode`与**新列表**的最后一个节点`newEndNode`对比
4. 使用**旧列表**的最后一个节点`oldEndNode`与**新列表**的头一个节点`newStartNode`对比

使用以上四步进行对比，去寻找`key`相同的可复用的节点，当在某一步中找到了则停止后面的寻找。具体对比顺序如下图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847306f303ab4177891b56cccff1ebd3~tplv-k3u1fbpfcp-watermark.image)

对比顺序代码结构如下:

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newEndIndex];
  
  if (oldStartNode.key === newStartNode.key) {

  } else if (oldEndNode.key === newEndNode.key) {

  } else if (oldStartNode.key === newEndNode.key) {

  } else if (oldEndNode.key === newStartNode.key) {

  }
}
```

当对比时找到了可复用的节点，我们还是先`patch`给元素打补丁，然后将指针进行`前/后移`一位指针。根据对比节点的不同，我们移动的**指针**和**方向**也不同，具体规则如下：

1. 当**旧列表**的头一个节点`oldStartNode`与**新列表**的头一个节点`newStartNode`对比时`key`相同。那么**旧列表**的头指针`oldStartIndex`与**新列表**的头指针`newStartIndex`同时向**后**移动一位。
2. 当**旧列表**的最后一个节点`oldEndNode`与**新列表**的最后一个节点`newEndNode`对比时`key`相同。那么**旧列表**的尾指针`oldEndIndex`与**新列表**的尾指针`newEndIndex`同时向**前**移动一位。
3. 当**旧列表**的头一个节点`oldStartNode`与**新列表**的最后一个节点`newEndNode`对比时`key`相同。那么**旧列表**的头指针`oldStartIndex`向**后**移动一位；**新列表**的尾指针`newEndIndex`向**前**移动一位。
4. 当**旧列表**的最后一个节点`oldEndNode`与**新列表**的头一个节点`newStartNode`对比时`key`相同。那么**旧列表**的尾指针`oldEndIndex`向**前**移动一位；**新列表**的头指针`newStartIndex`向**后**移动一位。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1,
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newEndIndex];

  if (oldStartNode.key === newStartNode.key) {
    patch(oldvStartNode, newStartNode, parent)

    oldStartIndex++
    newStartIndex++
    oldStartNode = prevChildren[oldStartIndex]
    newStartNode = nextChildren[newStartIndex]
  } else if (oldEndNode.key === newEndNode.key) {
    patch(oldEndNode, newEndNode, parent)

    oldEndIndex--
    newEndIndex--
    oldEndNode = prevChildren[oldEndIndex]
    newEndNode = nextChildren[newEndIndex]
  } else if (oldStartNode.key === newEndNode.key) {
    patch(oldStartNode, newEndNode, parent)

    oldStartIndex++
    newEndIndex--
    oldStartNode = prevChildren[oldStartIndex]
    newEndNode = nextChildren[newEndIndex]
  } else if (oldEndNode.key === newStartNode.key) {
    patch(oldEndNode, newStartNode, parent)

    oldEndIndex--
    nextStartIndex++
    oldEndNode = prevChildren[oldEndIndex]
    newStartNode = nextChildren[newStartIndex]
  }
}
```

在小节的开头，提到了要让指针向内靠拢，所以我们需要循环。循环停止的条件是当其中一个列表的节点全部遍历完成，代码如下

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1,
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newEndIndex];
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
      patch(oldStartNode, newStartNode, parent)

      oldStartIndex++
      newStartIndex++
      oldStartNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newEndNode.key) {
      patch(oldEndNode, newEndNode, parent)

      oldEndIndex--
      newndIndex--
      oldEndNode = prevChildren[oldEndIndex]
      newEndNode = nextChildren[newEndIndex]
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldvStartNode, newEndNode, parent)

      oldStartIndex++
      newEndIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newEndIndex]
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)

      oldEndIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldEndIndex]
      newStartNode = nextChildren[newStartIndex]
    }
  }
}
```

至此整体的循环我们就全部完成了，下面我们需要考虑这样两个问题：

- 什么情况下`DOM`节点需要移动
- `DOM`节点如何移动

我们来解决第一个问题：**什么情况下需要移动**，我们还是以上图为例。

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8c96a75e48346aea2c7de1d8bfa6f67~tplv-k3u1fbpfcp-watermark.image)

当我们在第一个循环时，在`第四步`发现**旧列表的尾节点**`oldEndNode`与**新列表的头节点**`newStartNode`的`key`相同，是可复用的`DOM`节点。通过观察我们可以发现，**原本在旧列表末尾的节点，却是新列表中的开头节点，没有人比他更靠前，因为他是第一个，所以我们只需要把当前的节点移动到原本旧列表中的第一个节点之前，让它成为第一个节点即可**。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
 // ...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
       // ...
    } else if (oldEndNode.key === newEndNode.key) {
      // ...
    } else if (oldStartNode.key === newEndNode.key) {
      // ...
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)
      // 移动到旧列表头节点之前
      parent.insertBefore(oldEndNode.el, oldStartNode.el)
      
      oldEndIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldEndIndex]
      newStartNode = nextChildren[newStartIndex]
    }
  }
}
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7f3368a5a5744bcb2b356d7424093a6~tplv-k3u1fbpfcp-watermark.image)

然后我们进入第二次循环，我们在`第二步`发现，**旧列表的尾节点**`oldEndNode`和**新列表的尾节点**`newEndNode`为复用节点。**原本在旧列表中就是尾节点，在新列表中也是尾节点，说明该节点不需要移动**，所以我们什么都不需要做。

同理，如果是**旧列表的头节点**`oldStartNode`和**新列表的头节点**`newStartNode`为复用节点，我们也什么都不需要做。

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2520c8511aad44589947be3616f7f50b~tplv-k3u1fbpfcp-watermark.image)

进入第三次循环，我们在`第三部`发现，**旧列表的头节点**`oldStartNode`和**新列表的尾节点**`newEndNode`为复用节点。到这一步聪明如你肯定就一眼可以看出来了，我们只要将`DOM-A`移动到`DOM-B`后面就可以了。

依照惯例我们还是解释一下，**原本旧列表中是头节点，然后在新列表中是尾节点。那么只要在旧列表中把当前的节点移动到原本尾节点的后面，就可以了**。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  // ...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
      // ...
    } else if (oldEndNode.key === newEndNode.key) {
      // ...
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldStartNode, newEndNode, parent)
      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling)

      oldStartIndex++
      newEndIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newEndIndex]
    } else if (oldEndNode.key === newStartNode.key) {
     //...
    }
  }
}
```

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0a744cac8045fc9ae4f593a153cc72~tplv-k3u1fbpfcp-watermark.image)

OK，进入最后一个循环。在`第一步`**旧列表**头节点`oldStartNode`与**新列表**头节点`newStartNode`位置相同，所以啥也不用做。然后结束循环，这就是`Vue2 双端比较`的原理。

**2. 非理想情况**

上一小节，我们讲了`双端比较`的原理，但是有一种特殊情况，当四次对比都**没找到**复用节点时，我们只能拿**新列表**的第一个节点去**旧列表**中找与其`key`相同的节点。

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dea77f7267b406ca0dc8600096c4dc1~tplv-k3u1fbpfcp-watermark.image)

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
    }
  }
}
```

找节点的时候其实会有两种情况：一种在**旧列表**中找到了，另一种情况是没找到。我们先以上图为例，说一下找到的情况。

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a74e61a47abb4e3ca85ffee65410340d~tplv-k3u1fbpfcp-watermark.image)

当我们在旧列表中找到对应的`VNode`，我们只需要将找到的节点的`DOM`元素，移动到开头就可以了。这里的逻辑其实和`第四步`的逻辑是一样的，只不过`第四步`是移动的尾节点，这里是移动找到的节点。`DOM`移动后，由我们将**旧列表**中的节点改为`undefined`，这是**至关重要**的一步，因为我们已经做了节点的移动了所以我们不需要进行再次的对比了。最后我们将头指针`newStartIndex`向后移一位。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newtKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
      if (oldIndex > -1) {
        let oldNode = prevChildren[oldIndex];
        patch(oldNode, newStartNode, parent)
        parent.insertBefore(oldNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      }
      newStartNode = nextChildren[++newStartIndex]
    }
  }
}
```

如果在**旧列表**中没有找到复用节点呢？很简单，直接创建一个新的节点放到最前面就可以了，然后后移头指针`newStartIndex`。

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bbefb16b2bf4d52bb9b2a5f5ea86ec1~tplv-k3u1fbpfcp-watermark.image)

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newtKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
      if (oldIndex > -1) {
        let oldNode = prevChildren[oldIndex];
        patch(oldNode, newStartNode, parent)
        parent.insertBefore(oldNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      } else {
      	mount(newStartNode, parent, oldStartNode.el)
      }
      newStartNode = nextChildren[++newStartIndex]
    }
  }
}
```

最后当**旧列表**遍历到`undefind`时就跳过当前节点。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode === undefind) {
    	oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefind) {
    	oldEndNode = prevChildren[--oldEndIndex]
    } else if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
    // ...
    }
  }
}
```

**3. 添加节点**

我们先来看一个例子

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85517a9eb0a34165832394b9d4e7627d~tplv-k3u1fbpfcp-watermark.image)

这个例子非常简单，几次循环都是尾节点相同，尾指针一直向前移动，直到循环结束，如下图

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/668208458312440cae49139534fd6d59~tplv-k3u1fbpfcp-watermark.image)

此时`oldEndIndex`以及小于了`oldStartIndex`，但是**新列表**中还有剩余的节点，我们只需要将剩余的节点依次插入到`oldStartNode`的`DOM`之前就可以了。为什么是插入`oldStartNode`之前呢？原因是剩余的节点在**新列表**的位置是位于`oldStartNode`之前的，如果剩余节点是在`oldStartNode`之后，`oldStartNode`就会先行对比，这个需要思考一下，其实还是与`第四步`的思路一样。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
  // ...
  }
  if (oldEndIndex < oldStartIndex) {
    for (let i = newStartIndex; i <= newEndIndex; i++) {
      mount(nextChildren[i], parent, prevStartNode.el)
    }
  }
}
```

**4. 移除节点**

与上一小节的情况相反，当**新列表**的`newEndIndex`小于`newStartIndex`时，我们将**旧列表**剩余的节点删除即可。这里我们需要注意，**旧列表**的`undefind`。在第二小节中我们提到过，当头尾节点都不相同时，我们会去**旧列表**中找**新列表**的第一个节点，移动完DOM节点后，将**旧列表**的那个节点改为`undefind`。所以我们在最后的删除时，需要注意这些`undefind`，遇到的话跳过当前循环即可。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
  // ...
  }
  if (oldEndIndex < oldStartIndex) {
    for (let i = newStartIndex; i <= newEndIndex; i++) {
      mount(nextChildren[i], parent, prevStartNode.el)
    }
  } else if (newEndIndex < newStartIndex) {
    for (let i = oldStartIndex; i <= oldEndIndex; i++) {
      if (prevChildren[i]) {
        partent.removeChild(prevChildren[i].el)
      }
    }
  }
}
```

**5. 小结**

至此`双端比较`全部完成，以下是全部代码。

```js
function vue2diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    newStartIndex = 0,
    oldStartIndex = prevChildren.length - 1,
    newStartIndex = nextChildren.length - 1,
    oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldStartIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newStartIndex];
  while (oldStartIndex <= oldStartIndex && newStartIndex <= newStartIndex) {
    if (oldStartNode === undefined) {
      oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefined) {
      oldEndNode = prevChildren[--oldStartIndex]
    } else if (oldStartNode.key === newStartNode.key) {
      patch(oldStartNode, newStartNode, parent)

      oldStartIndex++
      newStartIndex++
      oldStartNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newEndNode.key) {
      patch(oldEndNode, newEndNode, parent)

      oldStartIndex--
      newStartIndex--
      oldEndNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldStartNode, newEndNode, parent)
      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling)
      oldStartIndex++
      newStartIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)
      parent.insertBefore(oldEndNode.el, oldStartNode.el)
      oldStartIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else {
      let newKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child && (child.key === newKey));
      if (oldIndex === -1) {
        mount(newStartNode, parent, oldStartNode.el)
      } else {
        let prevNode = prevChildren[oldIndex]
        patch(prevNode, newStartNode, parent)
        parent.insertBefore(prevNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      }
      newStartIndex++
      newStartNode = nextChildren[newStartIndex]
    }
  }
  if (newStartIndex > newStartIndex) {
    while (oldStartIndex <= oldStartIndex) {
      if (!prevChildren[oldStartIndex]) {
        oldStartIndex++
        continue
      }
      parent.removeChild(prevChildren[oldStartIndex++].el)
    }
  } else if (oldStartIndex > oldStartIndex) {
    while (newStartIndex <= newStartIndex) {
      mount(nextChildren[newStartIndex++], parent, oldStartNode.el)
    }
  }
}
```

### [#](http://interview.poetries.top/excellent-docs/16-框架通识.html#_4-3-vue3-diff-最长递增子序列)4.3 Vue3 Diff —— 最长递增子序列

`vue3`的`diff`借鉴于[inferno (opens new window)](https://github.com/infernojs/inferno)，该算法其中有两个理念。第一个是相同的前置与后置元素的预处理；第二个则是最长递增子序列，此思想与`React`的`diff`类似又不尽相同。下面我们来一一介绍。

**1. 前置与后置的预处理**

我们看这两段文字

```text
Hello World
Hey World
```

其实就简单的看一眼我们就能发现，这两段文字是有一部分是相同的，**这些文字是不需要修改也不需要移动的**，真正需要进行修改中间的几个字母，所以`diff`就变成以下部分

```text
text1: 'llo'
text2: 'y'
```

接下来换成`vnode`，我们以下图为例。

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a27b4fa05b434889d99ae6fe832b4d~tplv-k3u1fbpfcp-watermark.image)

图中的被绿色框起来的节点，他们是不需要移动的，只需要进行打补丁`patch`就可以了。我们把该逻辑写成代码。

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  let j = 0,
    prevEnd = prevChildren.length - 1,
    nextEnd = nextChildren.length - 1,
    prevNode = prevChildren[j],
    nextNode = nextChildren[j];
  while (prevNode.key === nextNode.key) {
    patch(prevNode, nextNode, parent)
    j++
    prevNode = prevChildren[j]
    nextNode = nextChildren[j]
  }
  
  prevNode = prevChildren[prevEnd]
  nextNode = prevChildren[nextEnd]
  
  while (prevNode.key === nextNode.key) {
    patch(prevNode, nextNode, parent)
    prevEnd--
    nextEnd--
    prevNode = prevChildren[prevEnd]
    nextNode = prevChildren[nextEnd]
  }
}
```

这时候，我们就需要考虑边界情况了，这里有两种情况。一种是`j > prevEnd`；另一种是`j > nextEnd`。

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52779ed5f26a451d8098e945709132cf~tplv-k3u1fbpfcp-watermark.image)

我们以这张图为例，此时`j > prevEnd`且`j <= nextEnd`，我们只需要把**新列表**中`j`到`nextEnd`之间剩下的节点**插入**进去就可以了。相反， 如果`j > nextEnd`时，我们把**旧列表**中`j`到`prevEnd`之间的节点**删除**就可以了。

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  // ...
  if (j > prevEnd && j <= nextEnd) {
    let nextpos = nextEnd + 1,
      refNode = nextpos >= nextChildren.length
                ? null
                : nextChildren[nextpos].el;
    while(j <= nextEnd) mount(nextChildren[j++], parent, refNode)
    
  } else if (j > nextEnd && j <= prevEnd) {
    while(j <= prevEnd) parent.removeChild(prevChildren[j++].el)
  }
}
```

我们再继续思考，在我们`while`循环时，指针是从两端向内逐渐靠拢的，所以我们应该在循环中就应该去判断边界情况，我们使用`label`语法，当我们触发边界情况时，退出全部的循环，直接进入判断。代码如下：

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  let j = 0,
    prevEnd = prevChildren.length - 1,
    nextEnd = nextChildren.length - 1,
    prevNode = prevChildren[j],
    nextNode = nextChildren[j];
  // label语法
  outer: {
    while (prevNode.key === nextNode.key) {
      patch(prevNode, nextNode, parent)
      j++
      // 循环中如果触发边界情况，直接break，执行outer之后的判断
      if (j > prevEnd || j > nextEnd) break outer
      prevNode = prevChildren[j]
      nextNode = nextChildren[j]
    }

    prevNode = prevChildren[prevEnd]
    nextNode = prevChildren[nextEnd]

    while (prevNode.key === nextNode.key) {
      patch(prevNode, nextNode, parent)
      prevEnd--
      nextEnd--
      // 循环中如果触发边界情况，直接break，执行outer之后的判断
      if (j > prevEnd || j > nextEnd) break outer
      prevNode = prevChildren[prevEnd]
      nextNode = prevChildren[nextEnd]
    }
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    let nextpos = nextEnd + 1,
      refNode = nextpos >= nextChildren.length
                ? null
                : nextChildren[nextpos].el;
    while(j <= nextEnd) mount(nextChildren[j++], parent, refNode)
    
  } else if (j > nextEnd && j <= prevEnd) {
    while(j <= prevEnd) parent.removeChild(prevChildren[j++].el)
  }
}
```

**2. 判断是否需要移动**

其实几个算法看下来，套路已经很明显了，就是找到移动的节点，然后给他移动到正确的位置。把该加的新节点添加好，把该删的旧节点删了，整个算法就结束了。这个算法也不例外，我们接下来看一下它是如何做的。

当`前/后置`的预处理结束后，我们进入真正的`diff`环节。首先，我们先根据**新列表**剩余的节点数量，创建一个`source`数组，并将数组填满`-1`。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75944ec3b6a245989a0eaf7e474ef174~tplv-k3u1fbpfcp-watermark.image)

我们先写这块逻辑。

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1);  // 创建数组，填满-1
     
  }
}
```

那么这个`source`数组，是要做什么的呢？他就是来做新旧节点的对应关系的，我们将**新节点**在**旧列表**的位置存储在该数组中，我们在根据`source`计算出它的`最长递增子序列`用于移动DOM节点。为此，我们先建立一个对象存储当前**新列表**中的`节点`与`index`的关系，再去**旧列表**中去找位置。

在找节点时要注意，**如果旧节点在新列表中没有的话，直接删除就好**。除此之外，我们还需要一个数量表示记录我们已经`patch`过的节点，如果数量已经与**新列表**剩余的节点数量一样，那么剩下的`旧节点`我们就直接删除了就可以了

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1),  // 创建数组，填满-1
      nextIndexMap = {},                      // 新列表节点与index的映射
      patched = 0;                            // 已更新过的节点的数量
      
    // 保存映射关系  
    for (let i = nextStart; i <= nextEnd; i++) {
      let key = nextChildren[i].key
      nextIndexMap[key] = i
    } 
    
    // 去旧列表找位置
    for (let i = prevStart; i <= prevEnd; i++) {
      let prevNode = prevChildren[i],
      	prevKey = prevNode.key,
        nextIndex = nextIndexMap[prevKey];
      // 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点
      if (nextIndex === undefind || patched >= nextLeft) {
        parent.removeChild(prevNode.el)
        continue
      }
      // 找到对应的节点
      let nextNode = nextChildren[nextIndex];
      patch(prevNode, nextNode, parent);
      // 给source赋值
      source[nextIndex - nextStart] = i
      patched++
    }
  }
}
```

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01f5d145e4a84e3f922b4d39f80bcb6a~tplv-k3u1fbpfcp-watermark.image)

找到位置后，我们观察这个重新赋值后的`source`，我们可以看出，如果是全新的节点的话，其在`source`数组中对应的值就是初始的`-1`，通过这一步我们可以区分出来哪个为全新的节点，哪个是可复用的。

其次，我们要判断是否需要移动。那么如何判断移动呢？很简单，和`React`一样我们用递增法，如果我们找到的`index`是一直递增的，说明不需要移动任何节点。我们通过设置一个变量来保存是否需要移动的状态。

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1),  // 创建数组，填满-1
      nextIndexMap = {},                      // 新列表节点与index的映射
      patched = 0,
      move = false,                           // 是否移动
      lastIndex = 0;                          // 记录上一次的位置
      
    // 保存映射关系  
    for (let i = nextStart; i <= nextEnd; i++) {
      let key = nextChildren[i].key
      nextIndexMap[key] = i
    } 
    
    // 去旧列表找位置
    for (let i = prevStart; i <= prevEnd; i++) {
      let prevNode = prevChildren[i],
      	prevKey = prevNode.key,
        nextIndex = nextIndexMap[prevKey];
      // 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点
      if (nextIndex === undefind || patched >= nextLeft) {
        parent.removeChild(prevNode.el)
        continue
      }
      // 找到对应的节点
      let nextNode = nextChildren[nextIndex];
      patch(prevNode, nextNode, parent);
      // 给source赋值
      source[nextIndex - nextStart] = i
      patched++
      
      // 递增方法，判断是否需要移动
      if (nextIndex < lastIndex) {
      	move = false
      } else {
      	lastIndex = nextIndex
      }
    }
    
    if (move) {
    
    // 需要移动
    } else {
	
    //不需要移动
    }
  }
}
```

**3. DOM如何移动**

判断完是否需要移动后，我们就需要考虑如何移动了。一旦需要进行DOM移动，我们首先要做的就是找到`source`的**最长递增子序列**。

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
	const seq = lis(source); // [0, 1]
  // 需要移动
  } else {

  //不需要移动
  }
}
```

> 什么是最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。
>
> 例如给定数值序列为：[ 0, 8, 4, 12 ]。
>
> 那么它的最长递增子序列就是：[0, 8, 12]。
>
> 当然答案可能有多种情况，例如：[0, 4, 12] 也是可以的。

上面的代码中，我们调用`lis` 函数求出数组`source`的最长递增子序列为`[ 0, 1 ]`。我们知道 source 数组的值为 `[2, 3, 1, -1]`，很显然最长递增子序列应该是`[ 2, 3 ]`，但为什么计算出的结果是`[ 0, 1 ]`呢？其实`[ 0, 1 ]`代表的是最长递增子序列中的各个元素在`source`数组中的位置索引，如下图所示：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c80851ea784e03b3c995234c70e9a3~tplv-k3u1fbpfcp-watermark.image)

我们根据`source`，对**新列表**进行重新编号，并找出了`最长递增子序列`。

我们从后向前进行遍历`source`每一项。此时会出现三种情况：

1. 当前的值为`-1`，这说明该节点是全新的节点，又由于我们是**从后向前**遍历，我们直接创建好DOM节点插入到队尾就可以了。
2. 当前的索引为`最长递增子序列`中的值，也就是`i === seq[j]`，这说说明该节点不需要移动
3. 当前的索引不是`最长递增子序列`中的值，那么说明该DOM节点需要移动，这里也很好理解，我们也是直接将DOM节点插入到队尾就可以了，因为队尾是排好序的

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
   // 需要移动
	const seq = lis(source); // [0, 1]
    let j = seq.length - 1;  // 最长子序列的指针
    // 从后向前遍历
    for (let i = nextLeft - 1； i >= 0; i--) {
      let pos = nextStart + i, // 对应新列表的index
        nextNode = nextChildren[pos],	// 找到vnode
      	nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
        refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
        cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
        // 情况1，该节点是全新节点
      	mount(nextNode, parent, refNode)
      } else if (cur === seq[j]) {
        // 情况2，是递增子序列，该节点不需要移动
        // 让j指向下一个
        j--
      } else {
        // 情况3，不是递增子序列，该节点需要移动
        parent.insetBefore(nextNode.el, refNode)
      }
    }
 
  } else {
  //不需要移动
  
  }
}
```

说完了需要移动的情况，再说说不需要移动的情况。如果不需要移动的话，我们只需要判断是否有全新的节点给他添加进去就可以了。具体代码如下：

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
	const seq = lis(source); // [0, 1]
    let j = seq.length - 1;  // 最长子序列的指针
    // 从后向前遍历
    for (let i = nextLeft - 1； i >= 0; i--) {
      let pos = nextStart + i, // 对应新列表的index
        nextNode = nextChildren[pos],	// 找到vnode
      	nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
        refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
        cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
        // 情况1，该节点是全新节点
      	mount(nextNode, parent, refNode)
      } else if (cur === seq[j]) {
        // 情况2，是递增子序列，该节点不需要移动
        // 让j指向下一个
        j--
      } else {
        // 情况3，不是递增子序列，该节点需要移动
        parent.insetBefore(nextNode.el, refNode)
      }
    }
  } else {
    //不需要移动
    for (let i = nextLeft - 1； i >= 0; i--) {
      let cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
       let pos = nextStart + i, // 对应新列表的index
          nextNode = nextChildren[pos],	// 找到vnode
          nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
          refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
      	mount(nextNode, parent, refNode)
      }
    }
  }
}
```

至此`vue3.0`的diff完成。

**4. 最长递增子序列**

我们以该数组为例

```js
[10,9,2,5,3,8,7,13]
```

我们可以使用动态规划的思想考虑这个问题。动态规划的思想是将一个大的问题分解成多个小的子问题，并尝试得到这些子问题的最优解，子问题的最优解有可能会在更大的问题中被利用，这样通过小问题的最优解最终求得大问题的最优解。

我们先假设只有一个值的数组`[13]`，那么该数组的最长递增子序列就是`[13]`自己本身，其长度为`1`。**那么我们认为每一项的递增序列的长度值均为1**

那么我们这次给数组增加一个值`[7, 13]`, 由于`7 < 13`，所以该数组的最长递增子序列是`[7, 13]`，那么该长度为`2`。**那么我们是否可以认为，当`[7]`小于`[13]`时，以`[7]`为头的递增序列的长度是，`[7]`的长度和`[13]`的长度的和**，即`1 + 1 = 2`。

ok，我们基于这种思想来给计算一下该数组。我们先将每个值的初始赋值为`1`

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b62114779ce647db906d73ab1a737298~tplv-k3u1fbpfcp-watermark.image)

首先 `7 < 13` 那么`7`对应的长度就是`13`的长度再加1，`1 + 1 = 2`

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80dc121621324857ab806f8220f264b4~tplv-k3u1fbpfcp-watermark.image)

继续，我们对比`8`。我们首先和`7`比，发现不满足递增，但是没关系我们还可以继续和`13`比，`8 < 13`满足递增，那么`8`的长度也是`13`的长度在加一，长度为`2`

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2782096530ba4f76ae05d4eece27298f~tplv-k3u1fbpfcp-watermark.image)

我们再对比`3`，我们先让其与`8`进行对比，`3 < 8`，那么`3`的长度是`8`的长度加一，此时`3`的长度为`3`。但是还没结束，我们还需要让`3`与`7`对比。同样`3 < 7`，此时我们需要在计算出一个长度是`7`的长度加一同样是`3`，我们对比两个长度，**如果原本的长度没有本次计算出的长度值大的话，我们进行替换，反之则我们保留原本的值**。由于`3 === 3`，我们选择不替换。最后，我们让`3`与`13`进行对比，同样的`3 < 13`，此时计算出的长度为`2`，比原本的长度`3`要小，我们选择保留原本的值。

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca21599c47c429ab0067c093c9e8bd0~tplv-k3u1fbpfcp-watermark.image)

之后的计算依次类推，最后的结果是这样的

![image-20210220201751694](http://img-repo.poetries.top/images/image-20210220201751694.png)

我们从中取最大的值`4`，该值代表的**最长递增子序列的个数**。代码如下：

```js
function lis(arr) {
  let len = arr.length,
    dp = new Array(len).fill(1); // 用于保存长度
  for (let i = len - 1; i >= 0; i--) {
    let cur = arr[i]
    for(let j = i + 1; j < len; j++) {
      let next = arr[j]
      // 如果是递增 取更大的长度值
      if (cur < next) dp[i] = Math.max(dp[j]+1, dp[i])
    }
  }
  return Math.max(...dp)
}
```

至此为止，我们讲完了基础的最长递增子序列。然而在`vue3.0`中，我们需要的是最长递增子序列在原本数组中的索引。所以我们还需要在创建一个数组用于保存每个值的最长子序列所对应在数组中的`index`。具体代码如下：

```js
function lis(arr) {
  let len = arr.length,
    res = [],
    dp = new Array(len).fill(1);
  // 存默认index
  for (let i = 0; i < len; i++) {
    res.push([i])
  }
  for (let i = len - 1; i >= 0; i--) {
    let cur = arr[i],
      nextIndex = undefined;
    // 如果为-1 直接跳过，因为-1代表的是新节点，不需要进行排序
    if (cur === -1) continue
    for (let j = i + 1; j < len; j++) {
      let next = arr[j]
      // 满足递增条件
      if (cur < next) {
        let max = dp[j] + 1
        // 当前长度是否比原本的长度要大
        if (max > dp[i]) {
          dp[i] = max
          nextIndex = j
        }
      }
    }
    // 记录满足条件的值，对应在数组中的index
    if (nextIndex !== undefined) res[i].push(...res[nextIndex])
  }
  let index = dp.reduce((prev, cur, i, arr) => cur > arr[prev] ? i : prev, dp.length - 1)
  // 返回最长的递增子序列的index
  return result[index]
}
```

# 17 排序算法

![img](http://img-repo.poetries.top/images/20210330120838.png)

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#冒泡排序)冒泡排序

> 通过相邻元素比较和交换，使得每一趟循环都能找到未排序的子数组。

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#实现)实现

```js
function bubbleSort(list) {
  var n = list.length
  if(!n) return []
  
  for(var i = 0; i < n; i++) {
    for(var j = 0; j < n - i - 1; j++) {
      if(list[j] > list[j + 1]) {
        var temp = list[j + 1]
        list[j + 1] = list[j]
        list[j] = temp
      }
    }
  }
  return list
}
```

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#优化)优化

#### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#单向冒泡)单向冒泡

> 标记在一轮比较汇总中，如果没有需要交换的数据，说明数组已经是有序的，可以减少排序循环的次数。

```js
function bubbleSort(list) {
  var n = list.length
  if(!n) return []
  
  for(var i = 0; i < n; i++) {
    let mark = true // 如果在一轮比较中没有出现需要交换的数据，说明数组已经是有序的
    for(let j = 0; j < n - i - 1; j++) {
      if(list[j] > list[j + 1]) {
        var temp = list[j + 1]
        list[j + 1] = list[j]
        list[j] = temp
        mark = false
      }
    }
    if(mark) break 
  }
  
  return list
}
```

#### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#双向冒泡)双向冒泡

> 普通冒泡排序一轮只找到最大值或最小值其中之一，双向冒泡则多一轮筛选，既可以找到最大值，也可以找到最小值。

```js
function bubbleSort(list) {
  var low = 0
  var high = list.length - 1
  while(low < high) {
    var mark = true
    // 找到最大值放在右边
    for(var i = low; i < high; i++) {
      if(list[i] > list[i + 1]) {
        var temp = list[i + 1]
        list[i + 1] = list[i]
        list[i] = temp
        mark = false
      }
    }
    high--
    // 找到最小值放在左边
    for(var j = high; j > low; j--) {
      if(list[j] < list[j - 1]) {
        var temp = list[j - 1]
        list[j - 1] = list[j]
        list[j] = temp
        mark = false
      }
    }
    low++
    if(mark) break
  }
  return list
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#选择排序)选择排序

> 依次找到剩余元素的最小值或者最大值，放置末尾或者开头。

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#实现-2)实现

```js
function selectSort(list) {
  var n = list.length
  var minIndex
  
  for(var i = 0; i < n - 1; i++) {
    minIndex = i
    for(var j = i + 1; j < n; j++) {
      if(list[j] < list[minIndex]) {
        minIndex = j
      }
    }
    var temp = list[i]
		list[i] = list[minIndex]
    list[minIndex] = temp
  }
  return list
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#插入排序)插入排序

> 以第一个元素为有序数组，其后的元素通过在这个已有序的数组中找到合适的元素并插入。

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#实现-3)实现

```js
function insertSort(list) {
  var n = list.length
  var preIndex
  var current
  
  for(var i = 1; i < n; i++) {
    preIndex = i - 1
    current = list[i]
    
    while(preIndex >=0 && list[preIndex] > current) {
      list[preIndex + 1] = list[preIndex]
      preIndex--
    }
    list[preIndex + 1] = current
  }
  return list
}
```

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#优化-2)优化

#### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#拆半插入)拆半插入

```js
function insertSort(list) {
  var low
  var high
  var j
  var temp
  for (var i = 1; i < list.length; i++) {
    if (list[i] < list[i - 1]) {
      temp = list[i]
      low = 0
      high = i - 1
      while (low <= high) {
        let mid = Math.floor((low + high) / 2)
        if (temp > list[mid]) {
          low = mid + 1
        } else {
          high = mid - 1
        }
      }
      for (j = i; j > low; --j) {
        list[j] = list[j - 1]
      }
      list[j] = temp
    }
  }
  return list
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#希尔排序)希尔排序

> 通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。

```js
function shellSort(list) {
  var n = list.length
  var gap = parseInt(n / 2) // 初始化步数
  while(gap) { // 逐步缩小步数
    for(var i = gap; i < n; i++) {
      // 逐步和前面其他成员比较交换
      for(var j = i - gap; j >=0; j -= gap) {
        if(list[j] > list[j + gap]) {
          var temp = list[j + gap]
          list[j + gap] = list[j]
          list[j] = temp
        } else {
          break
        }
      }
    }
    gap = parseInt(gap / 2)
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#归并排序)归并排序

> 递归将数组分成两个序列，有序合并这两个序列。作为一种典型的分治法思想算法应用，归并排序的实现有两种方法：
>
> - 自上而下的递归
> - 自下而上的迭代

```js
function mergeSort(list) {
  var n = list.length
  if(n < 2) return list
  
  var mid = Math.floor(n / 2)
  var left = list.slice(0, mid)
  var right = list.slice(mid)
  
  return merge(mergeSort(left), mergeSort(right))
}

function merge(left, right) {
  var result = []
  while(left.length && right.length) {
    if(left[0] <= right[0]) {
      result.push(left.shift())
    } else {
      result.push(right.shift())
    }
  }
  while(left.length) {
    result.push(left.shift())
  }
  while(right.length) {
    result.push(right.shift())
  }
  return result
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#快速排序)快速排序

> 选择一个元素作为基数，把比基数小的元素放在它左边，比它大的放在右边（相当于二分），再不断递归基数左右的序列。快速排序是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上递归分治法。快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，它是处理大数据最快的排序算法之一。

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#实现一)实现一

```js
function quickSort(list) {
  var n = list.length
  if(n <= 1) return list
  
  var pivotIndex = Math.floor(n / 2)
  var pivot = list[pivotIndex]
  var left = []
  var right = []
  
  for(var i = 0; i < n; i++) {
    if(i === pivotIndex) continue
    if(list[i] < pivot) {
      left.push(list[i])
    } else {
      right.push(list[i])
    }
  }
  
  return quickSort(left).concat(quickSort(right))
}
```

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#实现二)实现二

```js
function quickSort(list, left = 0, right = list.length - 1) {
  var n = list.length
	if(left < right) {
    var index = left - 1
    for(var i = left; i <= right; i++) {
      if(list[i] <= list[right]) {
        index++
        var temp = list[index]
        list[index] = list[i]
        list[i] = temp
      }
    }
    quickSort(list, left, index - 1)
    quickSort(list, index + 1, right)
  }
  
  return list
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#堆排序)堆排序

> 说到堆排序，首先需要了解一种数据结构--堆。堆是一种完全二叉树，这种结构通常可以用数组表示。在实际应用中，堆又可以分为最小堆和最大堆，两者区别如下：
>
> - -max-heap property：对于所有除了根节点的节点i，A[Parent(i)] >= A[i]
> - -min-heap property：对于除了根节点的节点i，A[Parent(i)] <= A[i]
>
> 堆排序可以说是一种利用堆的概念来排序的选择排序，分为两种方法：
>
> - 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排序；
> - 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排序。

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#实现-4)实现

```js
function heapSort(list) {
  buildHeap(list) 
  // 循环 n-1 次，每次循环后交换堆顶元素和堆底元素并重新调整堆结构
  for(var i = list.length - 1; i > 0; i--) {
    [nums[i], nums[0]] = [nums[0], nums[i]]
    adjustHeap(nums, 0, i)
  }
  return list
}

function buildHeap(nums) {
  // 注意这里的头节点是从0开始的，所以最后一个非叶子节点结果是 parseInt(nums.length / 2) - 1
  var start = parseInt(nums.length / 2) - 1
  var size = nums.length
  // 从最后一个非叶子节点开始调整，直至堆顶
  for(var i = start; i >= 0; i--) {
    adjustHeap(nums, i, size)
  }
}

function adjustHeap(nums, index, size) {
  // 交换后可能会破坏堆结构，需要循环使得每一个父节点都大于左右节点
  while(true) {
    var max = index
    var left = index * 2 + 1 // 左节点
    var right = index * 2 + 2 // 右节点
    if(left < size && nums[max] < nums[left]) max = left
    if(right < size && nums[max] < nums[right]) max = right
    // 如果左右节点大雨当前节点则交换，并在循环一遍判断交换后是否破坏堆结构
    if(index !== max) {
      [nums[index], nums[max]] = [nums[max], nums[index]]
      index = max
    } else {
      break
    }
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#计数排序)计数排序

> 以数组元素值为键，出现次数为值存进一个临时数组，最后再遍历这个临时数组还原回原数组。因为 JS 的数组下标是以字符串形式存储的，所以计数排序可以用来排列负数，但是不可以排列小数。

### [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#实现-5)实现

```js
function countingSort(nums) {
  var list = []
  var max = Math.max(...nums)
  var min = Math.min(...nums)
  
  for(var i = 0; i < nums.length; i++) {
    var temp = nums[i]
    list[temp] = list[temp] + 1 || 1
  }
  
  var index = 0
  for(var i = min; i <= max; i++) {
    while(list[i] > 0) {
      nums[index++] = i
      list[i]--
    }
  }
  
  return list
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#桶排序)桶排序

> 取 n 个桶，根据数组的最大值和最小值确认每个桶存放的数的区间，将元素插入到相应的桶里，最后再合并各个桶。
>
> 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 为了使桶排序更加高效，我们需要做到这两点：
>
> - 在额外空间充足的情况下，尽量增大桶的数量。
> - 使用的映射函数能够将输入的N个数据均匀的分配到K个桶中。

```js
function bucketSort(nums) {
  // 桶的个数，只要是正数都行
  var num = 5
  var max = Math.max(...nums)
  var min = Math.min(...nums)
  // 计算每个桶存放的数值范围，至少为 1
  var range = Math.ceil((max - min) / num) || 1
  // 创建二维数组，第一维表示第几个桶，第二维表示桶里放的数
	var arr = Array.from(Array(num)).map(() => Array().fill(0))
  nums.forEach(val => {
  	// 计算元素应该分布在哪个桶
   	let index = parseInt((val - min) / range);
    // 防止index越界，例如当[5,1,1,2,0,0]时index会出现5
    index = index >= num ? num - 1 : index;
    let temp = arr[index];
    // 插入排序，将元素有序插入到桶中
    let j = temp.length - 1;
    while (j >= 0 && val < temp[j]) {
    	temp[j + 1] = temp[j];
      j--;
    }
    temp[j + 1] = val;
	});
  // 修改回原数组
  var res = [].concat.apply([], arr);
  nums.forEach((val, i) => {
  	nums[i] = res[i];
  });
  return nums;
}
```

## [#](http://interview.poetries.top/excellent-docs/17-排序算法.html#基数排序)基数排序

> 使用十个桶 0-9，把每个数从低位到高位根据位数放到相应的桶里，以此循环最大值的位数次。但只能排列正整数，因为遇到负号和小数点无法进行比较。
>
> 基数排序有两种方法：
>
> - MSD 从高位开始进行排序
> - LSD 从低位开始进行排序
>
> 基数排序 vs 计数排序 vs 桶排序：
>
> 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
>
> - 基数排序：根据键值的每位数字来分配桶
> - 计数排序：每个桶只存储单一键值
> - 桶排序：每个桶存储一定范围的数值

```js
function radixSort(nums) {
  // 计算位数
  function getDigits(n) {
  	var sum = 0;
    while (n) {
    	sum++;
      n = parseInt(n / 10);
    }
    return sum;
  }
  // 第一维表示位数即0-9，第二维表示里面存放的值
  var arr = Array.from(Array(10)).map(() => Array());
  var max = Math.max(...nums);
  var maxDigits = getDigits(max);
  for (var i = 0, len = nums.length; i < len; i++) {
  	// 用0把每一个数都填充成相同的位数
    nums[i] = (nums[i] + '').padStart(maxDigits, 0);
    // 先根据个位数把每一个数放到相应的桶里
    var temp = nums[i][nums[i].length - 1];
    arr[temp].push(nums[i]);
  }
  // 循环判断每个位数
  for (var i = maxDigits - 2; i >= 0; i--) {
  	// 循环每一个桶
    for (var j = 0; j <= 9; j++) {
    	var temp = arr[j]
      var len = temp.length;
      // 根据当前的位数i把桶里的数放到相应的桶里
      	while (len--) {
          var str = temp[0];
          temp.shift();
          arr[str[i]].push(str);
       	}
      }
    }
    // 修改回原数组
    var res = [].concat.apply([], arr);
    nums.forEach((val, index) => {
    	nums[index] = +res[index];
    });
    return nums;
}
```



# 18  计算机通识

# 计算机基础

## [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#一、网络)一、网络

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_1-udp)1 UDP

**1.1 面向报文**

> `UDP` 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 `UDP` 只是报文的搬运工，不会对报文进行任何拆分和拼接操作

具体来说

- 在发送端，应用层将数据传递给传输层的 `UDP` 协议，`UDP` 只会给数据增加一个 `UDP` 头标识下是 `UDP` 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，`UDP` 只去除 `IP` 报文头就传递给应用层，不会任何拼接操作

**1.2 不可靠性**

- `UDP` 是无连接的，也就是说通信不需要建立和断开连接。
- `UDP` 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的
- `UDP` 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 `TCP`

**1.3 高效**

- 因为 `UDP` 没有 `TCP` 那么复杂，需要保证数据不丢失且有序到达。所以 `UDP` 的头部开销小，只有八字节，相比 `TCP` 的至少二十字节要少得多，在传输数据报文时是很高效的

![img](https://poetries1.gitee.io/img-repo/2020/09/226.png)

**头部包含了以下几个数据**

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度
- 整个数据报文的检验和（`IPv4` 可选 字段），该字段用于发现头部信息和数据中的错误

**1.4 传输方式**

> `UDP` 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_2-tcp)2 TCP

**2.1 头部**

> `TCP` 头部比 `UDP` 头部复杂的多

![img](https://poetries1.gitee.io/img-repo/2020/09/227.png)

> 对于 `TCP` 头部来说，以下几个字段是很重要的

- `Sequence number`，这个序号保证了 `TCP` 传输的报文都是有序的，对端可以通过序号顺序的拼接报文
- `Acknowledgement Number`，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
- `Window Size`，窗口大小，表示还能接收多少字节的数据，用于流量控制

**标识符**

- `URG=1`：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
- `ACK=1`：该字段为一表示确认号字段有效。此外，`TCP` 还规定在连接建立后传送的所有报文段都必须把 `ACK` 置为一 `PSH=1`：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
- `RST=1`：该字段为一表示当前 `TCP` 连接出现严重问题，可能需要重新建立 `TCP` 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
- `SYN=1`：当`SYN=1`，`ACK=0`时，表示当前报文段是一个连接请求报文。当`SYN=1`，`ACK=1`时，表示当前报文段是一个同意建立连接的应答报文。
- `FIN=1`：该字段为一表示此报文段是一个释放连接的请求报文

**2.2 状态机**

> `HTTP` 是无连接的，所以作为下层的 `TCP` 协议也是无连接的，虽然看似 `TCP` 将两端连接了起来，但是其实只是两端共同维护了一个状态

![img](https://poetries1.gitee.io/img-repo/2020/09/228.png)

- `TCP` 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。
- 在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间

**建立连接三次握手**

![img](https://poetries1.gitee.io/img-repo/2020/09/229.png)

- 在 `TCP` 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，`TCP`连接建立完后都能发送和接收数据，所以 `TCP` 也是一个全双工的协议。
- 起初，两端都为 `CLOSED` 状态。在通信开始前，双方都会创建 `TCB`。 服务器创建完 `TCB` 后遍进入 `LISTEN` 状态，此时开始等待客户端发送数据

**第一次握手**

> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。

**第二次握手**

> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 `SYN-RECEIVED` 状态。

**第三次握手**

> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入`ESTABLISHED` 状态，服务端收到这个应答后也进入 `ESTABLISHED`状态，此时连接建立成功。

- PS：第三次握手可以包含数据，通过 `TCP` 快速打开（`TFO`）技术。其实只要涉及到握手的协议，都可以使用类似 `TFO` 的方式，客户端和服务端存储相同 `cookie`，下次握手时发出 `cookie`达到减少 `RTT` 的目的

**你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？**

- 因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误

> 可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 `ESTABLISHED` 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费

> PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求

**断开链接四次握手**

![img](https://poetries1.gitee.io/img-repo/2020/09/230.png)

> `TCP` 是全双工的，在断开连接时两端都需要发送 `FIN` 和 `ACK`。

**第一次握手**

> 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

**第二次握手**

> B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。

**第三次握手**

> B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

> PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。

**第四次握手**

- A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

> 为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？

- 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_3-http)3 HTTP

> `HTTP` 协议是个无状态协议，不会保存状态

**3.1 Post 和 Get 的区别**

- `Get`请求能缓存，`Post` 不能
- `Post` 相对 `Get`安全一点点，因为`Get` 请求都包含在 `URL` 里，且会被浏览器保存历史纪录，`Post` 不会，但是在抓包的情况下都是一样的。
- `Post` 可以通过 `request body`来传输比 `Get` 更多的数据，`Get`没有这个技术
- `URL`有长度限制，会影响 `Get`请求，但是这个长度限制是浏览器规定的，不是 `RFC` 规定的
- `Post` 支持更多的编码类型且不对数据类型限制

**3.2 常见状态码**

**2XX 成功**

- `200 OK`，表示从客户端发来的请求在服务器端被正确处理
- `204 No content`，表示请求成功，但响应报文不含实体的主体部分
- `205 Reset Content`，表示请求成功，但响应报文不含实体的主体部分，但是与 `204` 响应不同在于要求请求方重置内容
- `206 Partial Content`，进行范围请求

**3XX 重定向**

- `301 moved permanently`，永久性重定向，表示资源已被分配了新的 URL
- `302 found`，临时性重定向，表示资源临时被分配了新的 URL
- `303 see other`，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源
- `304 not modified`，表示服务器允许访问资源，但因发生请求未满足条件的情况
- `307 temporary redirect`，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

**4XX 客户端错误**

- `400 bad request`，请求报文存在语法错误
- `401 unauthorized`，表示发送的请求需要有通过 `HTTP`认证的认证信息
- `403 forbidden`，表示对请求资源的访问被服务器拒绝
- `404 not found`，表示在服务器上没有找到请求的资源

**5XX 服务器错误**

- `500 internal sever error`，表示服务器端在执行请求时发生了错误
- `501 Not Implemented`，表示服务器不支持当前请求所需要的某个功能
- `503 service unavailable`，表明服务器暂时处于超负载或正在停机维护，无法处理请求

**3.3 HTTP 首部**

| 通用字段            | 作用                                            |
| ------------------- | ----------------------------------------------- |
| `Cache-Control`     | 控制缓存的行为                                  |
| `Connection`        | 浏览器想要优先使用的连接类型，比如 `keep-alive` |
| `Date`              | 创建报文时间                                    |
| `Pragma`            | 报文指令                                        |
| `Via`               | 代理服务器相关信息                              |
| `Transfer-Encoding` | 传输编码方式                                    |
| `Upgrade`           | 要求客户端升级协议                              |
| `Warning`           | 在内容中可能存在错误                            |

| 请求字段              | 作用                               |
| --------------------- | ---------------------------------- |
| `Accept`              | 能正确接收的媒体类型               |
| `Accept-Charset`      | 能正确接收的字符集                 |
| `Accept-Encoding`     | 能正确接收的编码格式列表           |
| `Accept-Language`     | 能正确接收的语言列表               |
| `Expect`              | 期待服务端的指定行为               |
| `From`                | 请求方邮箱地址                     |
| `Host`                | 服务器的域名                       |
| `If-Match`            | 两端资源标记比较                   |
| `If-Modified-Since`   | 本地资源未修改返回 304（比较时间） |
| `If-None-Match`       | 本地资源未修改返回 304（比较标记） |
| `User-Agent`          | 客户端信息                         |
| `Max-Forwards`        | 限制可被代理及网关转发的次数       |
| `Proxy-Authorization` | 向代理服务器发送验证信息           |
| `Range`               | 请求某个内容的一部分               |
| `Referer`             | 表示浏览器所访问的前一个页面       |
| `TE`                  | 传输编码方式                       |

| 响应字段             | 作用                       |
| -------------------- | -------------------------- |
| `Accept-Ranges`      | 是否支持某些种类的范围     |
| `Age`                | 资源在代理缓存中存在的时间 |
| `ETag`               | 资源标识                   |
| `Location`           | 客户端重定向到某个 `URL`   |
| `Proxy-Authenticate` | 向代理服务器发送验证信息   |
| `Server`             | 服务器名字                 |
| `WWW-Authenticate`   | 获取资源需要的验证信息     |

| 实体字段           | 作用                              |
| ------------------ | --------------------------------- |
| `Allow`            | 资源的正确请求方式                |
| `Content-Encoding` | 内容的编码格式                    |
| `Content-Language` | 内容使用的语言                    |
| `Content-Length`   | `request body` 长度               |
| `Content-Location` | 返回数据的备用地址                |
| `Content-MD5`      | `Base64`加密格式的内容`MD5`检验值 |
| `Content-Range`    | 内容的位置范围                    |
| `Content-Type`     | 内容的媒体类型                    |
| `Expires`          | 内容的过期时间                    |
| `Last_modified`    | 内容的最后修改时间                |

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_4-dns)4 DNS

> DNS 的作用就是通过域名查询到具体的 IP。

- 因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么

> 在 `TCP` 握手之前就已经进行了 `DNS` 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 `www.google.com` 时，会进行一下操作

- 操作系统会首先在本地缓存中查询
- 没有的话会去系统配置的 DNS 服务器中查询
- 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
- 然后去该服务器查询 google 这个二级域名
- 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP

> 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。

## [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#二、数据结构)二、数据结构

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_2-1-栈)2.1 栈

**概念**

- 栈是一个线性结构，在计算机中是一个相当常见的数据结构。
- 栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则

![img](https://poetries1.gitee.io/img-repo/2020/09/231.png)

**实现**

> 每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现

```js
class Stack {
  constructor() {
    this.stack = []
  }
  push(item) {
    this.stack.push(item)
  }
  pop() {
    this.stack.pop()
  }
  peek() {
    return this.stack[this.getCount() - 1]
  }
  getCount() {
    return this.stack.length
  }
  isEmpty() {
    return this.getCount() === 0
  }
}
```

**应用**

> 匹配括号，可以通过栈的特性来完成

```js
var isValid = function (s) {
  let map = {
    '(': -1,
    ')': 1,
    '[': -2,
    ']': 2,
    '{': -3,
    '}': 3
  }
  let stack = []
  for (let i = 0; i < s.length; i++) {
    if (map[s[i]] < 0) {
      stack.push(s[i])
    } else {
      let last = stack.pop()
      if (map[last] + map[s[i]] != 0) return false
    }
  }
  if (stack.length > 0) return false
  return true
};
```

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_2-2-队列)2.2 队列

**概念**

> 队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则

![img](https://poetries1.gitee.io/img-repo/2020/09/232.png)

**实现**

> 这里会讲解两种实现队列的方式，分别是单链队列和循环队列

- **单链队列**

```js
class Queue {
  constructor() {
    this.queue = []
  }
  enQueue(item) {
    this.queue.push(item)
  }
  deQueue() {
    return this.queue.shift()
  }
  getHeader() {
    return this.queue[0]
  }
  getLength() {
    return this.queue.length
  }
  isEmpty() {
    return this.getLength() === 0
  }
}
```

> 因为单链队列在出队操作的时候需要 `O(n)` 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 `O(1)` 的时间复杂度

- **循环队列**

```js
class SqQueue {
  constructor(length) {
    this.queue = new Array(length + 1)
    // 队头
    this.first = 0
    // 队尾
    this.last = 0
    // 当前队列大小
    this.size = 0
  }
  enQueue(item) {
    // 判断队尾 + 1 是否为队头
    // 如果是就代表需要扩容数组
    // % this.queue.length 是为了防止数组越界
    if (this.first === (this.last + 1) % this.queue.length) {
      this.resize(this.getLength() * 2 + 1)
    }
    this.queue[this.last] = item
    this.size++
    this.last = (this.last + 1) % this.queue.length
  }
  deQueue() {
    if (this.isEmpty()) {
      throw Error('Queue is empty')
    }
    let r = this.queue[this.first]
    this.queue[this.first] = null
    this.first = (this.first + 1) % this.queue.length
    this.size--
    // 判断当前队列大小是否过小
    // 为了保证不浪费空间，在队列空间等于总长度四分之一时
    // 且不为 2 时缩小总长度为当前的一半
    if (this.size === this.getLength() / 4 && this.getLength() / 2 !== 0) {
      this.resize(this.getLength() / 2)
    }
    return r
  }
  getHeader() {
    if (this.isEmpty()) {
      throw Error('Queue is empty')
    }
    return this.queue[this.first]
  }
  getLength() {
    return this.queue.length - 1
  }
  isEmpty() {
    return this.first === this.last
  }
  resize(length) {
    let q = new Array(length)
    for (let i = 0; i < length; i++) {
      q[i] = this.queue[(i + this.first) % this.queue.length]
    }
    this.queue = q
    this.first = 0
    this.last = this.size
  }
}
```

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_2-3-链表)2.3 链表

**概念**

> 链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大

![img](https://poetries1.gitee.io/img-repo/2020/09/233.png)

**实现**

- **单向链表**

```js
class Node {
  constructor(v, next) {
    this.value = v
    this.next = next
  }
}
class LinkList {
  constructor() {
    // 链表长度
    this.size = 0
    // 虚拟头部
    this.dummyNode = new Node(null, null)
  }
  find(header, index, currentIndex) {
    if (index === currentIndex) return header
    return this.find(header.next, index, currentIndex + 1)
  }
  addNode(v, index) {
    this.checkIndex(index)
    // 当往链表末尾插入时，prev.next 为空
    // 其他情况时，因为要插入节点，所以插入的节点
    // 的 next 应该是 prev.next
    // 然后设置 prev.next 为插入的节点
    let prev = this.find(this.dummyNode, index, 0)
    prev.next = new Node(v, prev.next)
    this.size++
    return prev.next
  }
  insertNode(v, index) {
    return this.addNode(v, index)
  }
  addToFirst(v) {
    return this.addNode(v, 0)
  }
  addToLast(v) {
    return this.addNode(v, this.size)
  }
  removeNode(index, isLast) {
    this.checkIndex(index)
    index = isLast ? index - 1 : index
    let prev = this.find(this.dummyNode, index, 0)
    let node = prev.next
    prev.next = node.next
    node.next = null
    this.size--
    return node
  }
  removeFirstNode() {
    return this.removeNode(0)
  }
  removeLastNode() {
    return this.removeNode(this.size, true)
  }
  checkIndex(index) {
    if (index < 0 || index > this.size) throw Error('Index error')
  }
  getNode(index) {
    this.checkIndex(index)
    if (this.isEmpty()) return
    return this.find(this.dummyNode, index, 0).next
  }
  isEmpty() {
    return this.size === 0
  }
  getSize() {
    return this.size
  }
}
```

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_2-4-树)2.4 树

**二叉树**

- 树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。
- 二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树

![img](https://poetries1.gitee.io/img-repo/2020/09/234.png)

**二分搜索树**

- 二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小
- 这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率

![img](https://poetries1.gitee.io/img-repo/2020/09/235.png)

- **实现**

```text
class Node {
  constructor(value) {
    this.value = value
    this.left = null
    this.right = null
  }
}
class BST {
  constructor() {
    this.root = null
    this.size = 0
  }
  getSize() {
    return this.size
  }
  isEmpty() {
    return this.size === 0
  }
  addNode(v) {
    this.root = this._addChild(this.root, v)
  }
  // 添加节点时，需要比较添加的节点值和当前
  // 节点值的大小
  _addChild(node, v) {
    if (!node) {
      this.size++
      return new Node(v)
    }
    if (node.value > v) {
      node.left = this._addChild(node.left, v)
    } else if (node.value < v) {
      node.right = this._addChild(node.right, v)
    }
    return node
  }
}
```

- 以上是最基本的二分搜索树实现，接下来实现树的遍历。

> 对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可

```js
// 先序遍历可用于打印树的结构
// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。
preTraversal() {
  this._pre(this.root)
}
_pre(node) {
  if (node) {
    console.log(node.value)
    this._pre(node.left)
    this._pre(node.right)
  }
}
// 中序遍历可用于排序
// 对于 BST 来说，中序遍历可以实现一次遍历就
// 得到有序的值
// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。
midTraversal() {
  this._mid(this.root)
}
_mid(node) {
  if (node) {
    this._mid(node.left)
    console.log(node.value)
    this._mid(node.right)
  }
}
// 后序遍历可用于先操作子节点
// 再操作父节点的场景
// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。
backTraversal() {
  this._back(this.root)
}
_back(node) {
  if (node) {
    this._back(node.left)
    this._back(node.right)
    console.log(node.value)
  }
}
```

> 以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成

```js
breadthTraversal() {
  if (!this.root) return null
  let q = new Queue()
  // 将根节点入队
  q.enQueue(this.root)
  // 循环判断队列是否为空，为空
  // 代表树遍历完毕
  while (!q.isEmpty()) {
    // 将队首出队，判断是否有左右子树
    // 有的话，就先左后右入队
    let n = q.deQueue()
    console.log(n.value)
    if (n.left) q.enQueue(n.left)
    if (n.right) q.enQueue(n.right)
  }
}
```

> 接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反

```js
getMin() {
  return this._getMin(this.root).value
}
_getMin(node) {
  if (!node.left) return node
  return this._getMin(node.left)
}
getMax() {
  return this._getMax(this.root).value
}
_getMax(node) {
  if (!node.right) return node
  return this._getMin(node.right)
}
```

> 向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断

```js
floor(v) {
  let node = this._floor(this.root, v)
  return node ? node.value : null
}
_floor(node, v) {
  if (!node) return null
  if (node.value === v) return v
  // 如果当前节点值还比需要的值大，就继续递归
  if (node.value > v) {
    return this._floor(node.left, v)
  }
  // 判断当前节点是否拥有右子树
  let right = this._floor(node.right, v)
  if (right) return right
  return node
}
```

> 排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身）

```js
class Node {
  constructor(value) {
    this.value = value
    this.left = null
    this.right = null
    // 修改代码
    this.size = 1
  }
}
// 新增代码
_getSize(node) {
  return node ? node.size : 0
}
_addChild(node, v) {
  if (!node) {
    return new Node(v)
  }
  if (node.value > v) {
    // 修改代码
    node.size++
    node.left = this._addChild(node.left, v)
  } else if (node.value < v) {
    // 修改代码
    node.size++
    node.right = this._addChild(node.right, v)
  }
  return node
}
select(k) {
  let node = this._select(this.root, k)
  return node ? node.value : null
}
_select(node, k) {
  if (!node) return null
  // 先获取左子树下有几个节点
  let size = node.left ? node.left.size : 0
  // 判断 size 是否大于 k
  // 如果大于 k，代表所需要的节点在左节点
  if (size > k) return this._select(node.left, k)
  // 如果小于 k，代表所需要的节点在右节点
  // 注意这里需要重新计算 k，减去根节点除了右子树的节点数量
  if (size < k) return this._select(node.right, k - size - 1)
  return node
}
```

> 接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况

- 需要删除的节点没有子树
- 需要删除的节点只有一条子树
- 需要删除的节点有左右两条树
- 对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述

```js
delectMin() {
  this.root = this._delectMin(this.root)
  console.log(this.root)
}
_delectMin(node) {
  // 一直递归左子树
  // 如果左子树为空，就判断节点是否拥有右子树
  // 有右子树的话就把需要删除的节点替换为右子树
  if ((node != null) & !node.left) return node.right
  node.left = this._delectMin(node.left)
  // 最后需要重新维护下节点的 `size`
  node.size = this._getSize(node.left) + this._getSize(node.right) + 1
  return node
}
```

- 最后讲解的就是如何删除任意节点了。对于这个操作，`T.Hibbard` 在 `1962`年提出了解决这个难题的办法，也就是如何解决第三种情况。
- 当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。
- 你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点

```js
delect(v) {
  this.root = this._delect(this.root, v)
}
_delect(node, v) {
  if (!node) return null
  // 寻找的节点比当前节点小，去左子树找
  if (node.value < v) {
    node.right = this._delect(node.right, v)
  } else if (node.value > v) {
    // 寻找的节点比当前节点大，去右子树找
    node.left = this._delect(node.left, v)
  } else {
    // 进入这个条件说明已经找到节点
    // 先判断节点是否拥有拥有左右子树中的一个
    // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样
    if (!node.left) return node.right
    if (!node.right) return node.left
    // 进入这里，代表节点拥有左右子树
    // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值
    let min = this._getMin(node.right)
    // 取出最小值后，删除最小值
    // 然后把删除节点后的子树赋值给最小值节点
    min.right = this._delectMin(node.right)
    // 左子树不动
    min.left = node.left
    node = min
  }
  // 维护 size
  node.size = this._getSize(node.left) + this._getSize(node.right) + 1
  return node
}
```

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_2-5-堆)2.5 堆

**概念**

- 堆通常是一个可以被看做一棵树的数组对象。
- 堆的实现通过构造二叉堆，实为二叉树的一种。这种数据结构具有以下性质。
- 任意节点小于（或大于）它的所有子节点 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。
- 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
- 优先队列也完全可以用堆来实现，操作是一模一样的。

**实现大根堆**

> 堆的每个节点的左边子节点索引是 `i * 2 + 1`，右边是 `i * 2 + 2`，父节点是 `(i - 1) /2`。

- 堆有两个核心的操作，分别是 `shiftUp` 和 `shiftDown` 。前者用于添加元素，后者用于删除根节点。
- `shiftUp` 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。
- `shiftDown` 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换

![img](https://poetries1.gitee.io/img-repo/2020/09/236.png)

```js
class MaxHeap {
  constructor() {
    this.heap = []
  }
  size() {
    return this.heap.length
  }
  empty() {
    return this.size() == 0
  }
  add(item) {
    this.heap.push(item)
    this._shiftUp(this.size() - 1)
  }
  removeMax() {
    this._shiftDown(0)
  }
  getParentIndex(k) {
    return parseInt((k - 1) / 2)
  }
  getLeftIndex(k) {
    return k * 2 + 1
  }
  _shiftUp(k) {
    // 如果当前节点比父节点大，就交换
    while (this.heap[k] > this.heap[this.getParentIndex(k)]) {
      this._swap(k, this.getParentIndex(k))
      // 将索引变成父节点
      k = this.getParentIndex(k)
    }
  }
  _shiftDown(k) {
    // 交换首位并删除末尾
    this._swap(k, this.size() - 1)
    this.heap.splice(this.size() - 1, 1)
    // 判断节点是否有左孩子，因为二叉堆的特性，有右必有左
    while (this.getLeftIndex(k) < this.size()) {
      let j = this.getLeftIndex(k)
      // 判断是否有右孩子，并且右孩子是否大于左孩子
      if (j + 1 < this.size() && this.heap[j + 1] > this.heap[j]) j++
      // 判断父节点是否已经比子节点都大
      if (this.heap[k] >= this.heap[j]) break
      this._swap(k, j)
      k = j
    }
  }
  _swap(left, right) {
    let rightValue = this.heap[right]
    this.heap[right] = this.heap[left]
    this.heap[left] = rightValue
  }
}
```

## [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#三、算法)三、算法

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_3-1-时间复杂度)3.1 时间复杂度

- 通常使用最差的时间复杂度来衡量一个算法的好坏。
- 常数时间 `O(1)` 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。
- 对于一个算法来说，可能会计算出如下操作次数 `aN +`1，`N` 代表数据量。那么该算法的时间复杂度就是 `O(N)`。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。
- 当然可能会出现两个算法都是 `O(N)` 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_3-2-位运算)3.2 位运算

- 位运算在算法中很有用，速度可以比四则运算快很多。
- 在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式
- 十进制 `33` 可以看成是 `32 + 1` ，并且 `33` 应该是六位二进制的（因为 `33`近似 `32`，而 `32` 是 `2`的五次方，所以是六位），那么 十进制 `33` 就是 `100001` ，只要是 2 的次方，那么就是 `1`否则都为 `0` 那么二进制 `100001` 同理，首位是 `2^5`，末位是 `2^0` ，相加得出 `33`

**左移 <<**

```text
10 << 1 // -> 20
```

> 左移就是将二进制全部往左移动，`10`在二进制中表示为 `1010` ，左移一位后变成 `10100` ，转换为十进制也就是 `20`，所以基本可以把左移看成以下公式 `a * (2 ^ b)`

**算数右移 >>**

```text
10 >> 1 // -> 5
```

- 算数右移就是将二进制全部往右移动并去除多余的右边，10 在二进制中表示为 `1010` ，右移一位后变成 `101` ，转换为十进制也就是 `5`，所以基本可以把右移看成以下公式 `int v = a / (2 ^ b)`
- 右移很好用，比如可以用在二分算法中取中间值

```text
13 >> 1 // -> 6
```

**按位操作**

- **按位与**

> 每一位都为 1，结果才为 1

```text
8 & 7 // -> 0
// 1000 & 0111 -> 0000 -> 0
```

- **按位或**

> 其中一位为 1，结果就是 1

```text
8 | 7 // -> 15
// 1000 | 0111 -> 1111 -> 15
```

- **按位异或**

> 每一位都不同，结果才为 1

```text
8 ^ 7 // -> 15
8 ^ 8 // -> 0
// 1000 ^ 0111 -> 1111 -> 15
// 1000 ^ 1000 -> 0000 -> 0
```

**面试题：两个数不使用四则运算得出和**

> 这道题中可以按位异或，因为按位异或就是不进位加法，`8 ^ 8 = 0` 如果进位了，就是 `16` 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 `1`，所以可以得出以下公式 `a + b = (a ^ b) + ((a & b) << 1)` ，然后通过迭代的方式模拟加法

```js
function sum(a, b) {
    if (a == 0) return b
    if (b == 0) return a
    let newA = a ^ b
    let newB = (a & b) << 1
    return sum(newA, newB)
}
```

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_3-3-排序)3.3 排序

**冒泡排序**

> 冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 `length - 1` 的位置

![img](https://poetries1.gitee.io/img-repo/2020/09/237.png)

> 以下是实现该算法的代码

```js
function bubble(array) {
  checkArray(array);
  for (let i = array.length - 1; i > 0; i--) {
    // 从 0 到 `length - 1` 遍历
    for (let j = 0; j < i; j++) {
      if (array[j] > array[j + 1]) swap(array, j, j + 1)
    }
  }
  return array;
}
```

> 该算法的操作次数是一个等差数列 `n + (n - 1) + (n - 2) + 1` ，去掉常数项以后得出时间复杂度是`O(n * n)`

**插入排序**

> 入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作

![img](https://poetries1.gitee.io/img-repo/2020/09/238.png)

以下是实现该算法的代码

```js
function insertion(array) {
  checkArray(array);
  for (let i = 1; i < array.length; i++) {
    for (let j = i - 1; j >= 0 && array[j] > array[j + 1]; j--)
      swap(array, j, j + 1);
  }
  return array;
}
```

> 该算法的操作次数是一个等差数列 `n + (n - 1) + (n - 2) + 1` ，去掉常数项以后得出时间复杂度是 `O(n * n)`

**选择排序**

> 选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作

![img](https://user-gold-cdn.xitu.io/2018/4/13/162bc8ea14567e2e?w=670&h=508&f=gif&s=965636)

以下是实现该算法的代码

```js
function selection(array) {
  checkArray(array);
  for (let i = 0; i < array.length - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < array.length; j++) {
      minIndex = array[j] < array[minIndex] ? j : minIndex;
    }
    swap(array, i, minIndex);
  }
  return array;
}
```

> 该算法的操作次数是一个等差数列 `n + (n - 1) + (n - 2) + 1` ，去掉常数项以后得出时间复杂度是 `O(n * n)`

**归并排序**

> 归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 `[3, 1, 2, 8, 9, 7, 6]`，中间数索引是 3，先排序数组 `[3, 1, 2, 8]` 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 `[3, 1]` 和 `[2, 8]` ，然后再排序数组 `[1, 3, 2, 8]` ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 `[1, 2, 3, 8]` 和 `[6, 7, 9]` 排序

![img](https://user-gold-cdn.xitu.io/2018/4/13/162be13c7e30bd86?w=896&h=1008&f=gif&s=937952)

以下是实现该算法的代码

```js
function sort(array) {
  checkArray(array);
  mergeSort(array, 0, array.length - 1);
  return array;
}

function mergeSort(array, left, right) {
  // 左右索引相同说明已经只有一个数
  if (left === right) return;
  // 等同于 `left + (right - left) / 2`
  // 相比 `(left + right) / 2` 来说更加安全，不会溢出
  // 使用位运算是因为位运算比四则运算快
  let mid = parseInt(left + ((right - left) >> 1));
  mergeSort(array, left, mid);
  mergeSort(array, mid + 1, right);

  let help = [];
  let i = 0;
  let p1 = left;
  let p2 = mid + 1;
  while (p1 <= mid && p2 <= right) {
    help[i++] = array[p1] < array[p2] ? array[p1++] : array[p2++];
  }
  while (p1 <= mid) {
    help[i++] = array[p1++];
  }
  while (p2 <= right) {
    help[i++] = array[p2++];
  }
  for (let i = 0; i < help.length; i++) {
    array[left + i] = help[i];
  }
  return array;
}
```

> 以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下

```js
mergeSort(data, 0, 6) // mid = 3
  mergeSort(data, 0, 3) // mid = 1
    mergeSort(data, 0, 1) // mid = 0
      mergeSort(data, 0, 0) // 遇到终止，回退到上一步
    mergeSort(data, 1, 1) // 遇到终止，回退到上一步
    // 排序 p1 = 0, p2 = mid + 1 = 1
    // 回退到 `mergeSort(data, 0, 3)` 执行下一个递归
  mergeSort(2, 3) // mid = 2
    mergeSort(3, 3) // 遇到终止，回退到上一步
  // 排序 p1 = 2, p2 = mid + 1 = 3
  // 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑
  // 排序 p1 = 0, p2 = mid + 1 = 2
  // 执行完毕回退
  // 左边数组排序完毕，右边也是如上轨迹
```

> 该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 `2T(N / 2) + T(N)` （`T` 代表时间，`N` 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 `O(N * logN)`

**快排**

> 快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。

![img](https://user-gold-cdn.xitu.io/2018/4/16/162cd23e69ca9ea3?w=824&h=506&f=gif&s=867744)

以下是实现该算法的代码

```js
function sort(array) {
  checkArray(array);
  quickSort(array, 0, array.length - 1);
  return array;
}

function quickSort(array, left, right) {
  if (left < right) {
    swap(array, , right)
    // 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低
    let indexs = part(array, parseInt(Math.random() * (right - left + 1)) + left, right);
    quickSort(array, left, indexs[0]);
    quickSort(array, indexs[1] + 1, right);
  }
}
function part(array, left, right) {
  let less = left - 1;
  let more = right;
  while (left < more) {
    if (array[left] < array[right]) {
      // 当前值比基准值小，`less` 和 `left` 都加一
	   ++less;
       ++left;
    } else if (array[left] > array[right]) {
      // 当前值比基准值大，将当前值和右边的值交换
      // 并且不改变 `left`，因为当前换过来的值还没有判断过大小
      swap(array, --more, left);
    } else {
      // 和基准值相同，只移动下标
      left++;
    }
  }
  // 将基准值和比基准值大的第一个值交换位置
  // 这样数组就变成 `[比基准值小, 基准值, 比基准值大]`
  swap(array, right, more);
  return [less, more];
}
```

> 该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 `O(logN)`，并且相比归并排序来说，所需的常数时间也更少

**面试题**

> Sort Colors：该题目来自 LeetCode，题目需要我们将 `[2,0,2,1,1,0]` 排序成 `[0,0,1,1,2,2]`，这个问题就可以使用三路快排的思想

```js
var sortColors = function(nums) {
  let left = -1;
  let right = nums.length;
  let i = 0;
  // 下标如果遇到 right，说明已经排序完成
  while (i < right) {
    if (nums[i] == 0) {
      swap(nums, i++, ++left);
    } else if (nums[i] == 1) {
      i++;
    } else {
      swap(nums, i, --right);
    }
  }
};
```

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_3-4-链表)3.4 链表

**反转单向链表**

> 该题目来自 LeetCode，题目需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题

```js
var reverseList = function(head) {
    // 判断下变量边界问题
    if (!head || !head.next) return head
    // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null
    let pre = null
    let current = head
    let next
    // 判断当前节点是否为空
    // 不为空就先获取当前节点的下一节点
    // 然后把当前节点的 next 设为上一个节点
    // 然后把 current 设为下一个节点，pre 设为当前节点
    while(current) {
        next = current.next
        current.next = pre
        pre = current
        current = next
    }
    return pre
};
```

### [#](http://interview.poetries.top/excellent-docs/18-计算机通识.html#_3-5-树)3.5 树

**二叉树的先序，中序，后序遍历**

- 先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。
- 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。
- 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点

**递归实现**

递归实现相当简单，代码如下

```js
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}
var traversal = function(root) {
  if (root) {
    // 先序
    console.log(root);
    traversal(root.left);
    // 中序
    // console.log(root);
    traversal(root.right);
    // 后序
    // console.log(root);
  }
};
```

> 对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了

**非递归实现**

> 非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。

以下是先序遍历代码实现

```js
function pre(root) {
  if (root) {
    let stack = [];
    // 先将根节点 push
    stack.push(root);
    // 判断栈中是否为空
    while (stack.length > 0) {
      // 弹出栈顶元素
      root = stack.pop();
      console.log(root);
      // 因为先序遍历是先左后右，栈是先进后出结构
      // 所以先 push 右边再 push 左边
      if (root.right) {
        stack.push(root.right);
      }
      if (root.left) {
        stack.push(root.left);
      }
    }
  }
}
```

以下是中序遍历代码实现

```js
function mid(root) {
  if (root) {
    let stack = [];
    // 中序遍历是先左再根最后右
    // 所以首先应该先把最左边节点遍历到底依次 push 进栈
    // 当左边没有节点时，就打印栈顶元素，然后寻找右节点
    // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点
    // 左边打印不出东西就把父节点拿出来打印，然后再看右节点
    while (stack.length > 0 || root) {
      if (root) {
        stack.push(root);
        root = root.left;
      } else {
        root = stack.pop();
        console.log(root);
        root = root.right;
      }
    }
  }
}
```

> 以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多

```js
function pos(root) {
  if (root) {
    let stack1 = [];
    let stack2 = [];
    // 后序遍历是先左再右最后根
	// 所以对于一个栈来说，应该先 push 根节点
    // 然后 push 右节点，最后 push 左节点
    stack1.push(root);
    while (stack1.length > 0) {
      root = stack1.pop();
      stack2.push(root);
      if (root.left) {
        stack1.push(root.left);
      }
      if (root.right) {
        stack1.push(root.right);
      }
    }
    while (stack2.length > 0) {
      console.log(s2.pop());
    }
  }
}
```

**中序遍历的前驱后继节点**

> 实现这个算法的前提是节点有一个 `parent` 的指针指向父节点，根节点指向 `null`

![img](https://user-gold-cdn.xitu.io/2018/4/24/162f61ad8e8588b7?w=682&h=486&f=png&s=41027)

> 如图所示，该树的中序遍历结果是 `4, 2, 5, 1, 6, 3, 7`

**前驱节点**

> 对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论

- 如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左节点 2 ，那么节点 2 的最右节点就是 5
- 如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 5 来说，没有左节点，且是节点 2 的右节点，所以节点 2 是前驱节点
- 如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 6 来说，没有左节点，且是节点 3 的左节点，所以向上寻找到节点 1 ，发现节点 3 是节点 1 的右节点，所以节点 1 是节点 6 的前驱节点

以下是算法实现

```js
function predecessor(node) {
  if (!node) return
  // 结论 1
  if (node.left) {
    return getRight(node.left)
  } else {
    let parent = node.parent
    // 结论 2 3 的判断
    while(parent && parent.right === node) {
      node = parent
      parent = node.parent
    }
    return parent
  }
}
function getRight(node) {
  if (!node) return
  node = node.right
  while(node) node = node.right
  return node
}
```

**后继节点**

> 对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论

- 如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么节点 3 的最左节点就是 6
- 如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 5 来说，没有右节点，就向上寻找到节点 2 ，该节点是父节点 1 的左节点，所以节点 1 是后继节点 以下是算法实现

```js
function successor(node) {
  if (!node) return
  // 结论 1
  if (node.right) {
    return getLeft(node.right)
  } else {
    // 结论 2
    let parent = node.parent
    // 判断 parent 为空
    while(parent && parent.left === node) {
      node = parent
      parent = node.parent
    }
    return parent
  }
}
function getLeft(node) {
  if (!node) return
  node = node.left
  while(node) node = node.left
  return node
}
```

**树的深度**

> 树的最大深度：该题目来自 Leetcode，题目需要求出一颗二叉树的最大深度

以下是算法实现

```js
var maxDepth = function(root) {
    if (!root) return 0
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
};
```

> 对于该递归函数可以这样理解：一旦没有找到节点就会返回 0，每弹出一次递归函数就会加一，树有三层就会得到3



